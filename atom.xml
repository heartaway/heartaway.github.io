<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heartaway</title>
  
  <subtitle>技术会被淘汰，但思想会一直永存（多思考，多总结，多分享）；只有技术才是硬通货，看到技术背后的思想价值；</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heartaway.cn/"/>
  <updated>2018-11-09T16:42:24.811Z</updated>
  <id>http://heartaway.cn/</id>
  
  <author>
    <name>心静志远</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>他人经受的，我必经受</title>
    <link href="http://heartaway.cn/2018/10/06/Think/2018-10-06-marriage-quarrel/"/>
    <id>http://heartaway.cn/2018/10/06/Think/2018-10-06-marriage-quarrel/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-11-09T16:42:24.811Z</updated>
    
    <content type="html"><![CDATA[<p>早上起床后，悠然自得地在阳台上晒着太阳看着柴静的《看见》这本书。突然楼上吵架吵的甚是厉害，这已经不是第一次听到楼上吵架了，每次都是伴随着咕咕嘟嘟的物品跌落到地板上声音、妇女歇斯底里的呼喊声、小孩声嘶力竭的哇哇哭闹声、间歇性的愤怒的男性咆哮声。</p><p>这一次吵闹的比之前几次都要凶，我感觉不太对劲，打开门，走上楼梯，准备去帮他们和解一下，心想：毕竟是一家人，没必要闹到这个份上。当我走到楼上时，女主站在门外，朝着门内哭喊道“你为什么打我，我出来没有打过你，你为什么打我”，他们的门没关，我看到他们玄关的台面上堆满了书籍，放不下的书籍已经被实实在在的塞在了竖立起来的书层上面，想必也是一定程度上的知识分子，我刚准备去拦架，就听到女主对着门外吼道：“我是在受不了你了，你给我走”，听到这些，我的脚步迈不开了，感觉自己想好的劝解的话不一定能凑效，反而可能让他们觉得不堪的场面，此刻他们需要的是冷静，然后控制住自己的情绪。</p><p>我重新回到阳台，继续翻看书籍《看见》，正好看到讲述十几位女性因为无法忍受自己的丈夫而杀害丈夫的故事，调查中的大部分女性都是在无数次沉默忍耐之后才爆发了最后的还击。我从小也经历过父亲喝醉酒，发了疯似的，拿着砍刀要杀人，当时母亲哭泣着抱着我躲在房间的角落里，我至今还清晰的记得那门框旁边残留的被刀砍下的凹痕；母亲的性格是那种凡事都隐忍，不主动把事情摊开来说的那种，我之前还嘲笑母亲懦弱的性格，后来我才明白这是“恐惧留下的阴影”，一个没有当过弱者的人，不会体会到这种恐惧。那些女犯人之所以环击，正是因为恐惧的一层层积累，积累到一定程度后，就会以暴力的方式爆发。</p><p>“叮咚，叮咚”，一阵门铃响声打断了我的思绪，我打开门，看到是天猫超市的配送员，他说打我手机没人接，担心我家的东西又丢了，现在都不敢放门口了，听到楼上的吵闹神，他说：“我也是离过婚的人，一个人来到异地杭州，无依无靠”。我不知道该说回答他，脑子中对婚姻这件事有了缕缕疑惑。</p><p>楼上的声音渐渐消停了下来，我也看到这篇报道的结尾了，结尾处柴静写到“他人经受的，我必经受”。在最近的几年里，我愈发的明白一个道理，那就是：<code>不要随意地站在自我的立场上使用自己那有限的人生经历去揣测与评判别人的人生，我们不曾经历过的一切都让我们的评论显得格外肤浅。</code></p><p>此时，老婆问我，“我们如果吵架了，你会怎么样？”，我笑了笑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上起床后，悠然自得地在阳台上晒着太阳看着柴静的《看见》这本书。突然楼上吵架吵的甚是厉害，这已经不是第一次听到楼上吵架了，每次都是伴随着咕咕嘟嘟的物品跌落到地板上声音、妇女歇斯底里的呼喊声、小孩声嘶力竭的哇哇哭闹声、间歇性的愤怒的男性咆哮声。&lt;/p&gt;
&lt;p&gt;这一次吵闹的比之
      
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>如何解决技术焦虑</title>
    <link href="http://heartaway.cn/2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/"/>
    <id>http://heartaway.cn/2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-11-09T14:28:42.230Z</updated>
    
    <content type="html"><![CDATA[<p>从事软件编程已经长达8年之后，曾经中间有很长一段时间感觉自己的技术能力没有得到根本性提升，与那些优秀的同龄人相比，技术自卑油然而生，面对日新月息的技术变更和时不我待的岁月流逝，步入中年的我不得不变的焦虑起来。回顾自己的编程生涯，刚毕业的头几年，通过自主学习实现了编程语言的基本掌握，紧接着使用学到的技术完成各种项目，然后日复一日，有时候也会看看技术书籍，但是终究未能突破语言层而知晓技术背后的本质。而后通过长时间的摸索与交流，寻找到了一些解决技术人技术焦虑的方法，这些问题和方法更多的是一种思维方式，一种看问题的视角，希望这些建议能够让我们有所收获和思考。</p><h2 id="技术焦虑的起因"><a href="#技术焦虑的起因" class="headerlink" title="技术焦虑的起因"></a>技术焦虑的起因</h2><h4 id="技术热情变低"><a href="#技术热情变低" class="headerlink" title="技术热情变低"></a>技术热情变低</h4><p>有人说：职业倦怠是做了大量重复劳动缺乏调整，或者努力完成高风险问题最后却以失败告终而导致的。在软件行业，接触了很多人，发现一开始大家对技术都非常热情，当把它编程职业后，时间一长，就索然无味了，但是又不得不从事这个行业，毕竟还要养家糊口。缺乏热情，可能是我们进入了瓶颈期，在大量重复劳动当中，自然提不起什么兴趣。我们可以有两种方法破局：1. 主要要求承担自己感兴趣又没做过的事情。阿里有一句老话，“今天最好的表现是明天最低的要求”，我们要时刻突破自己所在的“舒适区”，让自己跳跃到“学习区”。2. 为自己而工作。为别人工作就很容易消耗的我们的热情，如果我们转变思路，把学习工作转变为为自己工作，就会有所动力。我过观察到的是，那些在专业领域上付出了极大热情的人，往往因为这个工作领域的投入而成就了自己的影响力，难道这不是在为自己工作，为自己打造信用背书，为自己打造个人品牌吗。</p><h4 id="新技术层出不穷"><a href="#新技术层出不穷" class="headerlink" title="新技术层出不穷"></a>新技术层出不穷</h4><p>新技术的迭代更新速度远远超过了我们获取新知识的速度，然而我们并没有过多时间去深入学习每一门技术。当我们还没有把Java并发包下的每一个核心类的原理弄清楚的时候，Java库已经从7升级到了10，我们还在谈服务化的时候，微服务、ServiceMesh、Serverless、FaaS这些新技术迎面而来，让我们应接不暇。工作多年的你，想一想，自己多久没有利用业余时间系统性的学习一门新技术了，我们往往以为通过多看微信朋友圈中的技术转发帖就能获取精华知识，以为我们自己在学习，其实这只是我们在安慰我们那颗想学习有不想付出太多精力的心而已。</p><h4 id="加班太多，没时间学习"><a href="#加班太多，没时间学习" class="headerlink" title="加班太多，没时间学习"></a>加班太多，没时间学习</h4><p>在之前离开阿里出去创业的几年时间里，几乎把能用的时间都用在了做业务系统，有很长一段时间，每天工作12小时以上，一周工作6天，深切能体会到长时间做业务系统的研发那种迫不得已。在面对各种Deadline时，我们做技术调研、技术方案也就马马虎虎过去了，恨不得一拿到需求就开始编码，每天拼命加班完成那些似乎并不那么重要的需求，反而搁浅了那些更重要的事情。一接到任务就开始 Coding 的程序员，通常就是加班最多的程序员，<strong>切记积极工作和勤于思考都要占时间</strong>。加班占用了我们太多的精气神，即便是有一时的闲暇，也想着让疲惫的身心得到一丝舒缓，哪再有学习的动力，我们似乎陷入已经坠入了加班与没有时间学习带来的焦虑陷阱。</p><p>有一些团队文化中，非常推崇加班文化，甚至开始攀比谁加班多，似乎谁加班多谁付出就多绩效就好。我曾经竟然可笑的认为通过加班付出的越多，自己的价值也就越大，团队也就越信任你，其实这是非常错误的思维，<strong>常态加班只能证明我们不会选择或者效率低下</strong>。考核一个人对业务和团队付出多少是拿业务结果来说话的，并不是那加班。认真想一想通过加班透支太多个人时间这件事情，我们为什么要加班？<strong>我们之所以加班，是因对之前承诺的内疚</strong>；加班让我们成为了一个只会低头做事情的人，让我们缺少了抽身看全局的机会。从时间投资的角度讲，常态加班，也是对我们自身时间的极大浪费，我们应该学会选择，学会拒绝，学会借力，做最重要的事情，给自己预留空闲时间，用来做自己喜欢做的事情。</p><h2 id="解决技术焦虑"><a href="#解决技术焦虑" class="headerlink" title="解决技术焦虑"></a>解决技术焦虑</h2><p>在意识在自我对技术的焦虑后，开始关注如何解决这种焦虑感，解铃还须系铃人，那些往往让我们害怕或者恐慌的东西才是我们需要去弥补的。技术焦虑也是一样，是一种技术不自信，是自己技术上有很多短板和盲区，伴随着中年危机的到来，害怕因为专业性的不成熟而被整个行业淘汰。去年华为去大龄码农，去的正是那些不能提供技术专业性的员工。解决办法自然是通过沉下心来，慢慢的把基础中的短板不起来，拓宽自己知识宽度的同时，挖掘技术深度。在整个学习过程中，一些几点也许能让我们跟轻松跟高效的来面对技术的学习以及技术焦虑的消除。</p><h4 id="寻找兴趣点"><a href="#寻找兴趣点" class="headerlink" title="寻找兴趣点"></a>寻找兴趣点</h4><p>很多时候，技术之所以对我们的吸引力不够，不能让我们为之废寝忘食的一个原因，那就是我们没有找到一个自己感兴趣的点。比如，我之前有一段时间对技术几乎麻木了，没有任何动力去翻看技术文章，遇到大家都转载的博文，也就是顺手收藏起来，明知道自己不会再看，还是自我安慰到兴许后续会有时间学习，一年下来技术基本没什么积累，我甚至开始怀疑自己是否适合程序员的岗位。直到有一天，朋友向我推荐了一本书《编码·隐匿在计算机背后的语言》，这本书从手电筒开合讲到继电器编解码，再讲到计算机的构造，让我大跌眼镜，以前觉得计算机非常高深莫测，看完这本书之后才觉得原来如此，我竟然有了在淘宝上购买继电器回家自己一台计算机的冲动。应用举一反三以及类比的方法，把“编码”、“解码”的思维应用在生活的各个细节当中，发现很多道理都是想通的。有人对它的评价是“这本书花两个半天读上一般的内容，你的人生就赚到了”。</p><p>自此，我似乎重新拾起了对计算机的兴趣。然后重新找回一些计算机理论知识中的经典书籍，一本一本开始看，以前觉得深不可测、遥不可及的知识点，掌握其理念之后，觉得也就那么回事。所谓技术自信，就是自身具备盖世武功，面对对手的花样进攻，坦然处之了的心态。</p><h4 id="调整学习方式"><a href="#调整学习方式" class="headerlink" title="调整学习方式"></a>调整学习方式</h4><p>作为一名技术从业者，“终身学习”的道理自然不必多讲。那如何学习呢，学习有哪些方式呢？这个问题我出来没有认真考虑过，难道还有人不会学习吗？引发我对学习方式的思考，是源于跟同事的一次闲聊。同事说“我喜欢<strong>整体性学习</strong>，对一门新技术，势必先全部通读一遍，然后知晓其原理在开始编码，防坑，可控性更强”，我想了想我的学习方式，说“我自己属于<strong>模仿性学习</strong>，现学现用，不懂就查”；为什么会有这两种学习方式呢？他们之间有什么区别，哪一种效率更高呢？带着这些疑问，我查阅了《如何高效学习》、李善友老师的《混沌大学》、许岑老师的《如何成为有效学习的高手》、小马宋的《朋友圈的尖子生》等多本有关学习方法的书，最后得出一个结论：一切事情都有方法论或套路，我们需要看清楚变化事物背后不变的本质。所谓<strong>套路</strong>，就是大家从历史中总结出来的可复制的经验，我们每一个个体按照套路行事，也能学会的东西。比如围棋的定式、程序中的算法、设计模式、菜谱等等，这些都称得上是套路。</p><p>那学习方式目前主要分为两类，一类是自然主义学习；一类是结构主义学习。自然主义学习是基于模仿，通过向他人学习然后进行自我实践，比如我们学习说话、绘画、溜冰、弹钢琴等；而结构主义学习是系统性的构建并创造新的知识晶体，比如数学、物理、编程。针对学习任务的不同，采用合适的学习方法能让我们学习效率事半功倍。在回过来看看自己过往在软件编程上的学习策略，一直是在是在基于点的模仿性学习，而非像结构主义学习那样，讲究面，讲究整体性和系统性。只知道各个点的弊端是让我们看不到面的边界，不知道还有多少我们看不到，这不仅给我让我们对技术产生焦虑，也让自己的视野变得越来越窄；看似每天很努力的工作和学习，其实效率不高、结果不好正是这个原因。所以，面对编程技术的学习，做好的做法是结构化学习，拿整块的时间来学、系统的学，学习技术的历史背景、技术的核心思想、技术的使用范围以及边界，然后再通过自然主义学习策略下的模仿进行逐步实践，方能让我们更快更好的获取到知识。</p><h4 id="看清事情本质"><a href="#看清事情本质" class="headerlink" title="看清事情本质"></a>看清事情本质</h4><p>我们重复编码了多年，还是不得要领，就像学习了各种武功，还是无法突破招数的局限一样，这可能就是我们只知道使用技术，而忽略了技术背后真正的核心思想。在过去一年中，我面试了很多的同学，发现很多技术从业者都有一个共性，那就是只会基本使用，不知其实现原理，即便有一些知晓原理，稍微变通一下后，就无法应答，说明还是理解不深。其实计算机技术知识跟其它门类的只是也是一样的，总有一个核心思想在里面，比如《论语》的核心就是“仁”和“礼”，《孙子兵法》中的借刀杀人的核心就是“敌已明,友未定,引友杀敌,不自出力”。</p><p>那么计算机编程的核心思想是什么呢？是那些变化多端的设计模式，是不断演化的架构形式？这些都不是，我查阅多本资料，发现其本质是 “程序 = 算法 + 结构”，然后拿着这个本质在去看spring 源码、Mybatis源码，寻找他们实现的核心数据结构是什么，算法又是什么，使用了什么套路(设计模式)，在横向上跟其它技术做一下比对。比如spring中有缓存、Mybatis中有两段缓存、数据库有缓存、Redis分布式缓存、操作系统有缓存、CPU有缓存，为什么要使用缓存，这些缓存实现之间有什么共同之处？这还只是局限在编程里面，在现实世界中是不是到处都有缓存的实例呢，比如我们背诵各种诗词歌赋或者数据乘法表，以便在大脑中缓存这些知识，要得就是在最短的时间提取出答案，即便是占用大脑的一些记忆空间。再比如我们去食堂吃饭排队，这个队列是FIFO还是具有优先级的队列，如果队列为空了，打饭的是否是不是处于阻塞状态，如果队列满了，后来的人怎么办？当我们从学习的事情中进行抽象化，看到事情的本质后，在进行举一反三，多领域多维度验证，我们就会觉得“大道至简”，很多道理都是相同的，即便复杂如计算机系统也是一样。</p><p>当然除了看清楚技术的本质，我们在团队沟通协作当中也是需要应用这一思维，比如一个人发表了一个观点，那我们就应该想一想他说出这个观点的本意是什么，他是怎么想的，为什么会提出这样观点，这个观点的核心理念是什么，如果我们要说服他改变观点，我们要怎么做。在日常生活当中多刻意练习这一思维习惯，并通过与当事人的正面沟通寻求其真实本意的想法来及时矫正自己的思维模式（及时反馈），时间一长，习惯就培养出来了，这个时候，我们说话办事就不会再冲动和肤浅了。</p><h4 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h4><p>伴随着长大，让我们逐渐养成了“趋利避害”的行为习惯，原本自身上的各种棱角也被残酷的现实社会磨得异常圆滑，在各种决策中，我们似乎养成了随大流的习惯；学习技术，我们跟大流，别人学什么，我们也学什么；离职创业，在我们还没有想清楚自己是不是合适的时候，总理说“万众创业、大众创新” ，我们就投入到了创业的大潮当中；我们似乎活在了别人的思维模式下。那我们自己也有大脑，为什么就不能好好想一想自己目前的处境，未来的规划呢？ 思考本身就是一件苦差事，我们身体的本能就是尽量大脑降低负荷，能不动脑就不动脑，我们要克服这种情况，如果大脑长时间不用，就会退化，让我们成为独立个体的正式我们透过独立思考展示出来的人格魅力。</p><p>我之前老板有一个习惯，就是每天吃完晚饭后，回到工作岗位上，给自己预留半个小时，让自己处于冥想状态，思考自己当前在做什么，为什么做，需求本质是什么，能不能不做，做的怎么样，是不是有更高效的做法，同行业是怎么做的，整个市场是怎么样的，未来三到五年会有什么变化。 他建议我也尝试此方法，我在尝试此方法之前，就感觉每天忙忙碌碌，也不知道为什么忙，做日常工作似乎只是为了生计或者不得不做，通过这样的训练，发现自己成为了这件事情的主人，看到了很多之前不曾看到的东西，之前只能这低头走路，看路好不好走，而忽略了路的方向以及路边精彩的风景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从事软件编程已经长达8年之后，曾经中间有很长一段时间感觉自己的技术能力没有得到根本性提升，与那些优秀的同龄人相比，技术自卑油然而生，面对日新月息的技术变更和时不我待的岁月流逝，步入中年的我不得不变的焦虑起来。回顾自己的编程生涯，刚毕业的头几年，通过自主学习实现了编程语言的基
      
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis 核心理念</title>
    <link href="http://heartaway.cn/2018/04/09/Java/2018-04-09-mybatis-core-thought/"/>
    <id>http://heartaway.cn/2018/04/09/Java/2018-04-09-mybatis-core-thought/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-11-09T14:24:37.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mybatis的本质：混合型Java对象持久化工具；</p></blockquote><h3 id="前置说明："><a href="#前置说明：" class="headerlink" title="前置说明："></a>前置说明：</h3><p>需要提前具备SQL、JDBC、RDBMS、XML、OOP等知识；</p><h3 id="什么是Mybatis："><a href="#什么是Mybatis：" class="headerlink" title="什么是Mybatis："></a>什么是Mybatis：</h3><p>核心点：</p><ul><li>支持了SQL、存储过程、对象/关系映射的持久化框架；</li><li>消除了几乎所有的JDBC代码和需要手工处理的参数和结果；</li><li>支持XML和注解两种方式来配置sqlmap、mapper、pojo三者之间的关系。</li></ul><p>Mybatis理念：坚信SQL、RDBMS将继续使用<strong>30年</strong>；</p><h3 id="Mybatis-核心概念"><a href="#Mybatis-核心概念" class="headerlink" title="Mybatis 核心概念"></a>Mybatis 核心概念</h3><p>数据模型：</p><ul><li>Configuration</li><li>SqlSessionFactory</li><li>SqlSession</li><li>MappedStatement</li></ul><p>运行期四大组件：</p><ul><li>Executor </li><li>StatementHandler </li><li>ParameterHandler </li><li>ResultSetHandler</li></ul><p>算法：</p><ul><li>Java静态&amp;动态代理</li><li>待补充</li></ul><h3 id="Mybatis-发展历程"><a href="#Mybatis-发展历程" class="headerlink" title="Mybatis 发展历程"></a>Mybatis 发展历程</h3><p>ibatis → mybatis</p><p>ibatis 于2002年由 Clinton Begin创建；<br>ibatis 于2010年暂停维护，专有apache维护，改名为mybatis，版本定位mybatis 3；</p><h3 id="Mybatis-工作流程"><a href="#Mybatis-工作流程" class="headerlink" title="Mybatis 工作流程"></a>Mybatis 工作流程</h3><p><img src="/images/posts/20180409/mybatis-work-flow.jpg" alt=""><br>​    （选自CSDN：亦山）</p><h3 id="Mybatis-中的设计思想"><a href="#Mybatis-中的设计思想" class="headerlink" title="Mybatis 中的设计思想"></a>Mybatis 中的设计思想</h3><ol><li>外部化SQL&amp;参数配置化，将设置与运行策略分离；</li><li>采用配置化原因：降低编码复杂度，提高可读性和可维护性；</li><li>封装SQL；基于接口编程，屏蔽SQL对外部的具体实现；</li><li>随处可见的工厂模式、builder模式、Proxy模式、装饰器模式；</li><li>将大系统设计为多个子系统，每个子系统的功能相对集中，尽可能将那些需要由不同的开发角色处理的任务分离开来。</li><li>Cache的实现模式：链式静态代理，原始对象PerpetualCache；<ul><li>代理模式三要素：共同接口，真实对象、代理对象（装饰器模式）；</li><li>我们可以采用对象工程屏蔽代理类的生成；</li><li>静态代理的本质：不侵入代码的情况下，扩展原对象功能；</li></ul></li><li>Plugin实现采用Java动态代理方式，责任链模式实现；</li><li>基于注解或者路径的自动扫描；</li></ol><h3 id="Mybatis主要功能"><a href="#Mybatis主要功能" class="headerlink" title="Mybatis主要功能"></a>Mybatis主要功能</h3><ul><li>使用XML或Java API配置Mybatis</li><li>使用XML或注解配置SQL映射器（Mapper）</li><li>基于OGNL表达式的动态SQL构建</li><li>事务支持</li></ul><h5 id="Executor层次"><a href="#Executor层次" class="headerlink" title="Executor层次"></a>Executor层次</h5><p><img src="/images/posts/20180409/mybatis-executor-topo.jpg" alt=""></p><p>CachingExecutor 是正式Executor实现类的一个代理wrapper。</p><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>4个核心关键词:</p><ol><li>if </li><li>choise(when,otherwise)</li><li>trim（where,set）</li><li>foreach</li></ol><h5 id="缓存体系"><a href="#缓存体系" class="headerlink" title="缓存体系"></a>缓存体系</h5><ol><li><p>本地缓存；<br> 作用域：SqlSession内数据本地缓存；<br> 数据结构：PerpetualCache （HashMap）<br> 作用：利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。<br> 配置： localCacheScope=STATEMENT|SESSION设置作用域，建议使用STATEMENT，防止分布式环境下导致的脏读；</p></li><li><p>二级缓存<br> 作用域：namespace；SqlSession间数据缓存；<br> 默认底层缓存结构：LruCache包装的PerpetualCache<br> 选择：在分布式环境下，建议使用外部分布式缓存系统，而非Mybatis的本地缓存；</p></li></ol><h5 id="作用域：scope"><a href="#作用域：scope" class="headerlink" title="作用域：scope"></a>作用域：scope</h5><ul><li>SqlSessionFactory 建议应用级别；   </li><li>SqlSession 请求或方法级别（非线程安全）；</li><li>Mapper Instance 方法级别；</li></ul><h4 id="与Spring集成"><a href="#与Spring集成" class="headerlink" title="与Spring集成"></a>与Spring集成</h4><p>下回详解；</p><p>官方文档:<a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><p>版本说明：<a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><h4 id="工程示例："><a href="#工程示例：" class="headerlink" title="工程示例："></a>工程示例：</h4><p>大家可以基于测试工程自行联系相关设计理念以及工作原理：</p><p><a href="https://github.com/heartaway/mybatis-study-demo" target="_blank" rel="noopener">https://github.com/heartaway/mybatis-study-demo</a></p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档:"></a>参考文档:</h4><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html</a></p><p><a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><p><a href="https://blog.csdn.net/column/details/mybatis-principle.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/mybatis-principle.html</a></p><p>《iBatis实战》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Mybatis的本质：混合型Java对象持久化工具；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前置说明：&quot;&gt;&lt;a href=&quot;#前置说明：&quot; class=&quot;headerlink&quot; title=&quot;前置说明：&quot;&gt;&lt;/a&gt;前置说明：&lt;/h3&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云多机房部署网络架构</title>
    <link href="http://heartaway.cn/2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/"/>
    <id>http://heartaway.cn/2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-11-09T14:17:55.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/posts/20180329/aliyun-mutil-region.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/posts/20180329/aliyun-mutil-region.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>POJO 对象setter 方法是否合适return &quot;this&quot;</title>
    <link href="http://heartaway.cn/2018/03/22/Java/2018-03-22-java-bean-setter-return/"/>
    <id>http://heartaway.cn/2018/03/22/Java/2018-03-22-java-bean-setter-return/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-11-09T14:24:30.095Z</updated>
    
    <content type="html"><![CDATA[<p>通常的POJO对象setter方法return 为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是面对对象属性填充时，一堆的set方法让代码看起来很臃肿，部分同学采用类build模式，对setter方法进行改造，改造后就可以使用链式处理简化属性设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流式编码风格如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Employee().setName(<span class="string">"Xin yuan"</span>).setHeight(<span class="number">178</span>);</span><br></pre></td></tr></table></figure><p>有人认为这让pojo方法设置变得更加便捷，有其使用之处，但是也有人认为<code>return this</code>打破了<a href="https://docstore.mik.ua/orelly/java-ent/jnut/ch06_02.htm" target="_blank" rel="noopener">Java Bean</a>的规约，破坏了每个函数单一职责的原则，也可能会破坏一些工具库的使用，或组织JVM做一些优化。而且在IDE中getter&amp;setter的自动生成内容中并没有“return this”。综其所述，setter方法“return this”并不建议。</p><p>当然还有其它选择方案：</p><p><strong>方法一：</strong></p><p>采用java内置语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Employee()</span><br><span class="line">&#123;&#123;</span><br><span class="line">    setName(<span class="string">"Jack Sparrow"</span>);</span><br><span class="line">    setId(<span class="number">1</span>);</span><br><span class="line">    setFoo(<span class="string">"bacon!"</span>);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>采用更加复杂的内部类builder模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(Strig name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>造者模式(Builder Pattern)：将一个<strong>复杂对象</strong>的<strong>构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。但是一般POJO 类都比较简单，非复杂对象，所以采用builder模式并不会让代码变得简洁，反而会显得更加臃肿。</p><p><strong>方法三：</strong></p><p>属性新增withXxx方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">withName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    setName(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="keyword">new</span> Employee().withName(<span class="string">"Xin yuan"</span>).withHeight(<span class="number">178</span>);</span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>不建议在POJO： Java Bean的setter方法中添加‘return this’，我们遵循Java规范，如果期望简化Java Bean的属性设置，可以采用with或build方法。</p><p><strong>参考：</strong></p><p><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Plain_old_Java_object</a></p><p><a href="https://stackoverflow.com/questions/1345001/is-it-bad-practice-to-make-a-setter-return-this" target="_blank" rel="noopener">https://stackoverflow.com/questions/1345001/is-it-bad-practice-to-make-a-setter-return-this</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常的POJO对象setter方法return 为void&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS应用自动发现服务</title>
    <link href="http://heartaway.cn/2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/"/>
    <id>http://heartaway.cn/2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-11-09T14:17:45.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：AWS Application Discovery Service 收集并呈现数据，以使企业客户能了解其本地环境中服务器的配置、使用和行为。</p></blockquote><h2 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h2><h3 id="无代理自动发现"><a href="#无代理自动发现" class="headerlink" title="无代理自动发现"></a>无代理自动发现</h3><p>原理：基于 VMware vCenter Server 的环境的数据上报；</p><p>弊端：</p><ul><li>采用VMware 方式在国内并不常用；</li><li>采集到的数据有限，只是系统层面的静态数据与CPU、MEM的指标数据；</li></ul><h3 id="基于代理-Agent-的发现模式："><a href="#基于代理-Agent-的发现模式：" class="headerlink" title="基于代理(Agent)的发现模式："></a>基于代理(Agent)的发现模式：</h3><p>通过Agent可以采集更加丰富的数据集合，比如系统进程，系统间的网络连接；这里重点了解Agent模式。</p><h2 id="采集的数据："><a href="#采集的数据：" class="headerlink" title="采集的数据："></a>采集的数据：</h2><ul><li>静态配置数据： <ul><li>系统标识信息：主机名、IP地址、MAC地址、操作系统名称、操作系统版本号，cpuType；</li><li>运行中的进程数据；</li><li>系统间的网络调用（TCP/IP v4 和 v6）；<ul><li>sourceIP、sourceProcess、destinationIp、destinationPort、dstProcess，ipVersion；</li></ul></li></ul></li><li>性能指标数据：<ul><li>操作系统层面：<ul><li>参考之前的OS监控采集项；</li></ul></li><li>进程层面：<ul><li>%CPU</li><li>%MEM</li><li>%DISK  </li></ul></li><li>网络层面：<ul><li>待补充  </li></ul></li></ul></li></ul><h3 id="数据安全性："><a href="#数据安全性：" class="headerlink" title="数据安全性："></a>数据安全性：</h3><p>采用SSL协议进行数据传输；<br>数据存储采用AWS KMS静态加密；</p><h2 id="Agent模式下的自动发现"><a href="#Agent模式下的自动发现" class="headerlink" title="Agent模式下的自动发现"></a>Agent模式下的自动发现</h2><p>Agent启动时，自动注册到Arsenal中，并频繁对该服务执行 ping 操作以获取配置信息。<br><img src="https://gw.alipayobjects.com/zos/skylark/2a647cf5-d9b2-42f6-bcab-39a16b5ead2b/2018/png/179f1e58-a729-4ab0-8dea-b604269d0ad9.png" alt=""></p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>数据的收集需要自动显示开启；</p><h4 id="数据采集状态："><a href="#数据采集状态：" class="headerlink" title="数据采集状态："></a>数据采集状态：</h4><ul><li>STARTED – 收集工具已开始收集和发送数据到 Discovery Service。</li><li>START_SCHEDULED – 已计划数据收集开始时间。下次收集工具联系 AWS 时，它将开始将数据发送到 Discovery Service，并且收集状态将更改为 STARTED。</li><li>STOPPED – 收集工具已停止发送数据到 Discovery Service。</li><li>STOP_SCHEDULED – 已计划数据收集停止时间。下次收集工具联系 AWS 时，它将停止向 DiscoveryService 发送数据，并且收集状态将更改为 STOPPED。</li></ul><h3 id="组件分类"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类</h3><p>DiscoveryService识别组件后，通过TAG标签的方式，对资源进行标记；用户也可以同通过控制台进行自定义TAG标记；</p><p><strong>进程数据分类方法：</strong> 通过采集到的进程数据，可以推测出aws判断进程属于哪一类基础设施应该是通过进程名称与commondLine来判断的。</p><h3 id="Agent模式自动发现不足："><a href="#Agent模式自动发现不足：" class="headerlink" title="Agent模式自动发现不足："></a>Agent模式自动发现不足：</h3><ul><li>不能保存资源组件快照或跟踪资源变更；</li><li>收集的性能数据不是通用的运行状况监控解决方案；</li></ul><h2 id="自动发现API"><a href="#自动发现API" class="headerlink" title="自动发现API"></a>自动发现API</h2><ol><li>Agent相关API<ul><li>Agent的启动、停止数据采集操作；</li><li>Agent的描述信息；</li><li>Agent的运行状态；</li></ul></li><li>配置相关API<ul><li>server、application、process、connection 的指标查询、过滤与配置；</li></ul></li><li>标签相关API<ul><li>TAG的增删改查； </li></ul></li></ol><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>产品链接：<a href="https://aws.amazon.com/cn/documentation/application-discovery/" target="_blank" rel="noopener">https://aws.amazon.com/cn/documentation/application-discovery/</a></p><p>API地址：<a href="https://docs.aws.amazon.com/zh_cn/application-discovery/latest/APIReference/discovery-api.pdf#discovery-api-queries" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/application-discovery/latest/APIReference/discovery-api.pdf#discovery-api-queries</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义：AWS Application Discovery Service 收集并呈现数据，以使企业客户能了解其本地环境中服务器的配置、使用和行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工作模式：&quot;&gt;&lt;a href=&quot;#工作模式：&quot; 
      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>《基于中间件的基础设施自动发现》</title>
    <link href="http://heartaway.cn/2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/"/>
    <id>http://heartaway.cn/2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-11-09T14:26:02.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>论文地址：<br><a href="https://patents.google.com/patent/US7912749B2/en" target="_blank" rel="noopener">https://patents.google.com/patent/US7912749B2/en</a></p></blockquote><h4 id="论文主体内容："><a href="#论文主体内容：" class="headerlink" title="论文主体内容："></a>论文主体内容：</h4><p>通过分析中间件网络数据，建立信息模型；从网络数据中判断组件性能阈值、基础设施组件之间的依赖关系以及业务流程与基础设施的映射关系；</p><p>建议采用分层（图层）模型；（比如Dynatrace中的5层模型）</p><h4 id="架构基线特征"><a href="#架构基线特征" class="headerlink" title="架构基线特征"></a>架构基线特征</h4><ol><li>基于对象的；<ul><li>对象也就是架构实体或者信息模型的组合；</li></ul></li><li>策略驱动的；</li><li>安全的；</li><li>自我管理的；</li><li>自我描述；<ul><li>自我描述有利于新组件加入后的关系挖掘，而不依赖人工的定义与配置；</li></ul></li><li>能够提供信息透明度；</li></ol><p>架构基线是简化系统主要部分的识别和结构化组织的催化剂。</p><p>架构发现本质上是对信息的识别和分类过程，识别和分类过程最好与任何特定的知识库，上下文，协议或平台 无关。</p><h4 id="模型划分"><a href="#模型划分" class="headerlink" title="模型划分"></a>模型划分</h4><p>可以提供元模型来定义用于在业务管理环境中指定模型的语言。元模型可以具有描述动态语义的能力。元模型图层中的一些对象示例包括类，属性，操作，关联，组件等</p><p>可以提根据核心模型来定义抽象类的集合，核心模型是分析师确定如何扩展核心模型以创建领域模型的起点。抽象类的一些例子，比如交易、客户等；</p><p>按照信息的抽象程度划分：<br>元模型 &gt; 信息模型 &gt; 核心模型 &gt; 领域模型；</p><p>信息模型和核心模型通常更稳定，这两个模型是定义域模型的来源，这些模型也提供了跨不同领域的元素视图，可发现有价值的业务相关数据。</p><h4 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h4><p>从多个数据源创建有用的信息非常关键。但是，业务相关性需要适当、一致且相关的信息，而不是分散的数据。<strong>信息透明度服务</strong>可以将离散的实时或历史数据源分离出来，作为有用的信息源。该过程涉及通过使用明确定义的‘聚合’和‘转换规则’以及信息模型作为信息交换的基础来聚合和转换数据源。</p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>软件模块存储在数据库中。库中的各个模块称为模式，而库本身称为模式目录。模式可以根据其规模和抽象进一步分类为</p><ul><li>架构模式</li><li>设计模式</li><li>语言模式</li></ul><p>架构模式：表达了软件系统的基本结构组织模式。它提供了一组预定义的子系统，指定了他们的职责，并包括组织它们之间关系的规则和准则。</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>基础设施的自动发现，可衍生出通过诊断分析进行故障定位或影响分析等功能。可以提供自我修复程序，并且可以通过动态资源管理和嵌入式服务意识来解决基础结构优化问题。比如Dynatrace的故障定位；</p><h4 id="扩展产品了解："><a href="#扩展产品了解：" class="headerlink" title="扩展产品了解："></a>扩展产品了解：</h4><p><a href="https://www.dynatrace.com/capabilities/application-topology-discovery/smartscape/" target="_blank" rel="noopener">dynatrace</a><br><a href="https://docs.aws.amazon.com/application-discovery/latest/APIReference/discovery-api-queries.html" target="_blank" rel="noopener">amazon-application-discovery</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;论文地址：&lt;br&gt;&lt;a href=&quot;https://patents.google.com/patent/US7912749B2/en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://patents.google.co
      
    
    </summary>
    
      <category term="Paper" scheme="http://heartaway.cn/categories/Paper/"/>
    
    
  </entry>
  
  <entry>
    <title>自用型监控系统方案</title>
    <link href="http://heartaway.cn/2018/03/14/HighAvailability/2018-03-14-monitor-system/"/>
    <id>http://heartaway.cn/2018/03/14/HighAvailability/2018-03-14-monitor-system/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-11-09T14:17:34.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、监控系统整体概述"><a href="#一、监控系统整体概述" class="headerlink" title="一、监控系统整体概述"></a>一、监控系统整体概述</h2><blockquote><p>系统背景：<br>在当前项目中，当我们对特定流程注入故障后，如何评估故障的效果以及系统应对故障的表现？传统方式是用户需要登录线上机器或者各种监控系统去查看具体的指标信息，然后通过人工判断，来判断故障的影响范围，产品使用上不够自动化，且没有闭环。我们期望引入监控系统，把之前需要人来做的事情交给系统来做，为故障注入后的影响进行量化分析。</p></blockquote><p>整个监控系统对数据处理的四个步骤：<br><img src="https://gw.alicdn.com/tfscom/TB1nArGof2H8KJjy0FcXXaDlFXa.png" alt=""></p><p>系统架构图：<br><img src="https://gw.alipayobjects.com/zos/skylark/155aa3d2-3444-4bd5-9588-ae9dfa39a0b2/2018/png/c59df181-ff42-4f6d-be01-3314a92f5e03.png" alt=""></p><p><strong>组件说明：</strong></p><p><strong>API Gateway</strong>：agent 与 Server 所有交互都会通过API Gateway，统一由API Gateway进行管控，为整个MK提供一致的数据门面接口，实现之前约定的数据总线的方案。</p><p><strong>Data Collector</strong>：为数据采集器，接受来自客户端推送上来的监控数据 或 拉去外部监控数据；</p><p><strong>Data Transfer</strong>： 数据转换器，把采集到的非一致性架构的数据转换为统一的数据模型；</p><p><strong>Config</strong>： 此模块主要提供一些Agent、Collector、Analyzer需要的一些元数据；</p><p><strong>Schedule</strong>： 依赖Schedule，主要是期望能把周期性数据拉取采集任务转换为 schedule任务，降低重复编写分布式任务调度的复杂度，其次，借助schedule实现周期任务分发的负载均衡；</p><p><strong>Diamond</strong>：采用Diamond作为数据采集规则的动态配置中心。</p><p><strong>MQ</strong>： 把数据采集器采集到的数据转换为统一的消息格式，解耦数据采集与数据分析对数据使用差异性；其次，当数据分析器Data Analyzer集群宕机或处理性能下降时，MQ能起到数据缓存池的作用，一定程度上防止采集上来的数据未能处理而导致的数据丢失。</p><p><strong>Data Analyzer</strong>： 数据分析器，对收集到的监控数据进行一定程度上的计算转换，并根据关注点规则，进行事件监控处理；</p><p>自研监控系统，需要面临一系列的抉择：<br><img src="https://gw.alipayobjects.com/zos/skylark/03a23023-065f-4333-a11a-86afff4f770f/2018/png/f2c31281-de0d-49e7-830d-49c2474b6ddb.png" alt=""></p><h2 id="二、行业监控系统架构："><a href="#二、行业监控系统架构：" class="headerlink" title="二、行业监控系统架构："></a>二、行业监控系统架构：</h2><h4 id="OneAPM"><a href="#OneAPM" class="headerlink" title="OneAPM"></a>OneAPM</h4><p><img src="https://gw.alipayobjects.com/zos/skylark/1c75fc4a-de85-408c-a859-d943a7bccec3/2018/png/2e24513f-0c46-4f25-acd2-0aa293962b01.png" alt=""></p><h4 id="CAT"><a href="#CAT" class="headerlink" title="CAT"></a>CAT</h4><p><img src="https://gw.alipayobjects.com/zos/skylark/33fb5a1d-2b4a-45dd-a94b-f0b660b47339/2018/png/e956684e-e5ce-4e10-b424-6d51b2949502.png" alt=""></p><p>参考：<a href="https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html" target="_blank" rel="noopener">https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html</a></p><h2 id="三、数据采集方案"><a href="#三、数据采集方案" class="headerlink" title="三、数据采集方案"></a>三、数据采集方案</h2><p>数据采集面的的挑战：</p><ul><li>数据源多种多样 </li><li>数据量大 </li><li>变化快 </li><li>如何保证数据采集的可靠性的性能 </li><li>如何避免重复数据 </li><li>如何保证数据的质量</li></ul><h3 id="3-1-采集方案"><a href="#3-1-采集方案" class="headerlink" title="3.1 采集方案"></a>3.1 采集方案</h3><p>目前常用的数据采集方式有两种：</p><ol><li>主动监控（客户端推模式-Push）；<ul><li>优势：<ul><li>实时性好；</li><li>对服务端的压力相对较小；</li><li>插件化支持用户自定义采集脚本；</li><li>监控自动发现；</li></ul></li><li>劣势：<ul><li>数据聚合与异常处理复杂；</li></ul></li></ul></li><li>被动监控（服务端拉模式-Pull）；<ul><li>优势：<ul><li>数据处理方便；</li><li>数据准确性、完备性更好；</li><li>Edas已经存在根据staragent进行数据拉去的实践方案；</li></ul></li><li>劣势：<ul><li>集群规模大时，服务器压力大，任务分发易积压，分发线程忙，带来一定数据延迟；</li><li>数据拉取时服务隔离难(twitter)；</li><li>无法区分服务失效和代理失效(twitter)；</li></ul></li></ul></li></ol><p>现有监控系统采集方案：</p><table><thead><tr><th>系统</th><th>采集方式</th><th>备注</th></tr></thead><tbody><tr><td>AliMonitor</td><td>Push</td><td></td></tr><tr><td>Ali-Sunfire</td><td>Pull</td><td></td></tr><tr><td>TLog</td><td>Pull</td><td></td></tr><tr><td>aliyun-sls-ilogtail</td><td>Push</td><td></td></tr><tr><td>Zabbix</td><td>push+pull</td><td></td></tr><tr><td>Open-falcon</td><td>Push</td><td></td></tr><tr><td>OneAPM</td><td>Push</td><td></td></tr><tr><td>Cacti</td><td>Pull</td></tr></tbody></table><p><strong>主动监控示意图（Push）：</strong><br><img src="https://gw.alicdn.com/tfscom/TB1MJZKonvI8KJjSspjXXcgjXXa.png" alt=""></p><p>服务端提供一个接受数据请求的域名地址，客户端把数据推送到服务端，服务端负责数据解析与存储；</p><p><strong>被动监控示意图（Pull）：</strong><br><img src="https://gw.alicdn.com/tfscom/TB19cEKonvI8KJjSspjXXcgjXXa.png" alt=""></p><p><strong>Agent一般具备的功能:</strong></p><ol><li>LogFinder: 能够根据请求的时间区间返回区间内的监控数据；</li><li>LogQuery: 能够根据偏移量定位到日志位置；</li><li>LogCompression： 支持日志数据压缩；</li></ol><p>此部分可以参考LogAgent的实现逻辑。</p><p><strong>我们的需求：</strong></p><ul><li>轻量级；</li><li>可扩展；</li><li>支持系统监控（OS）、业务监控（Agent）</li><li>支持Agent自动注册以及静态数据主动上报；</li><li>监控项受控开启与关闭，具备开关功能（非常态化挂载）；</li><li>需要具备数据堆积能力；</li><li>需要具备多数据源扩展能力；</li></ul><p><strong>方案结论：</strong></p><blockquote><p>客户端通过写本地磁盘日志的方式写指标数据，服务端通过 主动拉的方式到客户端上进行拉去数据；</p></blockquote><h3 id="3-2-分布式任务调度"><a href="#3-2-分布式任务调度" class="headerlink" title="3.2 分布式任务调度"></a>3.2 分布式任务调度</h3><p>我们采用服务端拉去日志的方式，所以需要一套对多个节点进行周期性调度拉取日志的框架。目前分布式定时调度服务阿里集团内有scheduleX以及开源的Quartz，考虑到服务单独输出减少依赖组件的需求，对Quartz的分布式持久化任务整合工作量评估后， 我们选择了使用quartz的方式。目前spring有对quartz进行整合，简化对quartz的使用。<br>不仅在监控数据采集上需要调度，在演练定时触发、演练监控定时开启等场景下都需要分布式任务调度服务，所以提供一套通用型的与业务无关的分布式调度服务API很有必要。<br>基于spring-quartz进行接口封装出统一的分布式调度服务接口服务SchedulerService， 这部分是单独的一个模块。</p><h3 id="3-3-数据Metric指标"><a href="#3-3-数据Metric指标" class="headerlink" title="3.3 数据Metric指标"></a>3.3 数据Metric指标</h3><p>客户端打印的日志非Metric格式，通过日志数据采集上来的数据需要通过转换器Transfer进行转换为统一的Metric格式；</p><p>当前监控系统采集的数据指标分为两类：</p><ul><li>系统OS监控指标；</li><li>应用性能指标；</li></ul><p>系统监控指标Metric含义：</p><table><thead><tr><th>category</th><th>Metric</th><th>Type</th><th>Tag</th><th>Description</th></tr></thead><tbody><tr><td>cpu</td><td>system.cpu.idle</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.system</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.user</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.util</td><td>GAUGE</td><td>host</td><td>cpu使用率</td></tr><tr><td>load</td><td>system.load.1min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.load.5min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.load.15min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>mem</td><td>system.mem.buffers</td><td>GAUGE</td><td>host</td><td>当前系统的buffer cache的内存数(单位kb)</td></tr><tr><td></td><td>system.mem.cached</td><td>GAUGE</td><td>host</td><td>当前系统的pagecache里的内存数(单位kb)</td></tr><tr><td></td><td>system.mem.free</td><td>GAUGE</td><td>host</td><td>当前系统的空闲内存(单位kb)</td></tr><tr><td></td><td>system.mem.total</td><td>GAUGE</td><td>host</td><td>当前系统的总内存(单位kb)</td></tr><tr><td></td><td>system.mem.used</td><td>GAUGE</td><td>host</td><td>当前系统的已经使用的内存(单位kb)</td></tr><tr><td></td><td>system.mem.util</td><td>GAUGE</td><td>host</td><td>当前系统的已经使用的内存占比</td></tr><tr><td>disk.partition</td><td>system.disk.partition.total</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘总字节数</td></tr><tr><td></td><td>system.disk.partition.free</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘空闲字节数</td></tr><tr><td></td><td>system.disk.partition.used</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘使用字节数</td></tr><tr><td></td><td>system.disk.partition.used_ratio</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘使用率</td></tr><tr><td>disk.io</td><td>system.disk.io.read_merge</td><td>GAUGE</td><td>host、device</td><td>每秒合并读完成次数</td></tr><tr><td></td><td>system.disk.io.write_merge</td><td>GAUGE</td><td>host、device</td><td>每秒合并写完成次数</td></tr><tr><td></td><td>system.disk.io.read</td><td>GAUGE</td><td>host、device</td><td>每秒读完成次</td></tr><tr><td></td><td>system.disk.io.write</td><td>GAUGE</td><td>host、device</td><td>每秒写完成次数</td></tr><tr><td></td><td>system.disk.io.util</td><td>GAUGE</td><td>host、device</td><td>io占比</td></tr><tr><td>processs</td><td>system.process.switches</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.process.total</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>traffic</td><td>system.net.in.bytes</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.out.bytes</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.in.packets</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.out.packets</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.packet.errs</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.packet.dropped</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>tcp</td><td>system.tcp.active_opens</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒主动建连的连接数</td></tr><tr><td></td><td>system.tcp.passive_opens</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒被动建连的连接数</td></tr><tr><td></td><td>system.tcp.current_estab</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒处于ESTABLISHED和CLOSE-WAIT状态的TCP连接数</td></tr><tr><td></td><td>system.tcp.estab_resets</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒reset次数</td></tr><tr><td></td><td>system.tcp.out_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒发送的tcp包数量</td></tr><tr><td></td><td>system.tcp.in_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒接收到的tcp包数量</td></tr><tr><td></td><td>system.tcp.attempt_fails</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒建连失败次数</td></tr><tr><td></td><td>system.tcp.retran_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒重传的包数量</td></tr><tr><td>udp</td><td>system.udp.in_dgm</td><td>GAUGE</td><td>host</td><td>收到的udp报数目</td></tr><tr><td></td><td>system.udp.out_dgm</td><td>GAUGE</td><td>host</td><td>发送的udp报数目</td></tr><tr><td></td><td>system.udp.noport</td><td>GAUGE</td><td>host</td><td>udp协议层接收到目的地址或目的端口不存在的数据包</td></tr><tr><td></td><td>system.udp.in_errs</td><td>GAUGE</td><td>host</td><td>udp层接收到的无效数据包的个数</td></tr></tbody></table><p>应用性能监控指标Metric含义：</p><table><thead><tr><th>category</th><th>Metric</th><th>Type</th><th>Tag</th><th>Description</th></tr></thead><tbody><tr><td>servlet</td><td>app.servlet.request.count</td><td>COUNTER</td><td>host、transaction，device</td><td>时间区间内，请求总次数</td></tr><tr><td></td><td>app.servlet.request.durations</td><td>COUNTER</td><td>host、transaction，device</td><td>时间区间内，请求总时间</td></tr><tr><td></td><td>app.servlet.request.rt.mean</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的平均rt</td></tr><tr><td></td><td>app.servlet.request.rt.max</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的最大rt</td></tr><tr><td></td><td>app.servlet.request.rt.min</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的最小rt</td></tr><tr><td></td><td>app.servlet.request.error_count</td><td>COUNTER</td><td>host、transaction，device</td></tr></tbody></table><p>其中device存储agentId，transaction存储请求名称；</p><p><strong>Metric命名规范</strong></p><p>key和tag只支持：[a-z][A-Z][0-9][-_./], 不能有空格, 大小写敏感, key原则上不包含大写。<br>格式为xxx.category[.sub_category]*, category和sub_category里面如果有多个单词，用下划线’_’连接， 不要用’.’连接。<br>需要动态聚合的维度， 放在tag里面， 同时在tagKey也在key中体现。 不需要聚合的维度， 放在key里面。</p><h3 id="3-4-数据转换transfer"><a href="#3-4-数据转换transfer" class="headerlink" title="3.4 数据转换transfer"></a>3.4 数据转换transfer</h3><p>针对不同类型的类型，采用工厂方法提供自适配的解析器。针对system系统监控，继续拆分为领域适配器，比如针对CPU域、mem域提供不同的处理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetricTransfer</span> <span class="keyword">extends</span> <span class="title">Transfer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * format  data to metric list</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;MetricObject&gt; <span class="title">format</span><span class="params">(MetricMeta metricMeta, String sourceData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、数据分析方案"><a href="#四、数据分析方案" class="headerlink" title="四、数据分析方案"></a>四、数据分析方案</h2><h3 id="4-1-分析方案："><a href="#4-1-分析方案：" class="headerlink" title="4.1 分析方案："></a>4.1 分析方案：</h3><p>现有的监控系统数据分析模块主要分为两类：</p><ul><li>批处理模型；</li><li>流处理模型（Spark Streaming、Storm、Flink）；<br><img src="https://gw.alicdn.com/tfscom/TB1kLTkodbJ8KJjy1zjXXaqapXa.png" alt=""></li></ul><p>结论：考虑到我们要求部署节点少、拓扑简单以及本期研发周期时间紧，我们采暂且不采用流式处理方案，数据获取到后，直接给到后端进行分析处理；</p><h3 id="4-2-监控点分析："><a href="#4-2-监控点分析：" class="headerlink" title="4.2 监控点分析："></a>4.2 监控点分析：</h3><p>用户可以通过配置监控指标，来对关心的系统指标进行阈值判断，比如选择一批机器，关注CPU利用率超过90%，那么监控系统就需要把这批机器在演练期间CPU利用率超过90%的指标都找出来，并转换为Event事件。这点类似于监控系统中的报警系统模型。</p><p>数据分析器中处理监控指标的流程如下：<br><img src="https://gw.alicdn.com/tfscom/TB1sQtXov2H8KJjy1zkXXXr7pXa.png" alt=""></p><p><strong>流程分析：</strong></p><p>每一个Data Analyzer模块中都会包含一个Rule Set集合，Rule Set集合存放着生效后的关注点规则，在监控数据到达分析引擎中后，分析引擎通过filter机制，判断是否命中规则，如果命中规则，则根据规则与数据形成一条Event 事件数据，用于描述某次监控指标命中了监控指标阈值。后续复盘时，可以对Event 库中的指标事件进行聚合分析，形成需要的结论报告。</p><p><strong>规则注册与更新机制：</strong></p><p>关注点规则为内存数据集，当用户在界面是哪个新增了规则或者变更了规则的时候，都需要对内存中维护的这份规则集合进行修改操作。</p><p><strong>规则存储：</strong></p><p>当前规则为内存存储方式，在系统启动时从数据库中进行load全量有效关注点指标；带来的影响每一台机器都需要在内存中维护一份数据，如果某台机器数据更新失败，会带来数据的一致性问题，后续会考虑这部分数据移动到公共的外部快速存储设备中，比如Redis中。</p><p><strong>数据模型：</strong></p><p>我们把用户配置的关注点在系统指标上的阈值简称为“告警”，告警条件的判断以及存储流程中，主要涉及的领域模型为：Hosts、Metrics、triggers、functions、items、events、actions；</p><ul><li>hosts： 存储被监控的主机信息；</li><li>metrics：存储监控到的数据指标；</li><li>items： 存储支持的监控项配置信息。</li><li>triggers：存储触发器的相关信息；</li><li>events： 存储事件数据；</li><li>actions：存储当触发器触发时，需要采取的动作（不再本期研发范围内）；</li></ul><p><strong>触发器计算模型：</strong></p><p>我们的需求是：监控某个关注对象下的某类监控指标下的特定聚合函数值 是否超过(也可能是其它运算符)某个固定阈值；那么我们把需求中拆解出几个对象出来，分别是：监控对象、监控指标、聚合函数、运算符、固定阈值，我们通过这几个对象的组合，可以对我们的意图进行对象化描述，表达式函数格式如下：<br>{<host>:<metric>.<function>(<parameter>)}<operator><constant></constant></operator></parameter></function></metric></host></p><p><strong>计算模型举例：</strong></p><p>关注点描述为： 11.23.45.67  这台机器的 最近十分钟 load 指标 大于2   ， 那么 表达式函数为：<br>{11.23.45.67:system.cpu.load.last(10m)}  &gt; 2</p><p><strong>触发器中的聚合函数：</strong></p><ul><li>max    最大值    </li><li>min    最小值    </li><li>avg    平均值    </li></ul><p><strong>数据模型：</strong></p><p>在监控指标分析域中涉及到的领域模型对象为：</p><ul><li>items</li><li>triggers</li><li>events</li><li>actions</li></ul><p>数据模型以及关联关系如下：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/5ec4918f-2d14-4c92-a637-cc5457c828a8/2018/png/f1dffd57-4a0e-4f98-a295-b39db045a6e2.png" alt=""></p><p>资源组与触发器为1：n的关系，监控项与触发器为1:1关系，触发器与事件为1:1关系；</p><h2 id="五、数据存储方案"><a href="#五、数据存储方案" class="headerlink" title="五、数据存储方案"></a>五、数据存储方案</h2><h3 id="5-1-数据分类："><a href="#5-1-数据分类：" class="headerlink" title="5.1 数据分类："></a>5.1 数据分类：</h3><p>我们把数据类型分为五类：</p><ol><li>Metric指标数据（分为服务器和容器）<ul><li>定义：metric描述一个指标在某个时间点的值是多少，可以使用tag来进行元数据标记划分；比如OS的系统监控指标；</li></ul></li><li>Event  事件数据（包括：系统、Docker数据采集）<ul><li>定义：event记录系统在特定时刻下发生的具体信息，比如规则下发、故障启停、MkKit安装与卸载、Metric触发规则配置产生的事件等；</li></ul></li><li>Log 运行时日志数据<ul><li>定义：event数据可以根据业务需求打上tag便于分析时筛选，统计，text中记录事件丰富上下文信</li></ul></li><li>Heartbeat 心跳数据<ul><li>定义：定期执行的状态汇报，比如agent的心跳信息，进程的状态等；</li></ul></li><li>Trace 数据<ul><li>定义：记录故障注入请求trace的信息；</li></ul></li></ol><h3 id="5-2-数据存储方案："><a href="#5-2-数据存储方案：" class="headerlink" title="5.2 数据存储方案："></a>5.2 数据存储方案：</h3><p>监控数据是时间序列的数据，由于监控的对象数量巨大，所以存储的介质需要支持高的写入吞吐量，良好的扩充性，读取最近的数据速度要快，支持多数据类型，支持多种扫描方式等特点，目前主要的存储方式有SQL和NoSQL两种。通过对比，NoSQL在数据存储吞吐量，扩充性等方面具有优势，SQL在数据类型的支持，扫描多样性具有优势。</p><p>总而言之，监控数据更适合采用时序性存储媒介，比如OpenTSDB、HiTSDB等；考虑到种种原因，我们临时使用 Mysql，Mysql 能在一定程度上简化我们架构，让业务跑的更快一些。</p><p>不压缩的情况下：100台机器同时采集长达30天，占用空间49G；（单条1kb计算，5秒存储一次）。</p><h4 id="5-3-行业常用存储方案"><a href="#5-3-行业常用存储方案" class="headerlink" title="5.3 行业常用存储方案"></a>5.3 行业常用存储方案</h4><p>Cassandra<br>InfluxDB<br>MongoDB<br>OpenTSDB<br>KairosDB<br>HBase</p><h3 id="5-4-监控指标存储规范"><a href="#5-4-监控指标存储规范" class="headerlink" title="5.4 监控指标存储规范"></a>5.4 监控指标存储规范</h3><p>遵循metric规范；<br><a href="https://gw.alipayobjects.com/zos/skylark/02b7d493-9e02-490d-8f0c-243309a66ad5/2018/png/edcf8730-7203-48da-961b-1858d60a372c.png" target="_blank" rel="noopener"></a></p><p>一个metric由两部分组成，metric key和metric tag：</p><ol><li>metric key：它是用英文点号分隔的字符串，用来表征这个指标的含义</li><li>metric tag：它定义了这个指标的不同切分维度，可以是单个，也可以是多个<ul><li>tag key: 用于描述维度的名称</li><li>tag value: 用于描述维度的值</li></ul></li></ol><p>Metric的数据格式如下：<br><img src="https://gw.alicdn.com/tfscom/TB1Ey9PeAfb_uJkSne1XXbE4XXa.png" alt=""></p><ul><li>metric key：存储当前指标的key</li><li>metric tag：存储当前指标的tag</li><li>metric value：存储当前指标的值</li><li>timestamp：存储当前的时间戳</li><li>metadata：存储当前指标的一些元信息</li></ul><p>在Metric规范下，针对云上的多租户设计，我们增加了两个字段namespace、scope，用来对metric进行分类，一个是从用户角度进行划分，一个是从功能集角度划分，形成 MetricObject 对象属性描述如下：</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>是否必填</th></tr></thead><tbody><tr><td>namespace</td><td>​String</td><td>命名空间，用于区分不同租户，存储userId</td><td>必填</td></tr><tr><td>scope</td><td>String</td><td>范围，比如system、jvm、hsf、servlet等</td><td>必填</td></tr><tr><td>metric</td><td>String</td><td>指标Key</td><td>必填</td></tr><tr><td>metricType</td><td>MetricType</td><td>指标类型</td><td>必填</td></tr><tr><td>tags</td><td>map&lt;string,string&gt;</td><td>附加信息，当前只支持内置tag，不支持用户自定义tag（原因是采用mysql而不是nosql）</td><td>必填，遵循OpenTSDB规范，至少要求有一个Tag</td></tr><tr><td>timestamp</td><td>Long</td><td>时间戳</td><td>必填</td></tr><tr><td>value</td><td>Double</td><td>指标值</td><td>必填</td></tr></tbody></table><p>举例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"namespace"</span>: <span class="string">"1114805108664848"</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"system"</span>,</span><br><span class="line">    <span class="attr">"metric"</span>: <span class="string">"sys.memory.total"</span>,</span><br><span class="line">    <span class="attr">"metricType"</span>: <span class="string">"COUNTER"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: &#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1470298287916</span>,</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">1167126</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetricType 指标类型(参考：<a href="http://metrics.dropwizard.io/4.0.0/getting-started.html)：" target="_blank" rel="noopener">http://metrics.dropwizard.io/4.0.0/getting-started.html)：</a></p><ul><li>COUNTER: 用于累加型的数据，反映的是数据随着时间单调递增的关系，如Tomcat接受到的HTTP请求的总次数</li><li>GAUGE: 用于瞬态数据，表示指标在当前时间点的瞬时情况，反映的是数据随着时间上下波动的关系，如系统的load，JVM的内存使用率</li><li>METER：用于对变化速率型指标进行度量，反映的是数据随时间的增长快慢关系，如某个接口的QPS</li><li>HISTOGRAM：用于对分布型数据进行度量，反映的是数据随时间的统计学分布关系</li></ul><p><strong>Tags 标签存储方案：</strong></p><p>由于生产环境中存储方案当前技术选型为使用Mysql存储Metric数据，Mysql不支持schemaless结构，所以无法做到Tags的key-value的动态扩展，我们使用Mysql的固定列模式，通过提供内置tag来达到相同的目的；Tags中的key为Mysql中的列名称，字段值为tags的value；</p><p>内置的tag字段为：</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>举例</th></tr></thead><tbody><tr><td>tag_host</td><td>主机信息</td><td>127.0.0.1</td></tr><tr><td>tag_device</td><td>设备信息，比如磁盘盘符</td><td>/usr/dev1</td></tr><tr><td>tag_trace</td><td>请求链路标识</td><td>tid</td></tr><tr><td>tag_transaction</td><td>请求事务标识</td><td>createOrder</td></tr></tbody></table><p>Mysql数据模型如下：<br><img src="https://gw.alipayobjects.com/zos/skylark/1936fc76-7df1-4485-aed2-00eda58b2903/2018/png/0a5f4d67-77ca-4030-a095-919918a948c6.png" alt=""></p><h2 id="六、监控数据查询方案"><a href="#六、监控数据查询方案" class="headerlink" title="六、监控数据查询方案"></a>六、监控数据查询方案</h2><h3 id="6-1-数据查询分类："><a href="#6-1-数据查询分类：" class="headerlink" title="6.1 数据查询分类："></a>6.1 数据查询分类：</h3><p>用户对时序数据的查询场景多种多样，总的来说时序数据的查询分为两种：</p><ul><li>原始数据的查询（比如业务监控数据）</li><li>时序数据聚合运算的查询（比如系统监控数据）</li></ul><p><strong>某监控 指标展示计算解析：</strong></p><p>监控中用户日志的计算逻辑是由用户自定义的计算方式（因为是业务监控），主要由求行数、对列值求和、对列值求平均、对列值求最大值、对列值求最小值；其大盘数据展示中并未对数据做再次聚合处理，展示的是采集的原始数据（原始数据分为秒级和分钟级），如果需要做计算，是通过前端的聚合函数进行的业务处理。<br><img src="https://gw.alipayobjects.com/zos/skylark/ed6a20ea-c9d8-4ef7-be45-ab972ac211e2/2018/png/a9b705d7-cc05-43f2-8a3a-dc822ddfd7b2.png" alt=""></p><h3 id="6-2-数据聚合分类："><a href="#6-2-数据聚合分类：" class="headerlink" title="6.2 数据聚合分类："></a>6.2 数据聚合分类：</h3><p>在监控数据使用过程中，我们往往会针对单台机器进行分析或者多台(集群)机器进行分析，每一种分析中又会加入时间的概念，比如是采用原始采集的数据点还是进行多个点的合并形成一个新点。所以我们把数据分析计算分为两个维度，一个是‘机器’维度(空间聚合)，一个时间维度(时间聚合)；在Metric模型中我们通过两个方法分别定义，一个是Aggregator，一个是Down sample。</p><p>Aggregator：用来描述同一个时间点下，数据集合的聚合方式；比如一个集群的CPU使用率，在某一时刻下集群中所有机器的CPU使用率的平均值；需要注意的是，当随着集群规模越来越大的时候，我们也是需要从这个数据集合中进行采样，然后再做聚合计算。</p><p>Down sample：用来描述在多个时间点下，数据聚合的聚合方式；比如一台机器每隔5秒采集一个CPU使用率，最终数据展示时，需要按照1分钟一个点的方式进行展示，那么这个数据集合中在不丢数据的情况下会有12个数据项，我们需要将这12个数据项聚合为一个数据项。</p><h3 id="6-3-数据聚合方式："><a href="#6-3-数据聚合方式：" class="headerlink" title="6.3 数据聚合方式："></a>6.3 数据聚合方式：</h3><p>数据的聚合方式一般可以分为‘预聚合’和‘后聚合’；提前聚合可能引起数据膨胀但可以加速访问请求时的响应速度，访问时聚合虽然降低了一定的存储成本但可能会加慢响应速度。<br><img src="https://gw.alipayobjects.com/zos/skylark/84e8e67c-e0a8-4a9d-a748-0e5383cc08ee/2018/png/4afc4ec7-84d4-42e9-b3b7-d17cdc57eae3.png" alt=""></p><p>大部分监控系统一般都支持预聚合(归档)数据处理（比如zabbix的数据归档表trends）；由于一般原始数据采集周期比较小，比如分钟级，那么展示长时间的数据的视图需要扫描过多数据，展示比较慢，如果将数据归档成按小时，和按天的数据，那么展示时间跨度大的数据的效率大大提高；基于Metric的数据预处理，一般采用流式预聚合引擎，对数据进行降精度处理，比如阿里的DBPass产品，会对指标数据事先降时间精度，分为6个精度：1秒、5秒、15秒、1分钟、5分钟、15分钟。</p><p>基于Metric规范的时序数据库中，OpenTSDB支持预聚合和后聚合，Aliyun的HiTSDB优先采用后聚合，其通过采用倒排索引+前缀索引来加速数据查询。</p><h3 id="6-4-数据计算算法："><a href="#6-4-数据计算算法：" class="headerlink" title="6.4 数据计算算法："></a>6.4 数据计算算法：</h3><p>在客户端数据采集计算的时候，通常也会遇到数据聚合的需求，主要是基于单机维度的数据聚合，比如我们期望采集固定周期周期范围内的数据，假如每个周期范围内存在多个数据点（D1，D2，D3），我们要怎样计算才能得到一个点的数据呢？</p><p>通常会有以下计算方式：</p><ul><li>随机采样；</li><li>滑动窗口；</li><li>滑动时间窗口；</li><li>指数衰减随机采样（EWMA）；</li></ul><p><img src="https://gw.alipayobjects.com/zos/skylark/b070bc51-d1db-46b0-9fb9-19461a360ecc/2018/png/ebfc264d-1e49-4ae2-b771-63e88e39e63d.png" alt=""></p><p><img src="https://gw.alipayobjects.com/zos/skylark/5d1585f9-8351-4eec-afee-d2b74531c268/2018/png/490d585e-700e-44f5-978c-d30a772d9e80.png" alt=""></p><p>EWMA的Java实现方式可以参考：<a href="https://github.com/heartaway/metrics/blob/4.1-development/metrics-core/src/main/java/com/codahale/metrics/EWMA.java" target="_blank" rel="noopener">EWMA.java</a><br>EWMA算法 维护一个固定大小的集合，并认为该集合中的元素的权重不一样，元素的权重随元素距离当前时间的远近而呈现指数型的衰减。主要是解决数据集合中的离散点，让数据曲线跟加平滑。比如Load1、Load5、Load15目前的计算逻辑就采用EWMA算法；</p><h3 id="6-5-数据查询API："><a href="#6-5-数据查询API：" class="headerlink" title="6.5 数据查询API："></a>6.5 数据查询API：</h3><p>待补充</p><h2 id="七、扩展阅读："><a href="#七、扩展阅读：" class="headerlink" title="七、扩展阅读："></a>七、扩展阅读：</h2><p>metric起源：</p><p><a href="https://www.youtube.com/watch?v=czes-oa0yik" target="_blank" rel="noopener">https://www.youtube.com/watch?v=czes-oa0yik</a></p><p>小米 open-falcon：</p><p><a href="http://open-falcon.com/" target="_blank" rel="noopener">http://open-falcon.com/</a></p><p>网易企业级监控：</p><p><a href="http://blog.163yun.com/archives/900" target="_blank" rel="noopener">http://blog.163yun.com/archives/900</a></p><p>salesforce-Argus：<br><a href="https://github.com/salesforce/argus" target="_blank" rel="noopener">https://github.com/salesforce/argus</a></p><p>使用Metrics监控应用程序的性能：</p><p><a href="http://www.cnblogs.com/yangecnu/p/Using-Metrics-to-Profiling-WebService-Performance.html" target="_blank" rel="noopener">http://www.cnblogs.com/yangecnu/p/Using-Metrics-to-Profiling-WebService-Performance.html</a></p><p>深入浅出时序数据库之预处理篇：</p><p><a href="http://www.infoq.com/cn/articles/pretreatment-in-sequential-databases" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/pretreatment-in-sequential-databases</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、监控系统整体概述&quot;&gt;&lt;a href=&quot;#一、监控系统整体概述&quot; class=&quot;headerlink&quot; title=&quot;一、监控系统整体概述&quot;&gt;&lt;/a&gt;一、监控系统整体概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;系统背景：&lt;br&gt;在当前项目中，当我们对特定流程注
      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>spring quartz 指定trigger的执行机器</title>
    <link href="http://heartaway.cn/2018/03/06/Java/2018-03-06-spring-quartz-trigger/"/>
    <id>http://heartaway.cn/2018/03/06/Java/2018-03-06-spring-quartz-trigger/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-11-09T14:24:24.761Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用spring-quartz的时候，常常会遇到一个场景，那就是任务的调度会随着争取锁的先后顺序而出现不固定机器执行的场景，这在正常业务逻辑中具备了很好的容灾能力，但是在我们排查问题时，却带来了困绕，如果出现问题，我们期望任务调度固定在一台机器上进行执行，方便我们对问题的定位和排查。</p><p>这里就探讨如何扩展spring-quartz来实现任务的固定机器执行。</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>要指定机器运行trigger，那首先我们必须清楚spring-quartz cluster模式下，任务的触发时如何进行分布式执行的。<br>spring-quartz cluster 是借助数据锁来实现并发控制的，需要注意的是分布式环境下需要保证各机器系统时间一致性；</p><p>核心处理线程QuartzSchedulerThread决定了扫描那些JOB，以及触发执行和生命周期的维护。<br>QuartzSchedulerThread中run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在trigger表中扫描指定SCHED_NAME、状态为WAITING，下次触发时间在30秒内的触发器</span></span><br><span class="line">triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                                now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line">....                  </span><br><span class="line"><span class="comment">//触发器执行</span></span><br><span class="line">List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);                                                          </span><br><span class="line">...</span><br><span class="line"><span class="comment">//释放触发器</span></span><br><span class="line">qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//完成触发器</span></span><br><span class="line">qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br></pre></td></tr></table></figure><p>我们就可以在acquireNextTriggers中做扩展，获取全部或者指定了实例ID的trigger。</p><p>延伸思考：acquireNextTriggers获取到trigger列表后，假设机器宕机，这些trigger如何路由到其他机器中正常运行？</p><h3 id="扩展实例ID的生成策略"><a href="#扩展实例ID的生成策略" class="headerlink" title="扩展实例ID的生成策略"></a>扩展实例ID的生成策略</h3><p>spring-quartz一般配置的org.quartz.scheduler.instanceId：AUTO，采用的是SimpleInstanceIdGenerator ID生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleInstanceIdGenerator</span> <span class="keyword">implements</span> <span class="title">InstanceIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateInstanceId</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostName() + System.currentTimeMillis();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't get host name!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleInstanceIdGenerator 采用机器主机名称与当前时间戳作为instanceId,我们期望在开发环境使用hostName，在生产环境(Linux)采用IP作为实例ID。</p><p>实现InstanceIdGenerator接口，实现自己的ID生成策略，QuartzSchedulerInstanceIdGenerator的实现逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzSchedulerInstanceIdGenerator</span> <span class="keyword">implements</span> <span class="title">InstanceIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(QuartzSchedulerInstanceIdGenerator.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OS_NAME = <span class="string">"os.name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WINDOWS = <span class="string">"Windows"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAC = <span class="string">"Mac OS"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateInstanceId</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLocalDev()) &#123;</span><br><span class="line">                id = getHostName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id = IpUtil.getIp();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(id)) &#123;</span><br><span class="line">                id = InetAddress.getLocalHost().getHostName() + System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't generate instance id!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getHostName</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't get host name!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalDev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), WINDOWS) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), MAC) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在quartz.properties中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceIdGenerator.class=com.xx.ext.QuartzSchedulerInstanceIdGenerator</span><br></pre></td></tr></table></figure><h3 id="扩展StdJDBCDelegate"><a href="#扩展StdJDBCDelegate" class="headerlink" title="扩展StdJDBCDelegate"></a>扩展StdJDBCDelegate</h3><p>SchedulerFactoryBean 工厂Bean负责加载配置信息，初始化SchedulerFactory和Scheduler实例，jobStore负责job、trigger等的持久化工作，针对不同的数据库类型，可以配置不同的DriverDelegate。Spring中默认使用LocalDataSourceJobStore作为JobStore的处理类。</p><p>SchedulerFactory中initSchedulerFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading Quartz config from ["</span> + <span class="keyword">this</span>.configLocation + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PropertiesLoaderUtils.fillProperties(mergedProps, <span class="keyword">this</span>.configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(<span class="keyword">this</span>.quartzProperties, mergedProps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.put(StdSchedulerFactory.PROP_JOB_STORE_CLASS, LocalDataSourceJobStore.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到SchedulerFactoryBean中设置PROP_JOB_STORE_CLASS属性是在合并用户设置的配置文件之后，也就是PROP_JOB_STORE_CLASS的实现类Spring强制指定为LocalDataSourceJobStore而无法更改，即便是我们在quartz.properties中配置了org.quartz.jobStore.class属性，也会被LocalDataSourceJobStore覆盖掉。</p><p>LocalDataSourceJobStore继承自JobStoreSupport，JobStoreSupport默认配置使用StdJDBCDelegate作为与数据库交互的代理处理类；我们可以通过扩展StdJDBCDelegate类，来实现底层数据库交互的扩展。通过配置org.quartz.jobStore.driverDelegateClass属性，指定driverDelegate为我们扩展后的Delegate。</p><p>在quartz.properties中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.driverDelegateClass=com.xx.ext.StdJDBCDelegateExt</span><br></pre></td></tr></table></figure><p>针对${table_prefix}_quartz_triggers表新增字段INSTANCE_NAME，此字段为InstanceIdGenerator生成的实例ID，此字段会透传到StdJDBCDelegate中的属性instanceId中，因此我们可以扩展StdJDBCDelegate，通过instanceId字段来指定获取的trigger列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StdJDBCDelegateExt</span> <span class="keyword">extends</span> <span class="title">StdJDBCDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String INSTANCE_NAME_VALUE = <span class="string">"&#123;2&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    String SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT = <span class="string">"SELECT "</span></span><br><span class="line">        + COL_TRIGGER_NAME + <span class="string">", "</span> + COL_TRIGGER_GROUP + <span class="string">", "</span></span><br><span class="line">        + COL_NEXT_FIRE_TIME + <span class="string">", "</span> + COL_PRIORITY + <span class="string">" FROM "</span></span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_TRIGGERS + <span class="string">" WHERE "</span></span><br><span class="line">        + COL_SCHEDULER_NAME + <span class="string">" = "</span> + SCHED_NAME_SUBST</span><br><span class="line">        + <span class="string">" AND "</span> + COL_TRIGGER_STATE + <span class="string">" = ? AND "</span> + COL_NEXT_FIRE_TIME + <span class="string">" &lt;= ? "</span></span><br><span class="line">        + <span class="string">" AND ("</span> + COL_INSTANCE_NAME + <span class="string">" IS NULL OR "</span> + COL_INSTANCE_NAME + <span class="string">" = "</span> + INSTANCE_NAME_VALUE + <span class="string">")"</span></span><br><span class="line">        + <span class="string">"AND ("</span> + COL_MISFIRE_INSTRUCTION + <span class="string">" = -1 OR ("</span> + COL_MISFIRE_INSTRUCTION + <span class="string">" != -1 AND "</span></span><br><span class="line">        + COL_NEXT_FIRE_TIME + <span class="string">" &gt;= ?)) "</span></span><br><span class="line">        + <span class="string">"ORDER BY "</span> + COL_NEXT_FIRE_TIME + <span class="string">" ASC, "</span> + COL_PRIORITY + <span class="string">" DESC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许设置trigger 指定一台机器进行任务调度执行；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> noLaterThan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> noEarlierThan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TriggerKey&gt; <span class="title">selectTriggerToAcquire</span><span class="params">(Connection conn, <span class="keyword">long</span> noLaterThan, <span class="keyword">long</span> noEarlierThan, <span class="keyword">int</span> maxCount)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;TriggerKey&gt; nextTriggers = <span class="keyword">new</span> LinkedList&lt;TriggerKey&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(rtp(SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT, instanceId));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set max rows to retrieve</span></span><br><span class="line">            <span class="keyword">if</span> (maxCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.setMaxRows(maxCount);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to give jdbc driver a hint to hopefully not pull over more than the few rows we actually need.</span></span><br><span class="line">            <span class="comment">// Note: in some jdbc drivers, such as MySQL, you must set maxRows before fetchSize, or you get exception!</span></span><br><span class="line">            ps.setFetchSize(maxCount);</span><br><span class="line"></span><br><span class="line">            ps.setString(<span class="number">1</span>, STATE_WAITING);</span><br><span class="line">            ps.setBigDecimal(<span class="number">2</span>, <span class="keyword">new</span> BigDecimal(String.valueOf(noLaterThan)));</span><br><span class="line">            ps.setBigDecimal(<span class="number">3</span>, <span class="keyword">new</span> BigDecimal(String.valueOf(noEarlierThan)));</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next() &amp;&amp; nextTriggers.size() &lt;= maxCount) &#123;</span><br><span class="line">                nextTriggers.add(triggerKey(</span><br><span class="line">                    rs.getString(COL_TRIGGER_NAME),</span><br><span class="line">                    rs.getString(COL_TRIGGER_GROUP)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> nextTriggers;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResultSet(rs);</span><br><span class="line">            closeStatement(ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">rtp</span><span class="params">(String query, String instanceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MessageFormat.format(query,</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123;tablePrefix, getSchedulerNameLiteral(), <span class="string">"'"</span> + instanceName + <span class="string">"'"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成了指定trigger在特定instanceId上运行，但是有一个问题，假如我们期望trigger可以在多台instanceId上随机执行的话，该如何实现呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用spring-quartz的时候，常常会遇到一个场景，那就是任务的调度会随着争取锁的先后顺序而出现不固定机器执行的场景，这在正常业务逻辑中具备了很好的容灾能力，但是在我们排查问题时，却带来了困绕，如果出现问题，我们期望任务调度固定在一台机器上进行执行，方便我们对问
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring中property-placeholder的使用与解析</title>
    <link href="http://heartaway.cn/2018/01/19/Java/2018-01-19-spring-properties/"/>
    <id>http://heartaway.cn/2018/01/19/Java/2018-01-19-spring-properties/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2018-11-09T14:24:17.743Z</updated>
    
    <content type="html"><![CDATA[<p>在我们程序开发中，进程会需要把一些变量通过property方式进行提取，方便不同环境配置不同的属性，替换变量的方法通常有两种，一种是静态替换，一种是动态替换；所谓静态替换，是在打包编译的时候，把变量替换掉，动态替换，是在程序运行起来时，通过把属性注入到程序的环境变量中，类初始化的时候，再使用环境变量进行替换的一种方法。</p><p>静态替换常用工具：autoconfig<br>动态替换常用工具：spring.property-placeholder</p><h2 id="spring动态替换变量实践"><a href="#spring动态替换变量实践" class="headerlink" title="spring动态替换变量实践"></a>spring动态替换变量实践</h2><p>简洁配置法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:xxx.properties"</span> </span><br><span class="line">ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"location"</span>&gt;</span><br><span class="line">        &lt;value&gt;myConfig.properties&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>完整配置属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder   </span><br><span class="line">        location=<span class="string">""</span>  </span><br><span class="line">        file-encoding=<span class="string">""</span>  </span><br><span class="line">        ignore-resource-not-found=<span class="string">""</span>  </span><br><span class="line">        ignore-unresolvable=<span class="string">""</span>  </span><br><span class="line">        properties-ref=<span class="string">""</span>  </span><br><span class="line">        local-override=<span class="string">""</span>  </span><br><span class="line">        system-properties-mode=<span class="string">""</span>  </span><br><span class="line">        order=<span class="string">""</span>  </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>ignore-resource-not-found：如果属性文件找不到，是否忽略，默认false，即不忽略，找不到将抛出异常 </p><p>ignore-unresolvable：是否忽略解析不到的属性，如果不忽略，找不到将抛出异常 </p><p>order：当配置多个<a href="context:property-placeholder/" target="_blank" rel="noopener">context:property-placeholder/</a>时的查找顺序</p><p>不推荐将ignore-resource-not-found和ignore-unresolvable的值设置为ture，默认为false，可以有效避免程序运行异常</p><h4 id="使用PropertySource注解配置"><a href="#使用PropertySource注解配置" class="headerlink" title="使用PropertySource注解配置"></a>使用PropertySource注解配置</h4><p>Spring3.1添加了@PropertySource注解,方便添加property文件到环境.</p><h4 id="properties的注入与使用"><a href="#properties的注入与使用" class="headerlink" title="properties的注入与使用"></a>properties的注入与使用</h4><ul><li>java中使用@Value注解获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>( <span class="string">"$&#123;jdbc.url&#125;"</span> )</span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure><ul><li>在Spring的xml配置文件中获取</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="配置多个property-placeholder属性"><a href="#配置多个property-placeholder属性" class="headerlink" title="配置多个property-placeholder属性"></a>配置多个property-placeholder属性</h4><p>Spring容器是采用反射扫描的发现机制，通过标签的命名空间实例化实例，当Spring探测到容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderCVonfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描，即只能存在一个实例！</p><p>所以一遍不建议配置多个property-placeholder对象，但是在必须使用多个的场景下，如何配置呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=<span class="string">"xxx.properties"</span> ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:property-placeholder location=<span class="string">"xxx.properties"</span> ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>需要设置ignore-unresolvable=”true”，否则后面的property-placeholder不会被加载；</p><p>ignore-unresolvable单独使用来看是“是否忽视不存在的配置项”，不仅如此，其还有一个隐含意思：是否还要扫描其他配置项：如果为false，则会忽视后续的property-placeholder，如果需要配置多个property-placeholder则应该设置为true；</p><h4 id="context-property-placeholder-工作原理"><a href="#context-property-placeholder-工作原理" class="headerlink" title="context:property-placeholder 工作原理"></a>context:property-placeholder 工作原理</h4><p>在 ContextNamespaceHandler 中对于 context中的property-placeholder 标签，会采用PropertyPlaceholderBeanDefinitionParser解析器进行解析；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyPlaceholderBeanDefinitionParser解析器会将property-placeholder 标签解析为一个PropertySourcesPlaceholderConfigurer的单例 bean 。</p><p>可以看出 PropertySourcesPlaceholderConfigurer 或者 PropertyPlaceholderConfigurer 仅仅是做了一个配置文件的解析工作，真正的注入并不由它们完成，而是托付给了Spring 的Bean初始化流程。<br>之所以这么做可以生效，是因为这两个类实现了 BeanFactoryPostProcessor 接口，这个接口的优先级高于后续的Spring Bean。</p><p>属性元素的注入依赖于 AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues。 通过解析PropertySourcesPlaceholderConfigurer 查询得到元素值。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.findAutowiringMetadata(beanName, bean.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertySourcesPlaceholderConfigurer本质上是一个BeanFactoryPostProcessor。解析XML的流程在BeanFactoryPostProcessor之前， 优先将配置文件的路径以及名字通过Setter传入PropertySourcesPlaceholderConfigurer。</p><p>如上BeanFactoryPostProcessor的优先级又优于其余的Bean。因此可以实现在bean初始化之前的注入。</p><h4 id="Spring-Value注入流程"><a href="#Spring-Value注入流程" class="headerlink" title="Spring @Value注入流程"></a>Spring @Value注入流程</h4><ol><li>Spring Context 的初始化开始</li><li>读取到context:property-placeholder标签或者PropertySourcesPlaceholderConfigurer</li><li>解析并实例化一个PropertySourcesPlaceholderConfigurer。同时向其中注入配置文件路径、名称</li><li>PropertySourcesPlaceholderConfigurer自身生成多个StringValueResolver备用，Bean准备完毕</li><li>Spring在初始化非BeanFactoryPostProcessor的Bean的时候，AutowiredAnnotationBeanPostProcessor 负责找到Bean内有@Value注解的Field或者Method</li><li>通过PropertySourcesPlaceholderConfigurer寻找合适的StringValueResolver并解析得到val值。注入给@Value的Field或Method。(Method优先)2</li><li>Spring的其他流程。</li></ol><p>参考：<br><a href="http://blog.csdn.net/qyp199312/article/details/54313784" target="_blank" rel="noopener">http://blog.csdn.net/qyp199312/article/details/54313784</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们程序开发中，进程会需要把一些变量通过property方式进行提取，方便不同环境配置不同的属性，替换变量的方法通常有两种，一种是静态替换，一种是动态替换；所谓静态替换，是在打包编译的时候，把变量替换掉，动态替换，是在程序运行起来时，通过把属性注入到程序的环境变量中，类初
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>系统权限控制体系</title>
    <link href="http://heartaway.cn/2018/01/04/Program/2018-01-04-permission-system-degisn/"/>
    <id>http://heartaway.cn/2018/01/04/Program/2018-01-04-permission-system-degisn/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-11-09T14:26:45.566Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。比如我们开放的功能页面需要登录授权之后才能访问，一些功能需要具备特定权限的人才能操作；再比如我们开放了数据API接口，如果不做访问控制，那么任何人都可以调用，当被不法分子操作时将给我们带来巨大的麻烦。那么在Java 整个体系中访问控制是否有一套理论技术支撑呢，我们是否可以做一个通用性的访问控制系统来完成分布式系统架构下的复杂的权限控制？接下来会一一介绍。</p><h3 id="访问控制的本质："><a href="#访问控制的本质：" class="headerlink" title="访问控制的本质："></a>访问控制的本质：</h3><p>系统权限控制 本质上是访问控制（Access Control），那访问控制的本质又是什么呢？其实就是合法的访问受保护的资源，通俗的解释就是“【谁】是否有可以对某个【资源】进行某种【操作】”；可以看出访问控制的三个基本要素：主体（请求实体）、客体（资源实体）、控制策略（属性集合）；</p><h3 id="访问控制需要完成的两个任务："><a href="#访问控制需要完成的两个任务：" class="headerlink" title="访问控制需要完成的两个任务："></a>访问控制需要完成的两个任务：</h3><p>识别和确认访问系统的用户；<br>决定该用户可以对某一系统资源进行何种类型的访问；</p><h3 id="访问控制理论模型："><a href="#访问控制理论模型：" class="headerlink" title="访问控制理论模型："></a>访问控制理论模型：</h3><ul><li>DAC&amp;MAC模型<ul><li>DAC：自主访问控制；</li><li>MAC：强制访问控制，一般用于多级安全军事系统；</li></ul></li><li>IBAC模型：<ul><li>基于身份的访问控制模型</li><li>举例：登录验证</li><li>比如Java中使用cookie、session存储回话标识；</li></ul></li><li>RBAC模型：<ul><li>基于角色的访问控制（Role-Based Access Control）</li><li>用户、角色、权限</li><li>RBAC是ABAC的一种单属性特例；</li><li>1992年David F.Ferraiolo &amp; D.Richard Kuhn在第十五届国家计算机安全会议上提出；</li><li>论文：<a href="https://csrc.nist.gov/projects/role-based-access-control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/role-based-access-control</a></li><li>举例：丰趣-小二后台的认证授权模型设计；</li><li>Spring Security、Apache Shiro、Ali ACL</li></ul></li><li>ABAC模型：<ul><li>基于属性的访问控制模型 (Attribute Based Access Control)</li><li>举例：阿里云、AWS；</li><li>论文：<ul><li><a href="https://csrc.nist.gov/projects/attribute-based-access-control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/attribute-based-access-control</a></li><li><a href="https://link.springer.com/chapter/10.1007/978-3-319-25645-0_14" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-319-25645-0_14</a></li><li><a href="http://profsandhu.com/dissert/xin_slides.pdf" target="_blank" rel="noopener">http://profsandhu.com/dissert/xin_slides.pdf</a></li></ul></li></ul></li></ul><p>示意图：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/068d3b155b6538ee6f4651d7febe19cd.png" alt=""><br>基于RBAC权限模型的常见数据库模型设计：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/af745d65be9e6922518ff6402e805464.png" alt=""><br>设计的核心主题: 用户、权限、角色、用户角色、角色权限、用户组、用户组角色、操作审计<br>阿里巴巴登录鉴权与审计的三驾马车：BUC、ACL、OpLog；</p><h3 id="Java常用访问控制框架："><a href="#Java常用访问控制框架：" class="headerlink" title="Java常用访问控制框架："></a>Java常用访问控制框架：</h3><ul><li>JAAS框架：<ul><li>Authentication（鉴别），    Authorization（授权），Accounting（计费）；</li><li>Java认证和授权服务（Java Authentication and Authorization Service，简称JAAS）</li><li>支持的框架：LDAP</li><li>特点：面世时间早，使用受限，不建议使用；</li></ul></li><li>Spring Security框架</li><li>Apache Shiro框架</li></ul><h3 id="权限系统的演变历史："><a href="#权限系统的演变历史：" class="headerlink" title="权限系统的演变历史："></a>权限系统的演变历史：</h3><h4 id="1：-标准的JAAS-时代；"><a href="#1：-标准的JAAS-时代；" class="headerlink" title="1： 标准的JAAS 时代；"></a>1： 标准的JAAS 时代；</h4><p>J2ee时代，Java提出了标准的鉴权服务，即jaas；通过简单的容器配置和文件配置，通过一个LDAP（可以用数据库，只是效率不高），就可以提供一个极为高效便捷的权限管控服务。这个模式不仅支持页面管控，还支持ejb服务接口管控。其鉴权因为ldap的数倍于数据库的查询效率而无需任何缓存，速度很快。但是伴随着分布式服务化进程，应用的数量无限度增长，这种散落在各个容器的配置给容灾和修改，都带来了极大的挑战，ldap的可读化差，修改和编辑极为不便，当需求一旦个性化超过了树能够表达的模型便很难在适应。并且当ldap的数据爆炸式增长，且呈现28规律时（数据冷热不均），或者如果需要频繁的写ldap，查询效率会陡然下降。虽然这种方式目前并不流行的，但是由于历史原因，还存留着使用这种方式的管控方式，所以我们在Spring Security或者阿里的ACL中都还能看到对JAAS的支持。</p><h4 id="2：-单点登录-SSO-接口鉴权时代；"><a href="#2：-单点登录-SSO-接口鉴权时代；" class="headerlink" title="2： 单点登录(SSO)+接口鉴权时代；"></a>2： 单点登录(SSO)+接口鉴权时代；</h4><p>把分散在各个系统的登录认证服务统一到一个系统中来，统一管控登录授权业务，用户只要在一个系统中登录了，在其它系统中就没必要再次登录了，这就是SSO。简单的实现是登录授权系统部署在一台机器上，不涉登录系统的多机部署，此架构具有单点风险；任何具备高可用思维的架构师都不会允许此风险存在，原因有二：1. 统一登录中心后，SSO成为极为核心的应用，如果SSO系统挂了，那么需要登录的任何服务器都无法正常提供服务；2. 单台机器不具备抵抗登录风暴的能力； 所以SSO系统必须成为集群部署模式。其次，在访问控制模型上，也必须放弃JAAS方式，转而使用RBAC模型；</p><h4 id="3：-统一登录（分布式Session）-接口鉴权时代；"><a href="#3：-统一登录（分布式Session）-接口鉴权时代；" class="headerlink" title="3： 统一登录（分布式Session） + 接口鉴权时代；"></a>3： 统一登录（分布式Session） + 接口鉴权时代；</h4><p>SSO系统集群部署后，面临的首要问题就是Session的共享问题，比如用户在sso-1 机器上登录了，下次访问sso-2机器时，也必须是登录态的。分布式Session使用较多的方案为：Session集中管理；比如阿里巴巴基于Tair 缓存体系的共享session体系tbsession。如果采用了session + cookie的方案，并且服务端集群是多域名共享登录的话，那么还需要提供cookie跨域同步的能力（解决cookie不能跨域的问题）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。比如我们开放的功能页面需要登录授权之后才能访问，一些功能需要具备特定权限的人才能操作；再比如我们开放了数据API接口，如果不做访问控制，那么任何人都可以
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>Taobao SSO 跨域登录过程解析</title>
    <link href="http://heartaway.cn/2018/01/04/Program/2018-01-04-taobao-sso/"/>
    <id>http://heartaway.cn/2018/01/04/Program/2018-01-04-taobao-sso/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-11-09T14:26:38.603Z</updated>
    
    <content type="html"><![CDATA[<p>今年的双十一和双十二已经告一段落，你是否买到了你想要的宝贝呢？我们知道双十一是天猫的主场，双十二是淘宝的主场，你有没有注意到你在登录了淘宝后，访问天猫或者飞猪，你还是处于登录态的，但是我们知道cookie是不能跨域的，那么阿里是如何做到了多域名下的登录态同步呢？接下来我们通过抓包进行请求解析来了解这个过程。</p><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><ol><li>如果忘了Cookie和Session的区别，那么建议你先回顾一下，可以参考：<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md</a></li><li>如果不知道为什么需要鉴权，为什么需要SSO，为什么需要跨域登录，建议你先阅读上一篇文章“系统权限控制”。</li></ol><h2 id="测试过程："><a href="#测试过程：" class="headerlink" title="测试过程："></a>测试过程：</h2><ol><li>访问<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 请求登录，跳转到 login.taobao.com<ul><li>输入用户名和密码后，登录成功，302 回调到<a href="http://www.taobao.com页面" target="_blank" rel="noopener">www.taobao.com页面</a></li><li>Post 表单到 login.taobao.com , response 为 set-cookie，并通过redirectURL 跳会<a href="http://www.taobao.com首页；" target="_blank" rel="noopener">www.taobao.com首页；</a></li></ul></li><li>访问 <a href="http://www.tmall.com" target="_blank" rel="noopener">www.tmall.com</a><ul><li><a href="http://www.tmall.com页面响应中发起新的请求" target="_blank" rel="noopener">www.tmall.com页面响应中发起新的请求</a> tmcc.tmall.com/pass.com</li></ul></li><li>请求页面 <a href="https://tmcc.tmall.com/pass.htm" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm</a><ul><li>响应为 302 跳转到： <a href="https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1</a></li><li>tbpm=1表示：进行tbsession的跨域同步；</li></ul></li><li>请求页面 <a href="https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1</a><ul><li>在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息</li><li>响应为302跳转到：<a href="https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1" target="_blank" rel="noopener">https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1</a></li><li>服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。</li></ul></li><li>请求页面 <a href="https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1" target="_blank" rel="noopener">https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1</a><ul><li>携带cookie 信息的query string 参数请求 tmall.com域名下的信息，请求添加cookie。</li><li>响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步；</li><li>响应状态未302 重定向到 <a href="https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm?tbpm=1</a></li></ul></li><li>请求页面<a href="https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm?tbpm=1</a> 302 跳转到 <a href="https://tmcc.tmall.com/pass.htm" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm</a></li></ol><p>抓包信息：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/87d35687c06bdf7d01ea78c3aa1f8c7f.png" alt=""><br>图中隐藏了非关键请求，比如页面的静态资源等；</p><p>同样：</p><ol><li>访问 <a href="http://www.alitrip.com，会同步请求https://ffa.alitrip.com/userInfo.htm的请求" target="_blank" rel="noopener">www.alitrip.com，会同步请求https://ffa.alitrip.com/userInfo.htm的请求</a></li><li>请求页面<a href="https://ffa.alitrip.com/userInfo.htm" target="_blank" rel="noopener">https://ffa.alitrip.com/userInfo.htm</a><ul><li>响应为 302 跳转到：<a href="https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserInfo.htm" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserInfo.htm</a></li></ul></li><li>请求页面<a href="https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserIn" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserIn</a><ul><li>在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息</li><li>响应为302跳转到：<a href="https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4…" target="_blank" rel="noopener">https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4…</a></li><li>服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。</li></ul></li><li>请求页面<a href="https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4" target="_blank" rel="noopener">https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4</a><ul><li>携带cookie 信息的query string 参数请求 alitrip.com 域名下的信息，请求添加cookie</li><li>响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步;</li></ul></li></ol><p>示意图：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ad93fbcaff26e6b4bc3ca3af620468e9.png" alt=""></p><ol><li>访问原始url： tmcc.tmall.com</li><li>重定向，访问login.taobao.com/jump</li><li>重定向，访问pass.tmall.com</li><li>重定向，访问原始url（带有同步标识tbpm）</li><li>重定向，访问原始url（去掉同步标识tbpm）</li></ol><p>如果我们taobao.com域下没有登录cookie，通过在login.tmall.com页面进行登录，那么cookie的传递是怎么样的呢？<br>通过测试，发现在请求login.tmall.com的时候会同步请求login.taobao.com然后cookie依然是通过taobao域同步到tmall域名，也就是cookie的同步是单向；</p><p>当然，这个过程是正向流程，那退出登录的逆向流程是怎么样的呢？会同步请求login.taobao.com/clear, 通过set-cookie 清楚session cookie（会话cookie），然后进行 302 跳转到 <a href="https://pass.tmall.com/clear" target="_blank" rel="noopener">https://pass.tmall.com/clear</a> 进行cookie清理，然后 302 跳转到 <a href="https://pass.etao.com/clear" target="_blank" rel="noopener">https://pass.etao.com/clear</a> 进行cookie清理，然后 302 跳转到<a href="https://pass.etao.com/clear" target="_blank" rel="noopener">https://pass.etao.com/clear</a> 进行 cookie清理，如此重复知道所有域名cookie进行清理完毕。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/eafb7fc66c6139c50a6a8bbb5bd89e58.png" alt=""><br>通过测试发现淘系的系统所有的退出登录都是走login.taobao.com/member/logout.jhtml , 然后通过一些列302 跳转pass系统进行登录态的清理。 登录态在到阿里云、支付宝是不通的,因为阿里云和支付宝的账号体系不一样。</p><h2 id="禁用Cookie："><a href="#禁用Cookie：" class="headerlink" title="禁用Cookie："></a>禁用Cookie：</h2><p>可以看出整个跨域登录依赖的是cookie信息的传递与跨域设置，如果出于安全考虑，我们禁用了cookie，是否还能正常工作呢？经过测试，发现禁用cookie后，跨域自动登录不能正常执行了，跨域请求后对于受限的访问请求还是会自动跳登录。由于设计上没有考虑cookie禁用的情况，淘宝的登录页面竟然无法进入，一直循环跳转登录页面。</p><h2 id="分布式Session-的常见解决方案："><a href="#分布式Session-的常见解决方案：" class="headerlink" title="分布式Session 的常见解决方案："></a>分布式Session 的常见解决方案：</h2><ol><li>通过cookie进行共享；</li><li>借助第三方进行存储，比如缓存；</li><li>不容服务器之间进行session同步；</li></ol><p>这里面涉及到阿里两个重要级产品：tbsession、passcookie。</p><ol><li>tbsession：用来解决多应用间session共享存储与同步问题；tbsession采用的是 方法1 + 方法2的结合；</li><li>passcookie：用来解决不同域名之间cookie同步的问题，以及决定同步那些cookie；</li></ol><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>问：为什么有了cookie 还需要 session？</p><p>答：cookie存储本身具备一些优势，比如信息存储在客户端，分散了资源消耗，cookie可以在客户端进行持久化存储（cookie在客户端分为：Permanent Cookies，Session Cookie）。    主要是只使用cookie作为资源访问的鉴权记录具备不安全性，容易引起CSRF（跨站请求伪造），比如攻击者劫持登录后的cookie信息进行页面操作，此时服务器以为还是用户自身在登录态下的本人操作。当然，只是简单的使用session也并不能彻底解决CSRF，使用session只是把用户的登录态信息保存在服务器端，客户端cookie往往会记录一个JSessionId 用来标识当前会话ID，jsessionid在网络中传输还是存在被劫持的可能性（参考下面的session劫持），所以需要配合响应的解决手段防止CSRF的发生。其次，cookie的使用在大小和条数上限制，大于需要存储大量用户态信息的场景下已经不够用了，此时需要借助session在服务端的存储设备来实现。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/877347f9c7fc1318a494640818519c2a.png" alt=""></p><p>问：登录后会会话中的每一次访问受限资源都需要访问验证？</p><p>答：是的，因为每一次请求都无法确认你的身份，所以为了降低复杂认证授权的过程，通过sessionId 来标识某一会话；如果我们的Cookie信息泄露，那么不法分子就可以使用我们包含登录态的Cookie进行访问我们的受限资源（比如拷贝登录后的cookie信息通过postman请求需要登录后才能查看的信息），即便是我们丢增删改的请求采用了crsf_token ,不法分子还是可以看到我们的信息，信息已经造成了泄露。所以对于持久化Cookie，尽量设置为httpOnly，不允许通过JS脚本读取Cookie信息。还有就是使用https协议代替http协议（从tcp到ssl），这样不法分子劫持了请求信息，也无法破解请求信息的内容。</p><p>问：是否采用了https就不需要防范CSRF了？</p><p>答：不是的，我们采用https，是在数据传输层对请求进行进行加密后发送，但是如果CSRF是在浏览器的本地读取我们的Cookie信息（存储在我们浏览器中本地的Cookie信息确实明文的），还是可以读取到我们明文的Cookie信息。采用https只是防止了请求在传输中拦截后窃取我们的Cookie进行攻击而已。</p><h2 id="Session-劫持与防范："><a href="#Session-劫持与防范：" class="headerlink" title="Session 劫持与防范："></a>Session 劫持与防范：</h2><p>这篇文章详细阐述了服务器端不做任何处理下的sessionId劫持的案例。<br><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md</a></p><p>session 劫持的防范措施：</p><ol><li>使用POST 请求 + Referer验证；<ul><li>此方式简单容易实现；</li><li>弊端：1.所有请求都是用POST方式不符合规范，比如RestFul。2.很多场景下请求是无法携带referer的；</li></ul></li><li>使用csrf_token：在涉及增删改的请求中，带上一个和服务器端同步的随机数(token)，然后在服务器端做校验。由于这个token是变化的，同时具有私密性，只会内嵌到当前用户的页面中，因此可以起到防止CSRF的作用，比如淘宝域下cookie中的_tb_token_参数。</li></ol><p>csrftoken的整个生命周期一般是这样的：</p><ul><li>后端针对每一个用户生成唯一的csrftoken后    </li><li>将csrftoken存储在服务器端，且和当前用户一一绑定</li><li>当用户访问页面时，将csrftoken埋入前端页面</li><li>用户提交请求时，需要在请求中附带上csrftoken</li><li>后端对接收到的csrftoken进行校验，判断请求是否合法</li><li>根据请求，后端判断是非需要更新csrftoken</li></ul><p>使用csrf_token 方案目前来说是最有效的安全措施，但是方案实施起来也相对复杂很多，需要考虑csrf_token的存储、更新、埋点以及校验等逻辑。</p><h2 id="本质思考："><a href="#本质思考：" class="headerlink" title="本质思考："></a>本质思考：</h2><p>SSO 跨域统一登录的本质就是【登录态信息的跨域共享，为了实现共享采用了复制的方式】，这跟我们现实世界中为了达到知识共享，需要把知识转化为书籍，然后通过书籍印刷进行分发。</p><h2 id="抓包工具介绍："><a href="#抓包工具介绍：" class="headerlink" title="抓包工具介绍："></a>抓包工具介绍：</h2><ol><li>工具采用 mac 下的 Charles；</li><li>https由于安全限制无法抓取到具体的内容，所以需要通过一些列的设置才能抓到请求数据；</li><li>Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</li><li>Proxy -&gt; SSL Proxying Setting -&gt; SSL Proxying 添加正则域名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年的双十一和双十二已经告一段落，你是否买到了你想要的宝贝呢？我们知道双十一是天猫的主场，双十二是淘宝的主场，你有没有注意到你在登录了淘宝后，访问天猫或者飞猪，你还是处于登录态的，但是我们知道cookie是不能跨域的，那么阿里是如何做到了多域名下的登录态同步呢？接下来我们通
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>二零一七，我的失败与伟大</title>
    <link href="http://heartaway.cn/2017/12/29/Think/2017-12-29-2017-my-success-and-fail/"/>
    <id>http://heartaway.cn/2017/12/29/Think/2017-12-29-2017-my-success-and-fail/</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-11-09T14:28:50.414Z</updated>
    
    <content type="html"><![CDATA[<p>2017年飘然离去，留下的唯有回忆。这一年总有一些刻骨铭心，总有一些难以忘怀，依依不舍。或遗落在某一渡口，或消失在某段站台，或模糊在某页书籍。岁月洗礼而后，一一封存，装帧成册，遗忘的森林，层出不穷的景致，黯淡了记忆的门窗。当又一次轻扣，忽而想起那年夏天的故事，亦或冬天里的恋歌，轻捻时光，掀开了往事，撑开了回忆的帆。这一年有过痛苦、焦虑、烦躁，也有过欢乐，自信和拼搏。</p><p>如果说让我用一句话总结一下2017年，我想这句话会比较合适：</p><blockquote><p>认知上升了一个台阶，但仍未能克服行为上的懒惰；工作生活，持续反思与学习，但仍沉溺于专业深度的自卑之中。</p></blockquote><p>如果非要让我从过去一年中对自己的失败和伟大之处做一些“套路”上的总结的话，以下这几天应该被展现出来，愿它们像伴随我成长之路上的路灯，时时照亮我前行的路。</p><h2 id="1-认知升级，追本溯源"><a href="#1-认知升级，追本溯源" class="headerlink" title="1. 认知升级，追本溯源"></a>1. 认知升级，追本溯源</h2><p>这一年自己思想的改变应该算是最大的收获了。以前对待事情总是浮在表面，现在会主动去思考事情背后的关系与本质，到底是什么导致了当前的状态，每个人说的话其背后的逻辑是什么；比如当开会、讨论、看演讲时，都会跳出当前讨论的事情，去想他们为什么会这么说，理论基础是什么，期望达到一个什么目标。</p><p>近期通过研究高效学习的理论知识，逐步掌握学习知识的方法套路。学习的理论自己在高中和大学阶段坚持的不错，但是工作以来，坚持的并不算好，很多时候，一天过去了，回顾时，是浑浑噩噩的，对自己的人生似乎帮助并不大，感慨自己的浪费生命。记得之前看到过一句话，我们现在做的觉得有挑战的事情，之前已经有很多人应该都做过了，我们只需要看看他们踩过的吭和趟出的路就好的。这点无论是放在编程还是人生上来说，都适用。很多时候，我们不需要重复造轮子，有轮子直接购买使用就好，为自己的工作生活快速提效，这是一个一切为“<strong>效率</strong>”为核心的时代。</p><p>什么是认知升级，就是看到了之前自己看不到的地方，看问题的角度比之前上升了一个角度。如果把认知划分为本能层、情绪层、立场层、利益层、社会心理层、系统认知层和智慧认知层的话，我目前只能算是从本能层走到了情绪层，未来的路还有很多要走。</p><p><img src="/images/posts/20171229/2017-12-12-renzhi-lay.jpeg" alt=""><br>​                            （图片来自“雾满拦江”）</p><p>什么是认知，什么是格局，我觉得有一个例子很不错，值得自己记在心里：</p><p>《吕氏套秋》里记载着一则楚王失弓的故事，讲的是楚王去云梦泽打猎，不小心把自己心爱的弓丢了，侍从们要循原路寻找，楚王说，算了吧，不必去找了，楚人失之，楚人得之，到不了别处的。侍从们都很佩服楚王的豁达与胸怀。孔子听闻此事后说，这句话如果去掉“楚”字就好了，不妨说“人失之，人得之。”老子听说了孔子的评论后，也发表了自己的看法。他说再去掉“人”字会更好。那样就是“失之，得之”，这样才符合天道。</p><h2 id="2-把握自己的命运，不要把自己的未来寄托在别人手上"><a href="#2-把握自己的命运，不要把自己的未来寄托在别人手上" class="headerlink" title="2. 把握自己的命运，不要把自己的未来寄托在别人手上"></a>2. 把握自己的命运，不要把自己的未来寄托在别人手上</h2><p><img src="/images/posts/20171229/2017-12-12-stock.jpeg" alt=""></p><p>相信炒股的朋友都收到过推销内幕股的电话或者微信，他们通过前一天收盘后的预期与第二天开盘后的涨幅逐步获取你的信任，之后采用盈利分成或者入会费的方式，跟你合作，告诉你什么时间点买哪只股票，什么价位卖出。开始的时候，我确实在短时间内赚了好几千快，感觉他们太牛了，感觉这种赚钱方式比工作快多了，无法克制住自己的<strong>贪婪</strong>，投入大量的资金进去，此时一次正常的下跌也让我们损失惨重，炒作垃圾股，根本就没有持仓的信心。跳出来好好想一想，如果钱真的这么好赚，他们为什么还要花这么大的心思跟你分成呢？他们过分强调了平分你的收益而把风险完全抛给了你。其次，走位一个多年的老股票，完全听信一个不知专业深浅的人指导，这跟板上鱼肉有何区别呢？即使是赚了钱，你也获取不到技能的提升，对于你后续的投资思路不会有半毛钱帮助，有的只有那点钱了。</p><p>正确的投资股市方式是建立其自己投资模式，比如改“投机”为“投资”，注重收益与风险的管理，做优质企业的中长线价值投资等。</p><p>其次，这点在个人职业生涯中同样适用，我们伴随着团队成长的同时，也要明确知道自己在职业这个坐标体系中自己的位置，明确自己的目标坐标，通过资源争取或者个人努力，逐渐向目标靠拢，而不是等待着老板或者同事赶着你走。如果事事都是你的老板说了算，你自己没有主见的话，这跟被牵着鼻子走的牛没什么两样，在团队中，你也只能成为“老黄牛”了，当你老了，结果会是“卸磨杀驴”（2017年华为清退老员工事件）。反观自己，以前很少与老板探讨自己想要什么，不要做什么，现在有一定的自信说出自己的诉求，然后主动把握机会磨练自己的独特优势，这一点是一个进步。</p><h2 id="3-矫正心理饥饿的金钱观"><a href="#3-矫正心理饥饿的金钱观" class="headerlink" title="3. 矫正心理饥饿的金钱观"></a>3. 矫正心理饥饿的金钱观</h2><p><img src="/images/posts/20171229/2017-12-12-yunnan-lgh.jpeg" alt=""></p><p>由于自己出生在一个比较贫困的家庭，自幼对金钱就分外珍惜，什么钱都不舍得花，甚至认为除了基本保证生活的开支外，一切的花销都是多余的。很多人看到这点肯定会评价说是“抠门”，我们不能拿着自己优越的生活去评论不曾经历的贫穷生活，因为你想象不到，贫穷深入骨髓后是一种什么状态。每当在相亲节目中看到那些抠门的男方的时候，我都很难能理解，然而面对确实大家一边倒式的批判。改革开放40年来，人们的生活质量有了非常的提升，但是很多的养成的节省系统并不是说改掉就能改掉的，就像我父母，他们年幼时经历了大饥荒，知道现在全家年收入超过已经达到小康水平，但还每日担忧未来可能没有饭吃，非要在自家的储藏室中储藏上几袋大米，心理才有安全感，其实这个陈为“心理饥饿”。由于害怕失去钱，害怕自己变得一无所有，所以自己万事都尽量已保守节省的方式在生活，殊不知，在现代经济中，反而认为最安全的方式往往却是最危险的方式，比如父母为了少还一些利息，买房时尽量不让贷款，几乎全款买房，殊不知，合理负债才是家庭财务经营的正确指导。</p><p>这个世界正在以超乎我们想象的速度变化，如果我们还保守着过去看似正确的理念生活，那么我们会与优质生活质量相差越来越远。钱是用来花的，不是用来存储的，学会花钱也是一门艺术。合理的消费，不仅有助于提高自身生活质量，还能提高国家的经济效应。现在的我不在为一周多买一次水果而大呼小叫，不再为每餐两人三菜而觉得浪费，为了让自己生活有点品质，还是不是给家里买一些鲜花来装饰装饰，美好的生活反过来会对我们的工作行程正反馈，心情好了，工作效率也会高不少。</p><p>自从买了车之后，生活确实变得不一样了，说走就走的旅行变得不再那么困难，自驾游去千岛湖，飞行去昆明、丽江、大理和香格里拉，感受祖国的大美河山和不同的乡土文化，读千卷书，行万里路。世界这么大大，我们应该时长走出去看看，走出工作家庭两点一线之间的线性单调区间。</p><h2 id="4-为专业付费，免费的往往是最贵的"><a href="#4-为专业付费，免费的往往是最贵的" class="headerlink" title="4. 为专业付费，免费的往往是最贵的"></a>4. 为专业付费，免费的往往是最贵的</h2><p>互联网在过去5年，倡导的一直是“免费”的文化，让产品免费，让更多用户受益。我们在使用各种软件或者观看各种收费视频的时候，首先先到的是找一找有没有破解版或者不需要收费的服务，为了获得免费的东西，有时候我们花费了大量的时间和精力，事后想一想，如果把时间换算成钱的话，我们是亏了的。往往<strong>看似免费的东西是最贵的</strong>，这个世界上没有免费的午餐，<strong>一切事情都是有成本的</strong>，只是有些事情的成本是隐形的，不容易被我们察觉罢了。免费的东西，人人都能力，其质量就很差，我们长期阅读低质的信息，会阻碍我们思维升级。反而那些付费的内容，正因为我们的付费，才促就了内容生产者以更加严谨的态度来对待产品，这是一个良性循环。我们值得为优质内容付费，科学高效的方法论告诉我们，跟随业界一流的牛人学习，才是高效的学习策略之一。</p><h2 id="5-你的圈子决定了你的价值"><a href="#5-你的圈子决定了你的价值" class="headerlink" title="5. 你的圈子决定了你的价值"></a>5. 你的圈子决定了你的价值</h2><p>查尔斯琼斯说：通过一个人的朋友圈和他看的书就可以看到5年以后的他，也就是说呢，一个人是他周围5个人的综合体。从而形成了“五次元密友理论”。环境的力量，我们不得不信服。古代有孟母三迁，现代人为了一套学区房挤破脑袋。跟优秀的人在一起，我们会被优秀的气场所影响，观念、行为也逐步会发生改变。</p><p>所以很多成功学或者心灵鸡汤类的文章常常建议我们每年主动与比我们自身段位高的人的人交往与交流，虽然在我们与他们交往中会有一定的不适感，但我们需要认识到这是正常的生理反应，是突破舒适区的副作用，我们终究会逐渐习惯，这种不适感会随着我们段位的提升而逐渐消失。</p><p>反观身边那些职场中晋升非常快的人，在他们成长的路上，几乎都有一个伙伴，和他们一起成长，帮助他们坚持正确的决定，从而避开错误。一个好的有责任心的伙伴是这样的，无条件的爱你，他本身就渴望成功，成熟，会征求你的建议，在你需要帮助的时候能帮助你，能够陪伴鼓励你！你是不能一个人在成长的道路上走下去的，除非你不想达到顶峰。在看看自己当前身处的环境，是否有这样一个伙伴一同成长，如果没有，我们改如何破局？</p><h2 id="6-感悟人性"><a href="#6-感悟人性" class="headerlink" title="6. 感悟人性"></a>6. 感悟人性</h2><p>狗为什么会对陌生人狂吠，人为什么会对伤害自身利益的言论会极力反驳进而情绪失控？面对巨大利益的时候，我们为什么会贪婪？这些都跟本性有关，了解人性，对我们日常生活非常有帮助，无论是我们做投资还是与人相处。就好像，以前老婆跟我抱怨工作上的不顺利，每次在她还没有说完前，我就不耐烦的打断，一口要求都是你自己的错误，在无法改变别人的前提下，你为什么不改变自己呢，然后噼里啪啦的堆砌出一大推自认为很有哲理性的说教语句，换来的结果总是无话可说。当我知晓了这背后的人性需求后，从说教着改为倾听者、陪伴者，效果一下子就不一样了。人性，是需要持续学习和感悟的东西，未来我会花时间系统性的去了解人性的心理学体系。</p><h2 id="7-成为一名佛系青年"><a href="#7-成为一名佛系青年" class="headerlink" title="7. 成为一名佛系青年"></a>7. 成为一名佛系青年</h2><p><img src="/images/posts/20171229/2017-12-12-yunnan-party.jpeg" alt=""></p><p>去了一趟香格里拉，接触藏民后，彻底改变了我对藏民和佛教的看法。认知中，藏M是野蛮和暴利的代名词，佛教是无知的人期望佛教来改变自身命运，现在看来，原来自己如井底之蛙般视野短浅，认知还停留在本能层。在一名叫做“幸福哥”的藏M导游解说藏传佛教的信仰之时，自己不知不觉中流下了真诚而感动的泪水。回来的途中，阅读了鬼脚七的《人生所有经过的路，都是必经之路》，感受他在出嫁求佛路中的点滴感悟，领悟颇多，自此下定决心，没事就开始背诵和抄写心经。佛教教会我们如何看待自己和这个世界，这个视角是脱离自我的视角，是以更高层的认识来看到实物的视角；比如“画外看画”，脱离自我，站在旁观者角度审视自己的举止言行，我们会有不一样的思考。</p><p>在工作生活中，我也不断践行佛教的自我审视的方法，遇到不开心的或者困惑的事情，也尝试着使用佛教中思想来指导言行，虽然有些时候还是不能控制住自己的身为人的本性，但是我相信，通过不断的练习，终究会抵达彼岸，菩提萨婆诃。</p><h2 id="8-让自己成为有一技之长的专业人才"><a href="#8-让自己成为有一技之长的专业人才" class="headerlink" title="8. 让自己成为有一技之长的专业人才"></a>8. 让自己成为有一技之长的专业人才</h2><p><img src="/images/posts/20171229/2017-12-12-aliyun-profile-money.png" alt=""></p><p>身为一名软件工程师，但是迟迟没有专业自信，究其原因，是因为自己在专业性上的精力投入远远不够，由于积累的太薄，很多技术都不说不清其核心思想，当面对未知的问题时，顿时会觉得恐慌和无助，更不要谈自信了。如何成为专业的人才，方法和策略其实自己都已知晓，但是迟迟未能行动，即便是行动起来了，也是三天打鱼两天晒网。这是一个道理过剩，行动力匮乏的年代，我们不会因为知道了变得不一样，而会因我们做了什么而不一样。以此祭奠我过去5年的专业自卑感，计划用一到两年时间来培养自己的专业自信。</p><h2 id="9-认清自己的核心优势，差异化竞争"><a href="#9-认清自己的核心优势，差异化竞争" class="headerlink" title="9. 认清自己的核心优势，差异化竞争"></a>9. 认清自己的核心优势，差异化竞争</h2><p>总觉得自己啥都能干，但是啥都不专业。在面对当前追求效率的社会大浪潮中，分工越来越细化，我们必须清楚的自己在社会大分工中位置，知道自己相比于其他人有哪些优势，短板在哪里，如何发挥个人的差异化竞争。最近在招聘中，对于那些什么都能干，然后什么研究的都不深入，有没有任何亮点的同学，我们基本都会直接Pass掉。我们常常笑道：如果按照现在的标准，我们也许都面不过当前的岗位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年飘然离去，留下的唯有回忆。这一年总有一些刻骨铭心，总有一些难以忘怀，依依不舍。或遗落在某一渡口，或消失在某段站台，或模糊在某页书籍。岁月洗礼而后，一一封存，装帧成册，遗忘的森林，层出不穷的景致，黯淡了记忆的门窗。当又一次轻扣，忽而想起那年夏天的故事，亦或冬天里的恋
      
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>The Twelve-Factor App</title>
    <link href="http://heartaway.cn/2017/12/27/Program/2017-12-27-the-twelve-factor-app/"/>
    <id>http://heartaway.cn/2017/12/27/Program/2017-12-27-the-twelve-factor-app/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-11-09T14:26:55.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：</p><ul><li>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</li><li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。</li><li>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。</li><li>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。</li><li>可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。</li><li>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文的贡献者者参与过数以百计的应用程序的开发和部署，并通过 Heroku 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p><p>本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。</p><p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： Patterns of Enterprise Application Architecture ， Refactoring 。</p><h2 id="读者应该是哪些人？"><a href="#读者应该是哪些人？" class="headerlink" title="读者应该是哪些人？"></a>读者应该是哪些人？</h2><p>任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。</p><hr><h1 id="12-factors"><a href="#12-factors" class="headerlink" title="12-factors"></a>12-factors</h1><h2 id="I-基准代码"><a href="#I-基准代码" class="headerlink" title="I. 基准代码"></a>I. 基准代码</h2><p>一份基准代码（Codebase），多份部署（deploy）<br>12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。</p><p>在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。</p><p><img src="https://12factor.net/images/codebase-deploys.png" alt=""></p><p>基准代码和应用之间总是保持一一对应的关系：</p><ul><li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。</li><li>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。</li></ul><p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h2 id="II-依赖"><a href="#II-依赖" class="headerlink" title="II. 依赖"></a>II. 依赖</h2><p>显式声明依赖关系（ dependency ）<br>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p>12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， Ruby 的 <a href="https://bundler.io/" target="_blank" rel="noopener">Bundler</a> 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – <a href="http://www.pip-installer.org/en/latest/" target="_blank" rel="noopener">Pip</a> 用作依赖声明， <a href="http://www.virtualenv.org/en/latest/" target="_blank" rel="noopener">Virtualenv</a> 用作依赖隔离。甚至 C 语言也有类似工具， <a href="http://www.gnu.org/s/autoconf/" target="_blank" rel="noopener">Autoconf</a> 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。</p><p>12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h2 id="III-配置"><a href="#III-配置" class="headerlink" title="III. 配置"></a>III. 配置</h2><p>在环境中存储配置<br>通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，Memcached，以及其他 后端服务 的配置</li><li>第三方服务的证书，如 Amazon S3、Twitter 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 <a href="http://spring.io/" target="_blank" rel="noopener">Spring</a> 时 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html" target="_blank" rel="noopener">代码模块间的依赖注入关系</a> 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p><strong>12-Factor推荐将应用的配置存储于</strong> 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h2 id="IV-后端服务"><a href="#IV-后端服务" class="headerlink" title="IV. 后端服务"></a>IV. 后端服务</h2><p>把后端服务(backing services)当作附加资源<br>后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（<a href="http://dev.mysql.com/" target="_blank" rel="noopener">MySQL</a>，<a href="http://couchdb.apache.org/" target="_blank" rel="noopener">CouchDB</a>），消息/队列系统（<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>，<a href="http://kr.github.com/beanstalkd/" target="_blank" rel="noopener">Beanstalkd</a>），SMTP 邮件发送服务（<a href="http://www.postfix.org/" target="_blank" rel="noopener">Postfix</a>），以及缓存系统（<a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a>）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 <a href="http://postmarkapp.com/" target="_blank" rel="noopener">Postmark</a>），数据收集服务（例如 <a href="http://newrelic.com/" target="_blank" rel="noopener">New Relic</a> 或 <a href="http://www.loggly.com/" target="_blank" rel="noopener">Loggly</a>），数据存储服务（如 <a href="http://http//aws.amazon.com/s3/" target="_blank" rel="noopener">Amazon S3</a>），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。</p><p><strong>12-Factor 应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。</p><p><img src="https://12factor.net/images/attached-resources.png" alt=""></p><p>部署可以按需加载或卸载资源## 部署可以按需加载或卸载资源部署可以按需加载或卸载资源部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h2 id="V-构建，发布，运行"><a href="#V-构建，发布，运行" class="headerlink" title="V. 构建，发布，运行"></a>V. 构建，发布，运行</h2><p> 严格分离构建和运行</p><p><a href="https://12factor.net/zh_cn/codebase" target="_blank" rel="noopener">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li>构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。</li><li>发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。</li><li>运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。</li></ul><p><img src="https://12factor.net/images/release.png" alt=""></p><p><strong>12-factor 应用严格区分构建，发布，运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， <a href="">Capistrano</a> 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。</p><p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h2 id="VI-进程"><a href="#VI-进程" class="headerlink" title="VI. 进程"></a>VI. 进程</h2><p>以一个或多个无状态进程运行应用<br>运行环境中，应用程序通常是以一个和多个 进程 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。</p><p>12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤做此动作——正如 Rails资源管道 ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</p><h2 id="VII-端口绑定"><a href="#VII-端口绑定" class="headerlink" title="VII. 端口绑定"></a>VII. 端口绑定</h2><p>通过端口绑定(Port binding)来提供服务<br>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。</p><p>12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似<a href="http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。" target="_blank" rel="noopener">http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</a></p><p>通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。</p><h2 id="VIII-并发"><a href="#VIII-并发" class="headerlink" title="VIII. 并发"></a>VIII. 并发</h2><p>通过进程模型进行扩展<br>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。<br><img src="https://12factor.net/images/process-types.png" alt=""><br>扩展表现为运行中的进程，工作多样性表现为进程类型。</p><p>在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。</p><p>12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h2 id="IX-易处理"><a href="#IX-易处理" class="headerlink" title="IX. 易处理"></a>IX. 易处理</h2><p>快速启动和优雅终止可最大化健壮性<br>12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。</p><p>进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。</p><p>进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。</p><h2 id="X-开发环境与线上环境等价"><a href="#X-开发环境与线上环境等价" class="headerlink" title="X. 开发环境与线上环境等价"></a>X. 开发环境与线上环境等价</h2><p>尽可能的保持开发，预发布，线上环境相同<br>从以往经验来看，开发环境（* 从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li>时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li>人员差异： 开发人员编写代码，运维人员部署代码。</li><li>工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。</li></ul><p>想要做到 持续部署 就必须* 想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:</p><ul><li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li></ul><p>将上述总结变为一个表格如下：</p><p>传统应用    12-FACTOR 应用<br>每次部署间隔    数周    几小时<br>开发人员 VS 运维人员    不同的人    相同的人<br>开发环境 VS 线上环境    不同    尽量接近<br>后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。</p><p>类型    语言    类库    适配器<br>数据库    Ruby/Rails    ActiveRecord    MySQL, PostgreSQL, SQLite<br>队列    Python/Django    Celery    RabbitMQ, Beanstalkd, Redis<br>缓存    Ruby/Rails    ActiveSupport::Cache    Memory, filesystem, Memcached<br>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。</p><p>12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是## 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h2 id="XI-日志"><a href="#XI-日志" class="headerlink" title="XI. 日志"></a>XI. 日志</h2><p>把日志当做事件流<br>日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p>12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><p>找出过去一段时间特殊的事件。<br>图形化一个大规模的趋势，比如每分钟的请求量。<br>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</p><h2 id="XII-管理进程"><a href="#XII-管理进程" class="headerlink" title="XII. 管理进程"></a>XII. 管理进程</h2><p>后台管理任务当作一次性进程运行<br>进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><p>运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。<br>运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。<br>运行一些提交到代码仓库的一次性脚本。<br>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。</p><p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p><p>转发自：<a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">https://12factor.net/zh_cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>DevOps的三种方式</title>
    <link href="http://heartaway.cn/2017/12/24/Program/2017-12-24-devops-three-method/"/>
    <id>http://heartaway.cn/2017/12/24/Program/2017-12-24-devops-three-method/</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2018-11-09T14:26:59.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客中提到的“三种方式“源自 <a href="http://www.itrevolution.com/book/the-devops-handbook/" target="_blank" rel="noopener">《DevOps Handbook》</a> 及<a href="https://itrevolution.com/books/novel/" target="_blank" rel="noopener">《凤凰项目》</a>（The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win.），这三种方式描述了构成 DevOps 的理论框架、流程、实践及价值观和哲学。</p><p>感谢《Lean IT》的作者 Mike Orzen 为此文提供宝贵建议。</p><h2 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h2><p>下文将介绍三种模式及在该种模式指导下的 DevOps 实践。</p><h3 id="第一种方式：-系统思考"><a href="#第一种方式：-系统思考" class="headerlink" title="第一种方式： 系统思考"></a>第一种方式： 系统思考</h3><p><img src="https://gw.alipayobjects.com/zos/skylark/90fda8c1-ed1d-414d-bf7a-379e3fc7bd54/2018/png/46243fa7-bffa-4015-acd8-2597e974feee.png" alt=""></p><p>第一种方式强调全局优化，而非局部改进。— 大到部门职能划分（例如研发部和运维部门），小到个人（开发和系统工程师）。</p><p>这种方式将关注点放在整个业务价值流上。换句话说，整个团队应该关注在从需求被定义到开发，再到运维这个过程，直到价值被以服务的形式交付给最终用户。</p><p>将这种方式带到实践中的产出便是永远不要将已知的缺陷传递到下游工作，永远不要为了局部优化影响了整体价值流交付，总是为了增加价值流动努力，永远追求对架构的深刻理解。</p><p>涉及到这种方式的实践有：</p><ul><li>所有环境和代码使用同一个仓库，将软件包纳入版本管理</li><li>团队共同决定发布流程</li><li>保持 DEV、TEST、PRODUCTION 环境的一致性</li><li>自动化回归测试</li><li>小步提交，每日部署；而不是一次部署大量变更</li><li>更快、更频繁发布</li></ul><h3 id="第二种方式：经过放大的反馈回路"><a href="#第二种方式：经过放大的反馈回路" class="headerlink" title="第二种方式：经过放大的反馈回路"></a>第二种方式：经过放大的反馈回路</h3><p><img src="https://gw.alipayobjects.com/zos/skylark/f6cc08b5-b7e5-4162-92a3-0d0df213d902/2018/png/c8e97809-c293-4170-a84c-143789ea7faf.png" alt=""></p><p>第二种方式是创建从开发过程下游至上游的反馈环。几乎所有的流程改进都是为了从时间上缩短和从覆盖面上放大反馈循环，从而可以不断地进行必要的改正。</p><p>第二种方式的产出是关注到价值流中所有涉及到的用户，包括价值流内部和外部的，缩短和放大反馈回路，并且可以随时定位到需要改进的地方。</p><p>涉及到这种方式的实践有：</p><ul><li>代码审查及配置变更检查</li><li>有纪律的自动化测试，使许多同时的小型敏捷团队能够有效地工作</li><li>尽早设置监控预警</li><li>修复 bug 为团队最高优先级</li><li>团队成员之间高度互相信任</li><li>团队之间保持沟通和良好合作<h3 id="第三种方式：持续做试验和学习的文化"><a href="#第三种方式：持续做试验和学习的文化" class="headerlink" title="第三种方式：持续做试验和学习的文化"></a>第三种方式：持续做试验和学习的文化</h3><img src="https://gw.alipayobjects.com/zos/skylark/dfea288e-e3e5-4f41-b1c0-998f7def0202/2018/png/096c5099-06da-403c-8329-3c88f8851fd9.png" alt=""></li></ul><p>第三种方式提倡持续做试验，承担风险、从失败中学习；通过反复实践来达到精通。</p><p>我们需要实验和冒着失败的风险，及时不断地尝试将我们置于一个危险的境地，我们要通过反复试错来掌握使我们远离危险的技能。</p><p>第三种方式的输出为为改善日常工作分配时间、奖励团队冒险精神，将错误人工引入系统以提高系统健壮性。</p><p>最具有代表性的就是 Netfilx 的 Chaos monkey ，Netflix 在他们的生产环境搭建一个服务用于定时随机关闭服务器，用以模拟服务器正常损坏或服务异常，他们的系统长期在这种环境下运行，“服务器故障”成为系统每日都要面临的问题，因此当服务器真的以外故障时不会对系统整体造成任何的影响。</p><h2 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h2><p>全局优化、快速反馈、鼓励失败。我们发现其实敏捷、精益、持续交付、DevOps中间有很多相似的东西。</p><blockquote><p>参考资料: <a href="https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec" target="_blank" rel="noopener">https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec</a></p></blockquote><blockquote><p><a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">http://itrevolution.com/the-three-ways-principles-underpinning-devops/</a></p></blockquote><p>转发自：@duyidong</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇博客中提到的“三种方式“源自 &lt;a href=&quot;http://www.itrevolution.com/book/the-devops-
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>《那时花开》</title>
    <link href="http://heartaway.cn/2017/12/20/Think/2017-12-20-high-school-years/"/>
    <id>http://heartaway.cn/2017/12/20/Think/2017-12-20-high-school-years/</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2018-11-09T14:28:58.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作品：《那时花开》</p><p>字数：约 35000 字</p><p>体裁：中篇小说</p><p>关键字：校园青春</p><p>背景：小说记录了自己以在高中时期一群小伙伴的学习生活，作者：陈晓雷</p></blockquote><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ebd88c6345e5ad414d1007e6f121417e.jpg" alt=""></p><p>袁河是高二上学期转到陆可凡他们班的。至于转班的原因却不得而知。不过众所周知的是，陆可凡他们班的语文老师是袁河的爸爸，所以就有人猜测这可能是他爸爸的注意，目的很简单，无非就是为了方便监督和管教儿子学习。那为什么到了高二才转班呢？答案也很简单，因为高二是承上启下的关键学期，既能延续高一时的学习状态，又能为高三做准备，所以这时转班最合适不过了。</p><p>转到陆可凡他们班上后，袁河发现了一个奇怪的现象。</p><p>比如一般课间休息的时候，同学们都会以固有的方式来放松自己。其中少数同学会走出教室，站在外面的走廊上，抬头仰望天空，认真盘算自己忧伤的心事。或者靠在旁边的栏杆上，低头看着地面，仔细回忆某天的快乐心情。而大多数同学则会三五成群地聚在一起，找一个大家都感兴趣的话题，然后各抒己见，开始谈论。<a id="more"></a></p><p>如果是男生的话，通常都会选择这样的话题。比如昨天的美国篮球比赛。比如目前的世界足球状况。比如台湾当局复杂的问题。比如中国军队使用的武器。比如某部好看的电影。比如某款好玩的游戏。等等等等。</p><p>如果是女生的话。那能够谈论的话题可就非常多了。她们可以从几天前在报刊杂志上看到的一则新闻，一直谈论到当今娱乐圈最闪亮的某个明星。她们甚至可以从几年前在自家门前新栽的一棵小树，一直谈论到现在时尚界最前卫的某种发型。永远也说不完的样子。简直匪夷所思。</p><p>一般情况下，在上课前，大家都会得出一个令人满意的答案，然后意犹未尽地回到座位上，开始上课。当然也有同学因为观点对立，结果争得面红耳赤不可开交，最终在上课前也没有达成共识。于是等下节课上完后，再接着继续谈论，直到得出相同的观点为止。</p><p>对于这样的课间谈论，如果遇到比较感兴趣的话题，袁河有时也会参与其中的。虽然他对那些话题真正知道的并不多，而且发表的见解也有些自以为是。但这并不影响他参与其中的热情。他始终觉得这样做很有意思。特别是在上课感到烦躁不愿听讲的时候，稍微回想一下刚才热烈谈论时的情景，心情马上就会好起来。真有点不可思议。</p><p>但是陆可凡，却从来不会参与这样的课间谈论，也从不会关心任何与学习无关的话题。课间休息的时候，他除了上厕所外，几乎一直都坐在教室里面，要么一边左手不停地抚摸耳边的短头发，一边右手握笔默写各种各样的定律，完成各种各样的试题；要么就是一边右手不停地转动白色的圆珠笔，一边左手翻书回顾上节课老师所讲的知识，预习下节课老师要上的内容。好像永远都是这样。除了课间谈论外，对于学校举行的各种文艺晚会或者比赛，陆可凡也从来没有报名参加过。他所做的就是站在台下，当一名最普通的观众。如果节目精彩的话，就轻声鼓掌；如果比赛糟糕的话，就转身离开。仅此而已。</p><p>2</p><p>袁河曾经问过陆可凡为什么要这样。陆可凡笑着回答说，其实我并非完全排斥和拒绝这些热闹的东西。我知道这些东西确实很有意思。你们通过这些东西能够放松心情，获得快乐。这当然很好。但是我也有自己获得快乐的方法。那就是学习。对我来说，没有什么事情能比学习更让人感到快乐的了。所以我认为实在没有必要参与那些东西。而且你知道的，像我这样的性格，也根本不适合那些东西。怎么说呢？与热闹和喧嚣相比，我觉得只有安静才是最重要的。因为我是一个特别安静的人。我喜欢的只是安静而已。</p><p>听完这样的回答，袁河并没有予以反驳。他知道陆可凡所说的都是真的。这一点他非常肯定。因为陆可凡从来没有骗过他。而且在他面前，也从来没有隐瞒过任何事情。毕竟他们是那么好的朋友。</p><p>其实袁河转到他们班上没几天就已经知道，陆可凡获得快乐的方法，就是学习。因为他从来只有在课堂上回答问题时，才会格外积极兴奋。也只有在考场上运筹帷幄时，才会露出得意的笑容。整日心醉于很高的分数。完全沉浸在题海之中。几乎有点不可理喻。</p><p>而且从陆可凡下课后的表现来看，就会知道他是一个特别安静的人。有一个别人没有注意到的细节是，陆可凡在吵闹的环境下，总是紧皱眉头，有些厌恶的样子。如果吵闹声超出他的承受范围，就会用手掩耳，或者另找静地。向来都是如此。</p><p>既然袁河早就知道这些事情，那么他为什么还要明知故问呢？因为他觉得陆可凡一直这样默默无闻死气沉沉地生活很不好。他想认真听一下陆可凡的心里话，然后尽量帮他改变这种现状，让他变得活泼开朗起来。但是陆可凡却说，学习才是他最大的快乐。他真正喜欢的，只是安静而已。言下之意是，他对目前的生活很满意，根本不想改变什么现状，一切最好还是维持原样，不要有所变动。这样袁河就不好说什么了。他想，如果把自己的观点讲出来的话，也许会让陆可凡不高兴。既然如此，那就顺其自然吧。</p><p>对于陆可凡提出的“我是一个特别安静的人”这种说法，除了他的两个朋友袁河与赵燕外，几乎所有人都表示不赞同。因为陆可凡平时不爱说话，喜欢沉默。从来不会主动与人交往，更不会刻意去接近谁。走在路上遇到同学，从来不说一句话，总是随便点一下头，或者微笑一下，就算打过招呼了，然后直接走开。在陌生人面前，或者在认识但不熟悉的人面前，总是一副冷漠而又抗拒的表情。别人遇到难题向他请教时，他总是把解题过程写在草稿纸上递给人家，然后继续做自己的事情。所以别人用来形容他的词语，都像是结了冰的刺刀一样，寒冷而又尖锐。比如清高。比如孤傲。比如嚣张。比如狂妄。比如自以为是。比如目中无人。等等等等。反正没有一个好词。甚至还有人在背地里说，他不就是学习好吗？这有什么了不起的？清高什么啊？</p><p>对于这样的评价，陆可凡感到非常气愤。他对袁河说，我只是因为不善言谈，所以才会很少说话。我只是因为害羞，所以才会不与他人交往。我只是因为内向，所以才会不习惯跟人打招呼。我只是因为拘谨，所以才会逃避陌生或不熟悉的人。而所有这一切，都只是因为我喜欢安静而已。我哪里清高孤傲了？我哪里嚣张狂妄了？我哪里自以为是了？我哪里目中无人了？我讲过自己了不起吗？他们怎么能这样说我呢？简直气死人了。</p><p>袁河拍了一下陆可凡的肩膀说，他们只是因为对你不了解，所以才会那样说你。这些话你不要放在心上就是了。袁河说完看着陆可凡脸上郁闷的表情，低声叹了一口气，唉，我跟你说过多少次了，要变得乐观开朗一点，要多与同学们交往，可你就是不听。陆可凡说，废话，谁不想跟你一样？可是这些我根本都做不到，你让我怎么变啊？陆可凡说的没错，这些他确实做不到。所以上次袁河才会忍住没有对他说那些话。一切还是顺其自然吧。</p><p>3</p><p>其实陆可凡一点都不知道，在他们交往之前，袁河也认为他是一个清高孤傲而又狂妄自大的人。因为刚转到他们班上不久，袁河向陆可凡请教学习上的问题，但是陆可凡却一言不发地把解题过程写在草稿纸上递给他后，就不再理他了。很自负的样子。每次在路上碰面，袁河都会主动跟他打招呼，但是陆可凡却向他随便点一下头，便直接走开了。这让袁河特别尴尬。课间休息的时候，袁河在他旁边高声重复某个话题，想吸引他的参与。但是陆可凡却一直无动于衷，总是安静地坐在那里，不停地转动手中白色的圆珠笔。这让袁河感到非常泄气。天下怎么会有这样的人啊？真是没见过！</p><p>高二下学期，学校调整了一次寝室，他们被安排在了同一间宿舍。袁河以为机会来了，便想出各种办法去接近陆可凡。但是得到的依然是那张冷漠的脸。这让袁河相当懊丧。也就从那时起，袁河便认定陆可凡是一个清高孤傲而又狂妄自大的人，除了学习好外，简直一无是处，白白浪费自己的感情。直到后来通过辗转调位做了同桌，他们才逐渐开始交往起来。然而他们之间的关系却毫无进展。因为交往有限。直到那天晚上。一切才得以改变。</p><p>记得那天晚上是三个英语自习。平时自习课如果老师不在的话，那么同学们都会安静地坐在那里看书或者记单词。但是那天晚上却有些反常。根本不知怎么回事，教室里面一直闹哄哄的，到处都是噪音，那些班干部们非但对此视而不见，反而还带头说笑。在这样的环境下，袁河与陆可凡完全无心学习。于是便开始聊天。</p><p>袁河提议说，我们来谈论各自的初中生活，好不好？陆可凡想了一下，然后点点头表示同意。没想到在谈论的过程中，他们惊奇地发现，两人居然会有那么多类似或者相同的经历。比如，他们都曾当过班长。比如，他们都曾指挥过学校举行的合唱比赛。比如，他们都曾是学校鼓乐队中的一名鼓手。等等等等。两人越说越兴奋，说到最后都有种想哭的冲动。真是相交恨晚啊。</p><p>三个英语自习就在他们的追忆和谈笑中结束了。而以前袁河对陆可凡的所有误会，也都在谈笑间灰飞烟灭了。那天晚上，袁河才发现，其实陆可凡是一个很亲切，很随和，很容易接近的人。后来，他们就成为了朋友。</p><p>对于“陆可凡是一个很亲切很随和很容易接近的人”这种说法，又是除了他的两个朋友袁河与赵燕外，几乎所有人都表示不赞同。他们用来形容陆可凡的还是那些冰冷而又潮湿的词语。不过对此陆可凡已经不在乎了。他曾对袁河说，我发现想要取悦每一个人，或者指望别人都来理解你，那是根本不可能的。所以他现在常说的一句话就是，走自己的路，让别人说去吧，不管他们说什么，就当自己没听过。</p><p>对于陆可凡这样的心态，袁河当然可以理解。毕竟被人误会的滋味可不好受，与其怀恨与心，不如充耳不闻。没办法。不得已而为之。</p><p>对于那些出言贬斥陆可凡的人，袁河也能够理解。毕竟陆可凡所有的行为，给人的感觉，就是清高孤傲，目中无人。再说自己以前不也是这样认为他的吗？没办法。想要接近陆可凡实在太难了，想要成为陆可凡的朋友，那就更难了。别人当然会这样说他！</p><p>袁河曾经试图想要跟别人解释陆可凡不是那样的人。但是他们根本不听，你以为我们会相信你所说的话吗？你是他的朋友，当然会替他开脱了！于是袁河只好闭嘴。但是他在心里却说，总有一天，你们会重新认识陆可凡的！</p><p>4</p><p>对于陆可凡的另外一个朋友赵燕，袁河感到非常好奇。</p><p>因为在他和陆可凡成为朋友之前，他们就已经是朋友了。所以袁河并不清楚他们之间的交往过程。据他所知，陆可凡与赵燕是高一下学期分文理科之后才认识的。在这之前，他们陌生的就像间隔了几万光年的两个星球一样。根本不知彼此。</p><p>说到这一点，其实大家都一样。因为大家都是不同地方的人，初中都在不同的学校读书。经过中考的筛选，大家才来到了这所学校，走进了这个班级，然后才慢慢认识的。当然也有例外，就是两人从小便在一起读书，几乎没有分开过，当然这种情况很少。至少陆可凡与赵燕就不是。他们的确是高一下学期分到这个班后才认识的。并且也仅仅只是认识而已。彼此都不熟悉。</p><p>因为陆可凡从来都不会主动和人说话，尤其不和女生说话，至于跟女生交往做朋友，那就更别提了。那么他们到底是怎么成为朋友的？而且关系还那么好？</p><p>直到袁河与赵燕成为同桌后，他才终于弄明白了陆可凡与赵燕之间的交往过程。</p><p>说起同桌，袁河已经想不起来赵燕究竟是他第几个同桌了。因为他爸爸经常毫无缘由地调座位。表面上说是为了促进大家团结，其实是为了防止男女生做同桌时间长了谈恋爱。所以他的同桌总是一变再变。最后同桌就从陆可凡换成了赵燕。至于陆可凡与赵燕之间到底穿插了几个同学，袁河早就已经记不起来了。有时袁河会想，那些人恐怕也早已忘记我这个同桌了吧。</p><p>那天中午，袁河在食堂吃完饭回到教室，发现陆可凡正坐在自己的位子上，给同桌赵燕讲题，于是就转身坐到了陆可凡的位子上。</p><p>陆可凡就是这样的人，如果别人向他请教题目时，他总是把解题过程写在草稿纸上，然后递给人家，就算完成任务了。但是袁河与赵燕向他请教题目时，他则会非常认真地讲解，绝不敷衍。而这也正是别人那样说他的原因。</p><p>袁河曾经问过陆可凡可不可以像对待他们那样给别人讲题。陆可凡摇摇头说，对不起，我做不到。袁河问为什么？陆可凡说因为那样会让他感到拘谨，浑身不自在。然后袁河就不再说什么了。因为无话可说。</p><p>5</p><p>袁河坐在陆可凡的位子上，随手拿起一本书，刚准备翻阅，却忽然有样东西从里面掉了下来。袁河低头一看，是一个非常漂亮的蓝色纸飞机，心想陆可凡真有闲情逸致，都这么大的人了，还折纸飞机玩，未免也太幼稚了吧。</p><p>袁河笑着拾起纸飞机，边看边想，等以后有机会了，好好嘲笑一下陆可凡，问他是不是还在过童年。真有意思。</p><p>袁河看着看着忽然发现，纸飞机被折叠起来的部分隐隐约约写有几行字，心想陆可凡居然能把公式定理之类的东西默写在这里面，真是太有才了。自叹不如。</p><p>袁河把纸飞机放在眼前，仔细看了看，觉得里面写的东西根本不像公式定理什么的，但是却又无法得知里面到底写的是什么。</p><p>因为首先那张纸有点厚，其次从外面看字体是反的，再者那些字由于折叠的缘故，大部分都重合在了一起，所以看来看去，毫无头绪。努力辨认，也只能看到个别字的大致轮廓。根本无法得知里面写的内容。</p><p>看到最后，袁河可以肯定的是，那些字绝对不是陆可凡写的。因为陆可凡的字，横七竖八，张牙舞爪，仿佛九曲黄河，亦如山路十八弯，如果不知道的，还以为那是甲骨文呢。像这样清秀美丽的字体，打死他都写不出来。如此说的话，这个纸飞机肯定不是陆可凡折的。那会是谁折的？从字体来看，应该是一个女生写的。那么这个女生到底是谁呢？</p><p>袁河很想拆开纸飞机，看一下里面到底写的什么内容，但是后来一想，这可是陆可凡的隐私啊，自己不能这样做，于是便放弃了这个念头。算了，等以后有时间了再问他吧。这样想着就把纸飞机重新夹在了书中。</p><p>袁河刚把书放好，陆可凡就回来了。</p><p>袁河问，题目讲完了？</p><p>陆可凡笑着点点头。</p><p>袁河起身拍了一下陆可凡的肩膀，然后回到自己的座位上，开始做数学题。仿佛刚才什么事情也没有发生过。</p><p>袁河才做了三道题就卡壳了，急得心烦意乱抓耳挠腮。</p><p>赵燕见状问他怎么了。他指着第四道综合题说，做着做着遇到一个碉堡，攻不下来，都快把我给急死了。</p><p>赵燕也幽默地说，那就让我来帮你炸掉它吧。说完看着袁河微微一笑，陆可凡刚才已经给我讲过这道题了。</p><p>提到陆可凡，袁河忽然想起有个问题还没有向她请教，于是等赵燕讲完题目便问，哎，那个，你和陆可凡是怎么成为朋友的？</p><p>赵燕一愣，你怎么突然想起问我这个问题？</p><p>袁河挠了一下头，到目前为止，我还没有看到陆可凡和其他女生说过话，但是他在你面前却无话不说。对此，我真的很好奇啊。</p><p>袁河用手捋了一下眼前的头发，你可不可以跟我说说你们之间的交往过程啊？当然，如果不方便说的话，那就算了。</p><p>赵燕看着他脸上略带祈求的表情，忍不住扑哧一笑，你真想知道吗？</p><p>袁河笑着点点头，肯定了，要不然我问你干吗？</p><p>赵燕说，其实我们之间的交往很简单，根本没啥可说的，不过，既然你想听，那我说说也无妨。然后赵燕就像电影中的主人公一样，低下头开始回忆。</p><p>6</p><p>那时高一下学期文理科分班已经有几个星期了，同学们差不多都已经相互认识彼此熟悉了。课间休息的时候，大家再也不会像刚分班那样，死气沉沉地坐在位子上，望着天花板发呆，而是纷纷走出教室，然后三五成群地聚在一起，谈论各种各样的话题。以此放松心情。当然也有同学会安静地坐在教室里面，专心做自己的事情。比如，陆可凡。</p><p>那天应该的星期六吧。赵燕记得那天下午第二节课上完后，同学们都纷纷走出了教室。不过这个时候，大家谈论的内容，已经不再是天下新闻，或者娱乐八卦，而是明天的出行计划，以及活动安排。因为明天就是周日了。</p><p>可是赵燕和好友林依然还没有说完周日的计划安排，上课铃便响了。于是在回到座位的路上，赵燕边走边扭过头，继续和林依然商量。</p><p>忽然只听“咔嚓”一声，好像踩断了什么东西。</p><p>赵燕吓了一跳，连忙转过身低下头，只见脚边一支白色的圆珠笔已经碎成几片，眼看是不能用了。而此时的陆可凡，正弯下腰伸出手，准备去捡那支笔。</p><p>这到底怎么回事？</p><p>原来第二节下课后，陆可凡坐在位子上，一边认真地复习刚才老师所讲的知识点，一边不停地转动手中白色的圆珠笔。上课铃响后，他开始准备第三节课要用的东西。结果不小心，把笔掉在了过道上。等一切准备就绪刚要去捡笔时，却没想到被赵燕踩成了碎片。于是一切就变成了现在这个样子。</p><p>赵燕还没有来得及向陆可凡道歉，老师就已经来了。赵燕只好慌忙地说声对不起，然后回到了自己的座位上。</p><p>陆可凡浑身上下只有这支白色的圆珠笔，没有备用的，可是现在却被赵燕踩碎了，无法抄写板书，急得手心直冒汗，本想张口跟同桌借支笔用，但是想到平日与同桌尴尬的关系，便放弃了这个念头，正在这时，肩膀忽然被人点了一下，惊得差点跳起来，于是趁老师转身写字的空当，回过头问后面那位同学为什么戳自己。那位同学什么也没说，只是拿起桌上一支粉红色的钢笔递给他。陆可凡接过笔，连忙道谢。不料那位同学却挥了一下手说，不用谢我，这支笔是赵燕的，我只是负责传递而已。</p><p>因为那个同学对陆可凡很有意见，总是经常在背后对人讲，他不就是学习好吗？这有什么了不起的？清高什么啊？所以刚才说那些话时，脸上的表情异常冷漠，而且说话的声音也像在冰箱中冻过一样，寒气逼人。陆可凡没有理他，转身开始抄写板书。</p><p>说起上课传递东西，真可谓历史悠久。至于久到什么年代，谁也说不清楚。因为各类文献上均没有记载。</p><p>陆可凡想，如果有人要考证这个东西的话，也不知道要追溯到多少年前。在陆可凡的记忆中，好像自从上学后，班上就有人开始趁老师不注意传递各种东西了。</p><p>至于传递的东西简直千奇百怪。比如，水果，零食，橡皮，衣服等等。不过传递的最多的却是小纸条。因为方便。而且隐蔽。不易被老师发现。所以很受同学欢迎。</p><p>至于传递的距离则有远有近。最远的便是对角线传递。而最近的则是同桌间的传递。并且传递的方式还多种多样。有从课桌上面递的。有从桌子下面传的。有从空中直接用手抛的。有从地面干脆用脚踢的。等等等等。想想真有意思。</p><p>直到老师将本节课的重点内容大声重复了一遍，陆可凡这才回过神来，发现自己思想开小差了，顿时懊恼不已。</p><p>陆可凡抄完板书，准备盖笔套的时候，才忽然发现笔上缠有一张小纸条。他把小纸条取下展开，只见上面写道：</p><p>陆可凡，上课前不小心把你的圆珠笔踩坏了，真是对不起啊，我不是故意的。那个……放学后请不要走好吗，我有件事想跟你说。</p><p>末尾署名是，踩坏你笔的那个人。</p><p>陆可凡想，不就是一支小小圆珠笔，用得着这样郑重其事吗？她说有事要跟我讲，到底什么事呢？算了，等放学后再说吧。</p><p>若在平时，以陆可凡那样的性格，早就拒绝了赵燕的请求。但是现在他却答应了。</p><p>因为赵燕的笔还在他手上。他应该把笔还给人家。再者他也有些好奇。赵燕到底会有什么事情要跟自己说呢？最主要的是，他觉得赵燕这个女生还不错，不像其他女生那样令他讨厌。所以顺理成章就答应了赵燕的请求。</p><p>7</p><p>下午放学后，等其他同学都走光了，赵燕这才走到陆可凡面前，抱歉地说，真是对不起啊，我不是故意要踩坏你的笔，我只是……</p><p>陆可凡轻轻打断她的话，没关系，不就是一支笔嘛，踩坏后再去买就是了，你这样客气反倒让我觉得有些不好意思。那个，你有什么事要跟我说？</p><p>赵燕微微一笑，为了表示歉意，明天中午，我想请你吃饭，怎么样？我已经和林依然约定好了。</p><p>陆可凡原本想说谢谢算了不用吧。但是看到赵燕脸上的笑容，有些不忍拒绝，于是犹豫了一下便答应了。</p><p>等赵燕转身已经走出很远了，陆可凡这才想起来笔还没有还给她，于是大声喊道，你的笔还在这里呢。</p><p>赵燕停住脚步站在窗户前笑着说，那支笔送给你好了，算是赔偿吧。说完就从窗户边消失不见了。</p><p>陆可凡看着手中粉红色的钢笔，轻轻摇摇头，径直走到赵燕的课桌前，把笔放进她的文具盒中，然后下楼走进商店买了一支白色的圆珠笔，这才满意地笑了。</p><p>第二天中午，陆可凡，赵燕，还有林依然，他们三个人是在校园外面一家名叫“三回头”的小餐馆里面吃的饭。</p><p>虽然这家餐馆名字起的俗不可耐，听着极不舒服，但是因为这里环境优美，饭菜可口，价格实惠，所以像生日聚会或者请客吃饭什么的，大家一般都会选择这家餐馆。有些人都不知道已经回过几次头了。</p><p>三人在吃饭的时候，陆可凡与赵燕一直不停地说话。而林依然则自始至终都沉默不语。就像绿叶一样，成为他们两个人的陪衬。</p><p>好像从那以后，陆可凡与赵燕就成为了很好的朋友。</p><p>8</p><p>赵燕讲完这些，看着袁河笑了，谁说陆可凡是一个清高孤傲而又狂妄自大的人？简直胡说八道。陆可凡根本就是以个很亲切，很随和，很容易接近的人。</p><p>袁河点点头表示同意。</p><p>赵燕忽然说，哎，有时候我发现，你与陆可凡还蛮像的。</p><p>袁河笑了笑，你终于看出来了，其实这正是我转班的原因。怎么样，觉得特不可思议吧。我跟你说啊，高一上学期刚开学的时候，就有人说我们长得像。那天我和一个同学在食堂吃饭，正吃到一半，同学突然用手推了我一下说，你有没有发现那个人和你长得很像啊。我说那个人，同学用手指了指不远处同样也在吃饭的陆可凡说，就是他，你看和你像不像。当然那时我并不认识他。我顺着同学指的方向看去，果然发现那个人和我长得很像，觉得这是缘分，于是就萌发了想转到他们班上的念头。后来我到处打听，才知道他就在我爸爸带的班上，于是便央求爸爸转班，可是我爸起初死活不答应，说在哪个班学习都一样，没必要转班，我说为了方便您监督和管教我的学习，就让我转到你的班上吧，我爸一想也对，于是就答应高二的时候让我转班。所以我就转到你们班上了。</p><p>袁河说到这里停顿了一下，然后说，你知道我当时最担心什么吗？赵燕问，你最担心什么啊。袁河回答说，我当时最担心的是，高一下学期分文理科后，陆可凡还在不在我爸的班上，要是不在的话，那我岂不是白转了。没想到他报的是理科，居然还在我爸的班上，你说这是不是缘分？</p><p>赵燕说，嗯，看来你们真的很有缘。不过我的意思是，除了长得有些像外，在某些方面，你们也蛮像的。</p><p>袁河问，什么方面？性格吗？不会吧。我和他的性格可是相差几万光年呐，坐飞机都追不上的，像什么像啊？真佩服你的眼力。</p><p>赵燕反问道，谁说你们性格像了？甭说飞机了，就是坐火箭也不行呀！我是说，在某些方面，你听不懂啊？</p><p>袁河搔了一下后脑勺儿，嗯，让我好好想想。</p><p>9</p><p>袁河想了半天，倒是想起了一些东西。他对这些东西慢慢回忆，细细品位，发现赵燕说的没错，在某些方面，他与陆可凡还确实蛮像的。</p><p>他记得有很多次，他们都不约而同地说出了同样的话语；有很多次，他们都心照不宣地写下了同样的文字；有很多次，他们都心有灵犀地做出了同样的动作；有很多次，他们都不由自主地选中了同样的东西……</p><p>袁河还想起了很多与陆可凡做同桌时所发生的事情。</p><p>记得那时袁河有一个专门用来写字绘画的黑色笔记本。他们做同桌的时候，如果平时闲着无聊了，或者上课不想听讲了，就会在那个笔记本上信笔涂鸦，然后在下面标上日期，怡然自得。曾经有很多次，他们都画出了同样的图画。每当这时，两人就会相视一笑，然后把手紧紧地握在一起。虽然不说一句话，但是心里却已温暖如春。</p><p>现在回想起这些事情，心里忽然有种特别的感觉。到底是什么感觉呢？嗯，应该是那种很甜美很温馨的感觉，就像池塘中被风吹拂的莲花，微露出清淡的甜，散发出诱人的香，让人沉醉其中，让人回味无穷。</p><p>袁河觉得上高中能够和陆可凡成为朋友，是他今生最大的幸运，也是他今生最大的快乐。如果没有陆可凡的话，那么他的生活就不会像现在这样精彩，而他的记忆也不会像现在这样丰盈。</p><p>不知道为什么，袁河突然有种想哭的冲动。但是最终却没让眼泪掉下来。因为他是男子汉，不能流泪。</p><p>袁河朝赵燕看去，发现她正在做题，于是也拿出习题册做了起来。</p><p>10</p><p>因为袁河与赵燕是同桌关系。所以平时闲着没事了，或者题目全都解决了，两人就会坐在位子上聊天。海阔天空地闲聊。从古说到今。从天说到地。从西方说到中国。从现在说到将来。没完没了。无头无序。但是却很快乐。</p><p>不过通常情况下，都是赵燕在手舞足蹈不停地说话。因为袁河根本插不上嘴。所以只好专门负责倾听。袁河想，其实这样也挺好的，能够增长见识，可以开阔视野，嗯，不错！</p><p>但是很多时候，赵燕说着说着就会突然把话题转移到自己身上来。弄得袁河莫名其妙猝不及防。其实说句心里话，与那些稀奇古怪乱七八糟的新闻相比，袁河更喜欢听她讲述自己。因为真实。</p><p>自从做同桌以来，赵燕向他说过很多自己初中美好的生活，对他讲过很多自己亲身经历的事情，跟他谈过很多自己内心真实的想法。袁河经常听的入神。</p><p>赵燕曾对他说，有很多东西，我从来都没有跟其他好朋友提起过。包括林依然。包括陆可凡。但是我却跟你说了，请你替我保守秘密，千万不要讲出去，好吗？袁河笑着点了点头。其实就算她不提醒，袁河也不会将这些告诉别人的。因为那份信任。赵燕每次讲述完毕都会说，我现在感觉轻松多了，如释重负。不过又浪费你时间了，真是对不起呀。袁河说，没关系啦。说完他们相视一笑，然后开始看书做题。彼此很有默契。</p><p>11</p><p>一般情况下，袁河与赵燕在一起聊天时，几乎没有人来打扰，所以他们通常都会聊得很完整，聊得很尽兴。可是有几次，两人刚聊到一半正高兴时，却被人硬生生给掐断了，简直非常郁闷，非常扫兴。而那人却偏偏正是赵燕的好朋友林依然。所以碍于情面，袁河只好忍住不发火。但是心里却非常的毛，无论做什么事情都不顺手，只有等情绪慢慢稳定后，一切才能恢复正常。</p><p>最初两次，袁河还能表示理解。毕竟林依然是赵燕的好朋友。但是后来就有些忍不住了。最后极力控制自己，才终于没有爆发。可心里却已经开始讨厌林依然，甚至都有些痛恨她了。我看这个女生真是一点涵养都没有。你为什么偏偏要在这个时候来找我的同桌啊？难道不能晚些吗？真是太扫兴了！事后想起刚才偏激的行为，袁河不禁暗骂自己心胸狭窄。因为这点小事，怎么可以如此讨厌和痛恨自己同桌的朋友呢？这样是不是太过分了？还好刚才没有把这些东西彻底表现出来，否则的话……不敢想象。</p><p>12</p><p>这天中午，袁河与赵燕把所有作业完成后，又闲着没事了。赵燕打了一个哈欠，转过头对袁河说，我有些困了，但却不想睡觉，你陪我聊聊天，行不行？</p><p>袁河笑着说，当然行了，我们是同桌关系，用得着这样客气吗？说吧，想聊些什么？我奉陪到底。</p><p>赵燕说，那就聊聊周杰伦吧。</p><p>袁河惊道，可是我对他知道的并不多，我只是听过他几首歌而已。怎么聊啊？</p><p>赵燕说，既然这样，那你就听我讲好了。</p><p>袁河耸耸肩，也只能这样。唉，看来我又要增长见识了。</p><p>两人刚聊到一半的时候，林依然走过来低声对赵燕说，我想跟你说件事，你可不可以出来一下？</p><p>赵燕说，当然可以了，我们是朋友嘛。说完看了看袁河，不好意思，我出去一下，马上回来再接着聊吧。袁河点了点头。</p><p>赵燕从教室外面走进来的时候，见袁河正一动不动地低着头，便走上前问，怎么？又为林依然打断话题感到不高兴了？真小气！</p><p>袁河抬起头说，我对此早已习惯了，哪有不高兴啊？我只是在思考一个问题而已。</p><p>赵燕眨了一下眼睛，思考什么问题呢？</p><p>袁河说，我发现林依然的性格和陆可凡差不多，都害羞内向，都不爱说话，都不愿交往，总是一直保持沉默，总是一直埋头不语。课间休息的时候，除了偶尔和你出去说说话外，几乎一直都待在教室里面，做自己的事情，好与世隔绝了一样。我记得在你和陆可凡成为朋友之前，你们就已经是朋友了。所以我在想，你和她又是怎么成为朋友的？唉，真伤脑筋啊。</p><p>赵燕低头一笑，你不会又要问我和林依然的交往过程吧。</p><p>袁河说，聪明！但你不要告诉我，因为你们都是女生。</p><p>赵燕看着袁河，如果我说就是这个原因呢？</p><p>袁河双手一摊，那就当我什么也没问好了。</p><p>赵燕做出一个“无法理解”的样子，你的好奇心为什么那么强啊？怎么什么都想知道？</p><p>袁河说，没办法，这些事情都发生在你身上，实在太不可思议了。我只是想了解一下其中的内幕，看看到底怎么回事。</p><p>袁河停顿了一下，然后抬头望了一下天花板，以开玩笑的口吻说，或许将来，我可以根据这些材料，编写一本书，名字就叫《如何与性格内向的人成为朋友》。你说如何？</p><p>赵燕白了他一眼，亏你想得出来。不过，你真想知道吗？</p><p>袁河说，废话，要不然我问你干吗？</p><p>赵燕笑了一下，其实我们之间的交往很简单，根本没啥可说的。不过既然你这么想知道，那我说说也无妨。</p><p>袁河抚摸了一下耳边的头发，自语道，奇怪，这样的对话为何如此耳熟？好像曾经在哪里出现过？</p><p>赵燕说，就在上次你问我与陆可凡的交往过程中出现过。看你什么记性！</p><p>袁河恍然大悟，哦，我想起来了，你现在开始讲吧。</p><p>13</p><p>记得高一刚开学那天，赵燕报完名，走进办公室一楼的大厅内，迅速浏览了一下张贴在墙壁上的教室分布图和寝室安排表，便开始根据学校发的地图，寻找商店和食堂。毕竟民以食为天，温饱最重要，先把这些问题解决了再说。至于自己在哪个班，通知书上早就写好了，到时只需对号入座即可。</p><p>赵燕找到商店和食堂后，看了一下环境和规模，感觉不错，心想高中就是不一样，简直比初中强多了。嗯，还算满意。</p><p>赵燕刚要离开，却忽然发现有个女生正坐在食堂的餐桌前，低着头伤心地哭泣。赵燕觉得非常奇怪，刚踏入新的学校，大家高兴还来不及，她怎么会坐在这里哭呢？是想家了吗？不会啊，今天才刚开学，哪有这么快就想家的道理？而且看样子也不像是在想家。那到底怎么回事？</p><p>赵燕走上前轻声问她怎么了？可是那个女生却没有回答，只是一直哭。</p><p>赵燕连着问了几遍，这位同学，你怎么了？那个女生才抬起头来。虽然已经停止了哭泣，但还是什么也没有说。</p><p>赵燕换了一种方式，请问你是哪个班的？</p><p>女生犹豫了一下，我是高一（4）班的。</p><p>赵燕激动地说，我也是那个班的。嗯，你住在几号寝室？</p><p>女生回答说，寝室安排表上写的是2栋410寝室。</p><p>赵燕听后显得更加激动了，原来我们住在同一个寝室。啊，太好了。那么，可以告诉我你叫什么名字吗？</p><p>女生说，我叫林依然。</p><p>赵燕把名字念了一遍，品味道，名字真好听。哎，对了，我叫赵燕。说完看着林依然，你刚才怎么了？为什么会坐在这里哭呢？是不是遇到什么麻烦了？</p><p>林依然起初不愿讲。赵燕说，我们既待在同一个班级，又住在同一个寝室，难道还有什么不好意思讲的吗？说出来吧，或许我还能为你做点什么。林依然低下头沉默了一会儿，觉得赵燕说的没错，在她面前确实没有必要遮掩什么，于是便把事情的原委全部跟赵燕说了。</p><p>原来林依然报完名，看过教室分布图和寝室安排表后，怀着与赵燕同样的心理，来到了食堂。等她观看完毕坐下休息时，才猛然发现，这两个月装在口袋中的生活费丢了，顿时吓得六神无主，当即哭了起来，一直哭到刚才赵燕出现。</p><p>赵燕问她，那你现在身上还有没有钱？</p><p>林依然回答说，一分也没有了，全部都掉光了。</p><p>赵燕问，那你为什么不跟家里说，而是坐在这里哭呢？</p><p>林依然说，我不敢跟家里说。如果父母知道我把钱弄丢了，他们会凶狠地打我的。</p><p>赵燕没有再继续问下去。她看着眼前有些可怜的林依然，同情心油然而生，当即从身上掏出一百元递给林依然说，这些钱你先拿去用吧，不必急着还，如果不够的话，你再跟我说，我会想办法的。</p><p>这些钱对林依然来说，无疑是雪中送炭，因此双手接过钱后，感动的又哭了起来。</p><p>赵燕拿出纸巾替她把眼泪擦干，然后说，如果你不嫌弃的话，我们做朋友怎么样？</p><p>林依然使劲地点了点头。大颗的眼泪又开始往下掉。</p><p>赵燕看见林依然哭泣的样子，突然有种想要拥抱她的感觉，于是张开了双臂。林依然见状也张开了双臂。然后两人紧紧地拥抱在了一起。很久很久都没有分开。</p><p>后来，她们就成为了最好的朋友。</p><p>14</p><p>袁河听完赵燕的讲述说，原来是这样啊。那她每次找你都是借钱用吗？</p><p>赵燕说，差不多吧。其实她父母每个月给她的生活费都很少，根本不够用的。那几次我们聊天刚进行到一半的时候，她来找我借钱，只是碰巧而已。至于私下都不知道借过多少回了。直到现在她还欠我五十呢。可是我却不想问她要了。就当是我资助她吧。虽然杯水车薪，但也总是我的一点心意。</p><p>袁河轻轻叹了一口气，唉，没想到是这样啊。</p><p>赵燕说，我知道你对林依然有些反感。那几次她来找我借钱，我从你的反应就看出来了。不过我想你可能是误会她了。其实她人挺好的。我不骗你。</p><p>袁河搓了搓手，看来以前我对她的了解还是不够啊，听你这么说，我真想跟她交往一下。</p><p>赵燕说，我觉得有这个必要。说不定将来你们还可以成为朋友呢。</p><p>袁河刚要讲什么，这时林依然又走过来低声对赵燕说，你可不可以，出来一下？</p><p>赵燕点点头便出去了。十分钟后才回来。眼睛红红的，好像哭过。</p><p>袁河问，她刚才不是已经找过你了吗？怎么又找啊？你眼睛怎么红了？你怎么了？</p><p>赵燕说，她第一找我是向我借钱的，我借给她了五十。而她这次找我是还我钱的，她还给我了一百。</p><p>袁河问，她怎么还你一百啊？</p><p>赵燕说，她之前还欠我五十呢。</p><p>袁河问，你刚才不是说不要那五十块钱了吗？</p><p>赵燕说，是啊，我原本是不想要的，但是她却非要坚持还给我，最后实在推脱不下就接住了。</p><p>袁河点了点头表示理解，可马上又问，她刚才还跟你借钱，现在怎么会有钱还你呢？</p><p>赵燕回答道，她说今天上午有个老乡来学校看望自己的孩子，于是她妈妈就让这个老乡顺便给她捎来了下个月一百五十块的生活费。她也是刚刚才收到的。然后就迫不及待地要还我钱。我说你先用吧，不用这么快还我。但是她却说，虽然我们是这么好的朋友，可我并不想无故接受你的馈赠，也不愿欠你任何东西，否则我会感到不安的，你还是收下吧，等这剩余的五十块用完了，我再向你借，好不好？说完用很纯真的眼神看着我。袁河你知道吗？我当时鼻尖一酸，差点就哭出来了。我接过钱说，那好吧，就这样，我先进去了。可是刚转过身，眼泪就拼命地往下掉。我是在外面等情绪稳定后才进来的。</p><p>赵燕说完从文具盒中拿出一块小镜子，开始看自己刚才哭红的眼睛。</p><p>就在赵燕拿镜子的时候，袁河看见在她文具盒中放有一支粉红色的钢笔，心想，那天赵燕把陆可凡的圆珠笔踩碎后，上课传递给陆可凡的应该就是这支笔吧。没想到这支笔竟使他们成为了朋友。真是不可思议。</p><p>赵燕对着镜子擦了一下眼睛，然后故作轻松地说，嗯，我好了，没事了。现在时间还这么早，我们再接着聊天。行不行？这次你来选话题。</p><p>袁河说，那就聊一下林依然吧。我现在对她非常好奇。</p><p>赵燕放下镜子，好呀。那我就跟你讲讲我们之间曾经发生的一些事情吧。</p><p>袁河做出一个“洗耳恭听”的动作，开始吧。</p><p>15</p><p>那天赵燕跟袁河讲了很多她与林依然之间曾经发生的事情。但是除了那两件事情，袁河现在基本上都已经想不起来了。到底是那两件事情让袁河记忆如此深刻难以忘怀？到底是那两件事情让他在很久之后回想起来都还觉得温暖？袁河低下头，嗯，让我好好想一下。于是他的思绪又回到了那天的谈话之中。</p><p>记得那天赵燕讲着讲着，忽然从课桌内拿出一双手套问袁河，你知道这双手套是谁送给我的吗？</p><p>袁河摇了摇头，我不知道。</p><p>赵燕说，是林依然一个月前送给我的。然后沉默了一下，接着说道，其实有很多人都不知道，我从来没有戴手套的习惯。从小到大，每年冬天，我都不戴手套，而且我的手也从来没有被冻肿过。虽然说今年冬天来得稍微有些早，而且比以往更加寒冷，但是我完全可以忍受。根本没有必要戴手套的。可是当我打开课桌看到躺在里面的手套时，我感动得差点落泪。你说朋友是不是就是在你感到寒冷时，给你送去温暖的那个人？那双手套我只戴了一天就把它取下来重新放进了包装袋中。我会好好珍藏那双手套，直到永远。</p><p>赵燕讲完这件事，眼中早已含满泪花。但是她却并没有用纸巾去擦，而是继续说，还有一件事情更加让我感动，你想听吗？</p><p>袁河点了点头表示想听。</p><p>赵燕这才拿出纸巾擦干眼泪，然后说，记得刚开学有段时间，我上火特别厉害，几乎每天早上洗脸都要流鼻血，吃完两盒三黄片竟然都不起效，林依然得知情况后，便步行走到县城的一家药店内给我买药。就是那种直接用开水冲服的中药。她听别人说喝生鸡蛋可以清火，便又到超市给我买了一斤生鸡蛋。你知道这些东西总共花了她多少钱吗？将近六十啊。可从我们学校到县城那么远的距离，她却舍不得花六块钱坐车，硬是步行来回。所以当她把这些东西放到我面前时，我当场感动得泪流满面一塌糊涂。我给她钱，可是她却不要。她说所有这一切都是她心甘情愿的，因为我是她最好的朋友，值得她这样为我做，让我不要再哭了。而且那几天，我水壶里面的水，也一直都是满的，都是林依然帮我打的。你说我能不哭吗？我觉得上高中能够和林依然成为朋友，是我今生最大的幸运和最大的快乐。希望我们之间的友谊能够一直延续到地老天荒。</p><p>不知道为什么，袁河听完最后这两句话，一下子就想到了陆可凡。他想自己跟陆可凡不也是这样的吗？</p><p>但愿所有人之间的友谊，都能够海枯石烂，地久天长！</p><p>16</p><p>一天下午放学后，赵燕从课桌内拿出一个天蓝色的笔记本，然后打开从里面取出一样东西让袁河看。袁河看后惊得差点跳起来。因为此刻赵燕手中拿的这样东西，居然就是那天自己坐在陆可凡的位子上，随手拿起一本书，刚准备翻阅，却忽然从里面掉下来的那个非常漂亮的蓝色纸飞机。</p><p>赵燕看着袁河脸上吃惊地表情问，你怎么了？</p><p>袁河这才回过神来，没什么。这个纸飞机是陆可凡送给你的？</p><p>赵燕扑哧一笑，亏你想的出来。现在哪有男生折纸飞机玩啊？告诉你吧。是林依然送给我的。</p><p>袁河感到莫名其妙，她为什么要送你纸飞机啊？</p><p>赵燕说，因为我是她的朋友呗。</p><p>她见袁河脸上满是困惑的表情，便故作神秘地说，你不知道吧，像这样的纸飞机呢，她只送给三种人。第一种就是她的朋友，第二种就是关心她的人，至于这第三种嘛，就是她喜欢的人。不过到目前为止，除了我之外，她好像还没有把纸飞机送给第二个人。你看，她在纸飞机折叠起来的部分还写着几行字呢。</p><p>袁河仔细看了一下，发现确实如此，跟那天在陆可凡位子上看到的那个纸飞机差不多。</p><p>赵燕问，你想不想知道，她在这里面写的什么内容？</p><p>袁河说，算了吧，这是你的隐私，我估计不方便知道。</p><p>赵燕说，我所有的隐私和秘密，你差不多全都知道了，难道还怕再多知道一点吗？</p><p>袁河做了一个无辜的表情，那是你主动要跟我讲的，又不是我逼你说的。你……</p><p>袁河还没说完，忽然发现赵燕正愤怒地看着自己，连忙投降说，我现在很想知道里面到底写的什么内容，你快讲吧。</p><p>赵燕这才露出笑容说，那我就告诉你吧。我刚才是假装生气的。</p><p>袁河发现自己上当了，不再理她，拿起饭盒，要去食堂吃饭。</p><p>赵燕说，现在食堂里面人很多，你去排不上队的。</p><p>袁河冷冷地看了她一眼，虽然排不上队，但总比在这儿上当受骗强吧。</p><p>赵燕说，我错了，好不好？我跟你说里面写的内容，好不好？你不要用那种眼神看着我，好不好？</p><p>袁河说，这还差不多。然后放下饭盒冲赵燕一笑，我刚才也是假装生气的。</p><p>赵燕把纸飞机拆开，只见上面写的是几句歌词：</p><p>赵燕，别管以后将如何结束，至少我们曾经相聚过，人的一生有许多回忆，只愿你的记忆中有我。希望你能永远记住我这个朋友。</p><p>袁河问，她一共送给你了几个纸飞机？</p><p>赵燕回答说，一共八个。</p><p>袁河问，那里面写的都是歌词吗？</p><p>赵燕白了他一眼，你认为这可能吗？八个纸飞机，只有这个里面写的是歌词，其他都不是。我告诉你吧，她对不同的人，会写不同的话。即使对同一个人，她写的话也不同。很少重复。而且像这样的纸飞机，她也只送给那三种人。所以你就没有。</p><p>其实袁河对于自己没有纸飞机，并不感到奇怪。</p><p>因为首先，自己不是林依然的朋友，甚至都没有跟她交往过；其次，自己也从来没有关心过她，甚至曾经还有些讨厌她；最主要的一点，自己不可能是她所喜欢的人，这完全没道理嘛。所以自己理所当然没有纸飞机了。</p><p>但让袁河感到诧异的是，陆可凡为什么会有纸飞机呢？他和自己的情况差不多呀？这也完全没理由嘛。难道是赵燕送给他的？</p><p>袁河本来想问赵燕陆可凡为什么会有纸飞机，是不是她送的。但是转念一想，这很正常啊，因为他们是朋友嘛，况且送个纸飞机又没有什么大不了的，所以最后就忍住没问。</p><p>赵燕把纸飞机折好，重新夹到那个天蓝色的笔记本中。然后问袁河，你知不知道这个笔记本是谁送给我的？</p><p>袁河说，我哪里清楚啊？难道又是林依然送给你的？</p><p>赵燕点点头说，嗯，是她送给我的。可你知道这个笔记本是用来干什么的吗？</p><p>袁河说，我怎么知道呢？不会是用来夹纸飞机的吧。</p><p>赵燕没好气地说，当然不是了。这个笔记本啊，是用来化解我们之间矛盾的。</p><p>袁河惊道，化解什么矛盾？你们不是很好的朋友吗？</p><p>赵燕说，你也许不知道吧，虽然我们之间的关系那么好，但有时也会闹些小矛盾的。每当这时，谁都不理谁。怎么办？那就在这个笔记本上写相互道歉的话，然后上课趁老师不注意传给对方，这样下课后，我们我们就又和好如初了。你说这个办法怎么样？</p><p>袁河做了一个佩服的表情，真是绝妙啊！</p><p>看着那个天蓝色的笔记本，袁河忽然想起了自己那个专门用来写字绘画的黑色笔记本。虽然里面记载的都是一些凌乱的文字和纷杂的图画，但却是两个人友情深厚的见证，是两个人最美好最珍贵的回忆。</p><p>袁河想，自己和陆可凡应该永远都不会忘记那个黑色的笔记本吧。而赵燕和林依然，则也会永远记住这个天蓝色的笔记本吧。</p><p>17</p><p>根据赵燕所讲的这些事情，基本上可以判定林依然是一个善良而又真诚的人。袁河想起以前自己对她的误解，以及对她的讨厌，不禁感到非常惭愧，不停地责怪自己实在太自私太过分了。</p><p>上次赵燕跟袁河讲完她与林依然之间的交往过程后，袁河就说过想要与林依然交往一下，但却一直没有机会。</p><p>后来当他听赵燕讲完更多与林依然有关的事情后，想要与之交往的念头便越来越强烈。强烈到让他无法控制的地步。但还是一直没有机会。没想到在星期二的那节体育课上，机会终于来了。他终于实现了这个一直都无法实现的愿望。</p><p>高一（4）班的课程表上写着，每个星期一的上午第四节，和星期二的下午第一节，是体育课。</p><p>虽然这个班每周都有两节体育课，但是通常情况下，大家上的只是星期二那节体育课。至于星期一那节课，则完全形同虚设。</p><p>因为周日的时候，大家完成自定的出行计划和活动安排后，都累得不行了，根本没有精力去上第二天的体育课。最主要的是，星期一那节体育课安排在上午第四节，同学们上完前三节课，就算已经放学了，谁还有心情去上什么体育课啊。所以星期一那节体育课就这样白费了。</p><p>有人抱怨说，到底谁安排的课程表啊？怎么如此没水平？还不如把体育课放在星期六的下午第三节算了，上完前两节就可以直接走人，这样多好啊，真是可惜了！</p><p>因为报销了一节体育课，所以另外那节课就显得尤其珍贵。每个星期二中午督学时间过后，大家都会急不可耐地朝操场上奔去。提前来上体育课。这样也算是对昨天那节课的一种安慰和补偿吧。</p><p>就连平时非常安静的人都到操场上去了。比如林依然。比如陆可凡。等等。</p><p>一般上星期二那节体育课的时候，袁河都会找人打乒乓球，或者羽毛球。如果找不到人的话，就走进校园书店里面看书，或者坐在篮球场边的石椅上，安静地看陆可凡打篮球。好像大致就是这样。</p><p>记得那个星期二上体育课的时候，袁河没有找到想打乒乓球和羽毛球的人，于是走进校园书店里面看书。看了十分钟，觉得没意思，便又走出书店，坐在篮球场边的石椅上，安静地看陆可凡打篮球。</p><p>每次看陆可凡打篮球的时候，袁河都会感到有些不可思议。因为篮球场上的陆可凡表现非常积极，显得特别活跃，简直与平时判若两人。很多次陆可凡把抢在手中的篮球投入蓝筐中后，都会流露出难得的喜悦，绽放出少有的笑容。</p><p>这让袁河隐隐觉得，活跃才是潜藏在陆可凡身体中最真实的一面。他想总有一天，陆可凡会变成一个活泼而又开朗的人。而那时，自己又会变成什么样子呢？</p><p>袁河正在思考自己将来会变成什么样子，这时肩膀忽然被人戳了一下，惊得差点从椅子上掉下来。抬头一看，只见赵燕正双手抱着一个篮球站在自己面前。</p><p>赵燕问，你在想什么呢？这么投入。</p><p>袁河往旁边挪了一下，拍拍椅子，示意赵燕坐下，没想什么。</p><p>赵燕说，我就不坐了。说着晃了晃手中的篮球，我看你也别坐了，起来活动活动，打打这个，怎么样？</p><p>袁河惊道，什么？打篮球？我不会啊。再说，只有我们两个人，怎么打？</p><p>赵燕反问道，谁说只有我们两个人了？说着指了一下站在远处的林依然，是三个人，还有她呢。嗯，她也不会打，可是，不会打可以学啊。如果实在不行的话，我来教你们，这样总可以了吧。</p><p>袁河更加吃惊地说，什么？你会打篮球？开玩笑吧。我怎么从来没有见你打过？真是太会吹牛了。我们班会打篮球的女生几乎没有。每次上体育课只会待在旁边踢毽跳绳聊八卦。你不也一样吗？</p><p>赵燕郑重地说，告诉你吧，我初中是学校女子篮球队的队长，怎么可能不会打篮球呢？只是进入高中后，发现班上没有女生打篮球，这才委屈自己和她们一样做那些事情。</p><p>袁河做出一个“晕倒”的动作，真是没想到啊，你居然是我们班的花木兰。然后摆出古代书生遇见客人后的姿势，在下这厢有礼了。</p><p>赵燕举起手中的篮球像要砸他的样子，少废话，你到底陪我们打不打？嗯，同桌，你可要想清楚了，如果你不答应的话，我会很生气，后果很严重。知不知道？说完忍不住扑哧一笑，我是不是很有才啊？</p><p>袁河点了点头，岂止很有才啊，简直相当有才。哎，那个，你会打篮球，怎么从来没有跟我提起过？</p><p>赵燕挥了一下手，我说出来你信吗？看你刚才那副吃惊的表情，好像遇见外星人了一样。再说，我现在不是已经告诉你了吗？</p><p>袁河看着赵燕手中的篮球说，既然以前你都忍住没打，怎么今天突然想打了呢？</p><p>赵燕假装生气地说，我今天突发奇想心血来潮，这样行了吧。我让你陪我和林依然打一下篮球，你罗嗦这么多。怎么？看不起我是不是？</p><p>袁河无辜地说，大姐啊，我怎么敢看不起你呢？万一出现严重的后果，那可怎么办啊？我陪你们打还不行吗？</p><p>赵燕说，这还差不多。跟我走吧。说完刚转过身就忍不住开始笑。</p><p>袁河想，看来我今天又要开阔视野了。</p><p>18</p><p>赵燕不愧是初中女子篮球队的队长，果然出手不凡，上来就投进一个空心三分球，把袁河与林依然看得瞠目结舌，无言以对。</p><p>赵燕捡起篮球说，既然你们都不会打，那就从最基本的投篮开始练起吧。嗯，女生优先，林依然，你先来吧。说完把篮球递给了林依然。</p><p>林依然不好意思地接过篮球，犹豫半天，最后在赵燕的鼓励下，才终于把球投了出去。结果用劲过小，篮球在空中划出一道优美的弧线后，直接落在了地上，连篮板都没有碰到。</p><p>林依然窘得站在那里直搓双手，不知如何是好。</p><p>篮球落在地上起初只是蹦跳着前进，后来索性就地翻滚。最后干脆沿着篮球场边倾斜的草坪飞速直下。然后只听“咕咚”一声，掉进了草坪前面的排水沟中，激起无数水花。看得三人心惊肉跳目瞪口呆。</p><p>赵燕最先反应过来。她拍了一下袁河的肩膀说，不好意思，麻烦你下去把篮球捞上来吧。</p><p>袁河说，什么？你看那水脏得简直不像话，难闻死了，怎么捞啊？我不下去。</p><p>赵燕说，难道你还要让我们女生下去吗？你一个男子汉大丈夫，怎么……</p><p>袁河不知道赵燕接下来要说什么，但肯定不会是什么好话，当即打断她说，我下去捞就是了，你不要再说了。</p><p>赵燕松了一口气，这还差不多。停顿了一下，还是把那句话说出来了，你一个男子汉大丈夫，怎么能那样没出息呢？</p><p>袁河一听差点气疯了，马上转身要回教室。</p><p>赵燕连忙说，你别走啊，你走了我们怎么办？我收回刚才那句话还不行吗？我求你了，好不好？</p><p>袁河这才没有离开。</p><p>袁河屏住呼吸走到排水沟边，只见整个篮球只有最上面巴掌大一块尚且干净，其他地方已经污秽不堪，并且还不停地上下浮动，这给他打捞工作造成了很大的困难。</p><p>袁河伸出两手的中指，慢慢从两边夹住篮球，轻轻向上提起，然后缓缓朝食堂旁边清洗餐具的水槽走去。</p><p>林依然跟在后边一直不停地抱歉，真是对不起啊，我不是故意的，请原谅我好吗？我真的不会打篮球，结果害得你……</p><p>袁河笑着说，没关系，我也不会打篮球啊。如果是我先投篮的话，估计也是这种情况，所以你不必自责的。</p><p>林依然说，但却是我把篮球弄到排水沟中的，真是……</p><p>袁河再次说，没关系了，无论是谁把篮球弄下去的，我都应该下去捡。因为我是男子汉大丈夫嘛。说完回过头，对着林依然灿烂一笑，这才发现赵燕没有跟上来。心想，等马上回到教室再找她算帐。我说过不会打篮球的，她却非要让我打，看把我害成什么样子了。哎呀，难闻死了……</p><p>林依然见袁河正对着自己笑，也不禁害羞地笑了。</p><p>袁河洗完篮球。二人边走边聊，非常开心。</p><p>刚回到操场上，下课铃就响了。袁河把篮球递给体育委员，回过头看了一眼正坐在篮球架下面休息的赵燕，做出一个“你可把我害惨了”的表情，然后便向教室走去，以迎接第二节课的到来。</p><p>赵燕和林依然在操场上说了几句话，然后也一起向教室走去。</p><p>第二节下课后，赵燕并没有像往常一样走出教室和其他女生聊天，而是反问袁河，你知道刚才上体育可课，我为什么要让你陪我和林依然打篮球吗？</p><p>袁河说，我还正想问你为什么呢？你不会就是想教我们打篮球吧。你闻一下，我现在身上都是排水沟的味道。你可真把我害惨了。你知道吗？</p><p>赵燕说，我也没想到会这样啊。嗯，对此我向你表示深深地道歉，对不起，这该行了吧。不过，你真不知道我为什么要让你打篮球吗？</p><p>袁河摇了摇头，我还真不知道。</p><p>赵燕说，我只是想通过这种方式，让你和林依然接触交往。你明白吗？</p><p>袁河一时没有反应过来，你说什么？</p><p>赵燕说，你以前不是说过想要和林依然交往吗？而我憋屈了那么久，实在很想打一下篮球。所以我就用这种自私的方法来帮你啊。否则你们这辈子都不会说一句话的。可你非但没有感激我，反而还那样责怪我。你真是太没有良心了。</p><p>袁河听后不禁意识到自己刚才有些过火了，连忙道歉，等赵燕情绪稳定后，这才激动地问道，你为什么要帮我啊？</p><p>赵燕说，免得你一直讨厌林依然。稍微停顿了一下，然后郑重地说道，因为林依然是我最好的朋友，所以我不希望任何自己熟悉的人对她心存误解。特别是你。</p><p>袁河感到非常冤枉，自从你跟我讲完那些与她有关的事情后，我对她的误解就已经彻底消除了。你为什么要这样说我？</p><p>赵燕看着袁河脸上郁闷的表情，觉得自己刚才有些言重了，忙后悔地说，对不起啊，我并不是对你有意见。而是因为太在乎林依然这个朋友了。所以才会这样说。因为以前你对林依然特别反感。我以为现在你对她还十分讨厌，所以……但我也是出于一片好心，因此……</p><p>袁河看到赵燕自责的样子，心里有些过意不去，没关系，我可以理解你的心情。谢谢！</p><p>19</p><p>自从上完那节体育课后，袁河与林依然之间的交往就越来越多。后来，他们就理所当然地成为了朋友。对于这一切，赵燕当然功不可没。</p><p>所以袁河为了感谢赵燕长久以来对自己无私的帮助，同时也为了庆祝自己和林依然能够成为朋友，便想请她们吃饭。</p><p>看到林依然后，袁河不禁想起了与之性格相似的陆可凡，印象中仿佛有很多天都没有跟他聚在一起了，于是叫上陆可凡。然后四个人就这么浩浩荡荡地出发了。</p><p>他们是在校园外面一家名叫“三回头”的小餐馆里面吃的饭。</p><p>在吃饭的过程中，陆可凡总是不停地和赵燕讲话。而林依然则一直沉默，不过目光却时不时会落在陆可凡身上。</p><p>但是袁河对此根本没有在意。</p><p>他只是感觉这里的饭菜确实不错，而且价格实惠，心想怪不得上次赵燕会请陆可凡在这里吃饭，原来如此啊。</p><p>20</p><p>通过这么长时间的交往，袁河发现林依然是个心地善良而又多愁善感的女生。一篇很平常的文章，一本很普通的小说，她都可以看的伤心欲绝；一件很细小的往事，一句很微妙的话语，她都可以想的泪流满面……就像林黛玉一样。</p><p>林依然表面上非常坚强，但是内心却比谁都脆弱。袁河知道像她这样的人，一般都特别容易受伤。可是她无论受到多么大的委屈，不管遭遇多么深的痛苦，全都自己担着，从来不对别人讲。袁河每次见她不开心走过去问她怎么了，她都低声说没事没事。她总是喜欢隐藏起自己一切的辛酸，掩饰住自己所有的悲伤，然后对每个人笑。笑容忧郁而又凄凉。</p><p>同赵燕一样，林依然特别喜欢与袁河坐在一起聊天。不过很多时候，都是林依然在不停地讲。袁河并非是因为插不上嘴，而是不忍心打断她的话。林依然跟袁河讲的最多的，就是自己悲惨的过去。</p><p>林依然说父母对她一直都不好，几乎从来都没有呵护过自己。她从小到大从来没有得到过父母的表扬。哪怕一次也没有。无论每次考试排名第几，父母都漠不关心。即便自己考试全班第一名，父母也只是沉着脸对她说不要骄傲。父母对她非常克扣，从来没有给过她任何零花钱。如果自己犯了错误，就会遭到父母凶狠地打骂。简直难以忍受。除了父母外，爷爷奶奶对她也非常苛求。总是看她不顺眼。稍有不对就厉声斥责。有时候，她觉得自己就像个丑小鸭一样，走到哪里都受人嘲笑欺侮。但是丑小鸭最后却变成了美丽的白天鹅。而自己将来会变成什么样子呢？</p><p>林依然低声道，说不定我就这样窝囊地过完此生，然后死去。没有人会记得，曾经有个叫林依然的女孩，在这个世上卑微地生活过。没有人知道……</p><p>每次讲到最后，林依然都会泪流满面。</p><p>袁河很想安慰她，可是却不知道应该怎么做，只能手足无措地站在旁边，任她哭泣。只有在事后才会说很多真心实意的话来关心她，做很多力所能及的事去帮助她。一直如此。</p><p>不知道为什么，只要看见林依然，袁河就会生出一种想要保护他的念头。</p><p>也许是因为她太弱小了吧，使自己忍不住想要赐予她力量，令她变得强大起来。真的。袁河想要保护林依然，让她从此以后再也不受任何伤害。他希望瞧见林依然快乐而又甜美的笑容，却不想看到她悲伤而又难过的眼泪。如果能让林依然每天都快乐无忧的话，他愿意去承担所有的痛苦和辛酸。</p><p>后来这样的念头越来越强烈。强烈到想要永远做她的守护神。一生一世都不离开。</p><p>袁河搞不清楚自己到底怎么回事，反正闲暇之余，脑海中全都是林依然孤单的身影，和忧伤的表情。怎么也挥之不去。都有点魂不守舍了。</p><p>袁河想，我以前从来不会这样的，我现在到底是怎么了？难道是喜欢上她了？一副困惑不解的样子。</p><p>21</p><p>自从那节体育课，赵燕曝光自己会打篮球的身份后，几乎每个星期二的体育课，她都要去打。</p><p>虽然无法和女生一起打篮球，但是可以和男生一起打啊。当然她不会主动加入其中的，否则就显得太粗野，没修养。毕竟自己是女生呐，要矜持一点，稳重一点，不能像男生那样，大大咧咧的。要不然影响多不好啊。</p><p>所以只有等男生过来邀请她后，才会去打一下篮球。</p><p>不知道为什么，差不多每次都是陆可凡去邀请她一起打篮球。真让人费解。</p><p>如果赵燕答应的话，那么陆可凡就会显得特别兴奋；如果赵燕拒绝的话，那么陆可凡就会感到非常失望。</p><p>除此以外，在比赛前，陆可凡总是要把自己和赵燕分在同组。如果没有的话，那么他就会请求调整队员，或者重新分组。别人都觉得陆可凡有些无理取闹，但是碍于情面，不好说什么，只能同意这么做。</p><p>而在比赛的过程中，如果赵燕表现良好的话，那么陆可凡就会露出赞赏的表情；若是赵燕发挥失误的话，那么陆可凡就会投出鼓励的目光。</p><p>袁河与林依然坐在篮球场边的石椅上，对此都感到有些诧异。特别是林依然，每当看到陆可凡那样做，都会脸红，并且迅速低下头，仿佛有些于心不忍的样子。</p><p>后来有一次，袁河见状问她怎么了。她低声说没事没事。可是眼泪却已经流了下来。袁河顿时手足无措，只能等她慢慢平静下来后，才开始安慰她。</p><p>22</p><p>这天下午上第三节课的时候，袁河正在抄写板书，手臂忽然被人点了一下，抬起头，只见赵燕已经把一个蓝色的纸飞机放到了自己的课桌上。</p><p>袁河问，这是林依然送给你的，你送给我干吗？</p><p>赵燕调皮地说，才不是呢。这个纸飞机是林依然送给你的。我只是负责传递而已。</p><p>袁河疑惑地问，她送给我的？为什么啊？</p><p>赵燕说，因为你现在是她的朋友嘛，她当然要送给你了。真是的，连这都不懂。</p><p>袁河拾起课桌上的纸飞机，左看右看爱不释手。</p><p>赵燕提醒说，你难道不想看看她在里面给你写的什么话吗？</p><p>袁河恍然大悟似地点了点头，你不说我还差点忘了。</p><p>袁河小心翼翼地拆开纸飞机，只见上面写道：</p><p>谢谢你的帮助，谢谢你的关心，谢谢你的安慰，谢谢你的宽容。</p><p>上高中能够遇到像你这样待人真诚而又善于倾听的人，是我今生最大的幸运，也是我今生最大的快乐。自从我们交往以来，你总是那样默默地关心我。那样静静地照顾我。对此我真的很感动，也很幸福。谢谢！</p><p>应该说我只是你人生中的一个过客，或者说我们彼此互为对方生命中的点缀。如果有一天我们分开了，请你一定要忘记我。</p><p>袁河看到前面那些话时，心里一阵温暖，可是看着看着脸色就有些变了。</p><p>他指着最后那两句话问赵燕是什么意思。赵燕摇摇头说不知道。</p><p>后来袁河又陆续收到了几个林依然送给他的纸飞机。里面写的内容各不相同，但是末尾却都是那两句话。从来没有变过。</p><p>袁河以为那是林依然的习惯，所以就不再胡思乱想了。只是每次把里面写的内容看完后，重新折好，然后夹进自己那个专门用来写字绘画的黑色笔记本中，以作收藏。</p><p>有时候，袁河觉得，林依然就像个飞在风里的纸飞机一样。那么柔弱，那么无助。没有依靠，没有归宿。一直飘曳，一直摇晃。仿佛随时都要掉下来的样子。</p><p>袁河可以感觉出来，她身上正背负着太多沉重的东西。那些东西压得她几乎虚脱，但是却不能停下来休息。因为一旦停下来的话，也许永远就无法再回到天空中了。</p><p>所以她必须要迎着风，一直艰难地飞行。一直飞行。一直。飞行。</p><p>袁河很想替她承受这一切，但是却无能为力。只好在心里默默地为她祈祷，深深地为她祝福，希望她能够健康快乐，一生平安！</p><p>23</p><p>现在星期二上体育课的时候，袁河很少再找人打羽毛球或者乒乓球了。至于校园书店，他也已经很久没有进去看过书了。那他上体育课的时候都在干吗？他在陪林依然。</p><p>自从那次观看赵燕和陆可凡打篮球，林依然低头哭过后，他们就再也没有坐在石椅上观看过篮球比赛了。</p><p>林依然喜欢安静地坐在草坪上，认真盘算自己的心事，袁河就坐在旁边陪伴她。虽然草坪前面是排水沟，但是他们所坐的位置绝佳，根本闻不到任何刺鼻的气味，挺好的。</p><p>有一次上体育课，袁河正坐在草坪上思考一个问题。林依然突然问他，陆可凡这个人怎么样？</p><p>袁河一时没听清楚，你说什么？</p><p>林依然低下头有些不好意思地说，我问你……陆可凡这个人怎么样？</p><p>袁河说，他人很好啊。要不然我们怎么会成为朋友呢？</p><p>林依然说，可是我到现在还没有跟他说过话呢，所以对他一点都不了解。你……可不可以跟我讲讲他？</p><p>袁河说，当然可以了。</p><p>直到快下课的时候，袁河才基本讲完。</p><p>林依然说，哦，原来是这样啊。我还以为他是一个清高而又孤傲的人呢。</p><p>袁河说，很多没有和他接触过的人都这样认为。但他不是的。</p><p>林依然点点头，嗯，我差不多有点了解他了。哎，我在问你话之前，你在想什么呢？那么专注，那么投入。</p><p>袁河说，我在想，上次观看赵燕和陆可凡打篮球，你为什么突然会哭？而且从那以后，我发现你和赵燕都很少交往了。能告诉我其中的原因吗？</p><p>林依然低头不语。</p><p>袁河问，你们又闹矛盾了？为什么不在那个天蓝色的笔记本上面写相互道歉的话，来消除矛盾呢？</p><p>林依然低声说，有些矛盾，并不是通过道歉，就能够化解消除的。</p><p>袁河问，那么我可以为你们做些什么吗？</p><p>林依然说，不可以。</p><p>袁河问，为什么？</p><p>林依然说，不为什么。</p><p>袁河问，你不信任我？</p><p>林依然说，不是。</p><p>袁河问，那你可不可以告诉我，你们之间到底有什么矛盾？</p><p>林依然说，不可以。</p><p>袁河问，为什么？</p><p>林依然说，不为什么。</p><p>袁河急得都快要哭出来了。这时下课铃响了。林依然说，我先回教室了。说完起身走开。</p><p>袁河看着林依然的背影，脸上满是痛苦。</p><p>这到底是为什么啊？</p><p>24</p><p>在后来的一节体育课上，赵燕因为腾空投篮的时候，被对方球员撞了一下，结果摔到地上，划破了手臂。</p><p>当时陆可凡都吓慌了，几秒钟后才反应过来，连忙上前扶起赵燕，朝医务室走去。</p><p>袁河见陆可凡眼中满是心疼，有些困惑，不就是划破了手臂，至于这样吗？太夸张了吧。谁没受过伤啊。回过头刚要跟林依然说这些，却见她早已泪流满面，更加诧异，虽说朋友受伤了，但不至于哭成这样吧。跟陆可凡一样。也太夸张了。</p><p>袁河对林依然说，看你哭成这样，是不是已经与赵燕私下和好了？嗯，这样才对嘛。走，让我们去医务室查访一下她的伤势情况，看看你到底有没有必要哭成这样。</p><p>林依然低声说，我不去。要去你去。我先回教室了。然后转身离开。</p><p>袁河感到非常不解，都是怎么搞的？想不通！</p><p>赵燕在医务室通过简单包扎后，便要返回教室。</p><p>陆可凡关切地问，你伤成这样，要不要请假休息几天？</p><p>赵燕笑着说，就这点小伤，还需要请假休息吗？没有必要吧。</p><p>陆可凡急道，谁说没有必要？万一伤口感染了怎么办？你放心，我会帮你补习的。</p><p>赵燕说，算了吧。我是不会请假的。哎，是不是快要上课了？走，一起回教室吧。</p><p>陆可凡还想说些什么，但是看到赵燕脸上坚定的表情便忍住了，只是附和道，好，走，回教室。</p><p>在赵燕伤口愈合的那些日子里，陆可凡三天两头跑过来嘘寒问暖的。但是林依然却没来看过赵燕一次。</p><p>这让袁河感到非常纳闷，同是赵燕的朋友，反差怎么这样大呢？林依然不是与赵燕已经私下和好了吗？怎么还那样陌生啊？难道又闹新矛盾了？而且看样子，这次关系好像更加恶化了。她们到底怎么回事呀？我想不明白，又没人跟我说，到底什么意思啊？真是……</p><p>25</p><p>有一天上课的时候，袁河发现赵燕的脸色很难看，便问，怎么了？你生病了？</p><p>赵燕说，没有。</p><p>袁河问，那你脸色为什么这样难看？</p><p>赵燕低下头说，林依然再也不理我了，她再也不和我做朋友了，她再也……话没说完，已经泣不成声。</p><p>袁河顿时慌得手足无措，完全不知道应该怎么办，只是一直不停地跺脚。</p><p>对于多愁善感的林依然，遇到这种突发情况，袁河尚且不知如何去安慰人家。那么对于自己的同桌赵燕，那就更不知道应该如何去安慰了。</p><p>因为自从做同桌以来，赵燕一直没有哭过，每天都笑容满面的，也不知道从哪里来那么多开心的事情。陆可凡曾经对袁河说，要是我能像赵燕那样笑口常开的话，那我就是天下最快乐的人了。袁河浅笑一下，无论谁像她那样，都会感到快乐的。不是吗？陆可凡点了点头。</p><p>可就是这样一个活泼开朗每天都笑容满面的女生，现在却哭得那样伤心。简直前所未有。袁河看得整个人都傻掉了。</p><p>等赵燕好不容易止住哭泣，袁河才轻声问道，她为什么不再理你了？</p><p>赵燕低声说，我不知道。反正自从我打篮球以后，她就再也没有跟我讲过话了。说完又开始哭了起来。</p><p>不知道为什么，只要看到有人流泪，袁河心里就会特别难受，几乎都要跟着一起哭了。所以现在袁河的脸色，甚至比赵燕还要难看。他只是轻轻地拍了一下赵燕的肩膀，以示安慰。然后转过头，也忍不住开始掉泪。</p><p>因为他们动作很轻，声音很小，课桌上面堆砌很高的书本挡住了别人的视线，而且他们一直都低着头。所以对于这里正在发生的一切，老师和同学们都没有发现。</p><p>后来上课的时候，赵燕总是会拿出林依然曾经送给她的那些蓝色纸飞机，和那个天蓝色的笔记本，一遍又一遍地看，一直看到泪流满面伤心欲绝为止。</p><p>袁河见同桌这个样子，简直心都碎了。不知道为什么，他忽然想起了很多关于赵燕平时的言行：她看完郭敬明的《梦里花落知多少》后一直自问，这个世上有没有像顾小北和陆叙那样好的人？我将来可要找一个像陆叙那样的伴侣；她做不到物理题时喜欢胡思乱想，如果我比爱因斯坦还要聪明的话，那就好了；她有时会对着镜子或者照片看半天，然后自恋地说，我长的也挺漂亮的呀；她特别崇拜周杰伦，不仅在课桌上贴满了他的图片，而且还到处宣扬以后要去看他开的演唱会；她在看书时碰到个别经典笑话会马上拿过来让袁河看，一边前俯后仰一边问，好笑吗？……</p><p>袁河想得鼻子都发酸了。一切怎么会变成现在这个样子啊？以前那个活泼开朗的赵燕到哪里去了？以前那个笑口常开的赵燕到哪里去了？以前那个快乐无忧的赵燕到哪里去了？以前那个一上体育课就在篮球场上挥汗如雨的赵燕到哪里去了？以前那么多那么多阳光可爱的赵燕，她们都到哪里去了？谁能告诉我啊？想到这里，眼泪终于还是掉了下来。</p><p>26</p><p>那天中午吃完饭回到教室，袁河看见赵燕正趴在课桌上不停地抽噎，心一下子又开始疼了。回到座位上，袁河拍拍赵燕的肩膀，你又看林依然送给你的那些东西了？</p><p>赵燕抬起头来，两只眼睛早已哭红了，没有。</p><p>袁河难过地问，那你为什么又哭得这样伤心？</p><p>赵燕说，你知道吗？我和林依然曾经是那么好的朋友，但却没有想到，有一天，我们会形同陌路到擦肩而过都不看彼此一眼的地步。就在刚才，我和她在教室外面走廊上相遇的时候，她居然都没有看我一眼，而是直接把头扭到一边，然后侧身从我身边走过去了。对此，我真的感到非常寒心，所以……话没说完，又开始哭了起来，而且比刚才更加伤心。</p><p>袁河看到赵燕现在这个样子，心想，看来我无论如何都要找林依然好好谈一下，看看她们之间到底有什么样的矛盾和误会。虽然那次上体育课的时候，她始终不肯告诉我。但是这次，我必须要弄清这些问题。希望我可以化解她们之间的矛盾，消除她们之间的误会，让她们重新和好。也只有这样，我的心里才会好受一些。</p><p>袁河走到林依然的位子前，低声说，有些事，我想好好和你谈谈。可以出来一下吗？</p><p>林依然见袁河走进教室与赵燕说了几句就来找自己谈话，便已猜到，他想和自己谈论的事情，就是那次体育课上，他问自己的那些问题。到底出不出去？虽然上次，自己始终没有给他答案。但是现在，好像不应该再向他隐瞒了。还是跟他说了吧。这样自己也许就彻底解脱了。这样自己也许就完全轻松了。这样自己也许就不会再承担那么大的痛苦了。这样自己也许就不会再承受那么大的煎熬了。</p><p>林依然稍微犹豫了一下，便点点头答应了，我们到哪里去谈呢？</p><p>袁河说，就在篮球场边的草坪上，行不行？</p><p>林依然说，好吧。</p><p>27</p><p>两人走到草坪上坐下后，袁河还没有来得及开口问林依然，她和赵燕之间到底有什么样的矛盾和误会。却被林依然反问道，说实话，你是不是喜欢我？</p><p>袁河说天也没有想到林依然上来会问自己这个问题，一时不知如何才好，红着脸低下头，一直不停地搓手。过了很长时间，才抬起头轻声说，我确实有点喜欢你。说完不好意思地看向别处。</p><p>林依然说，可我并不喜欢你。我真正喜欢的人是陆可凡。我们只能做朋友。你明白吗？</p><p>这句话对袁河来说，无疑是晴天霹雳。岂止啊。简直是五雷轰顶。袁河全身顿时凉透了。心里感到一阵酸楚。难受得要命。</p><p>袁河看过小说，看过电视，看过电影。他知道那里面的女主角，对于自己不喜欢的人，通常都会以委婉的话语，或体面的方式予以拒绝。那样自己不会太尴尬，对方也不会太难过。彼此都不会太痛苦。</p><p>但是他却没有想到，自己平生第一个喜欢的人，居然会这样直接地询问自己，然后再这样生硬地拒绝自己。真是太残忍了！林依然，你为什么要这样拒绝我？你为什么要这样伤害我？你为什么要这样打击我？袁河觉得自己都快要崩溃了。</p><p>袁河抬头望了一下天空，觉得太阳特别刺眼，泪水都快要流出来了，为什么？</p><p>林依然说，因为我们不合适。记得在我们交往之前，你不是一直都非常讨厌我吗？有几次我去问赵燕借钱，无意中打断了你们的聊天，于是你脸上就满是怒气，好像很反感我的样子。你知道那时我心里有多难受吗？你不会知道的。也没有人会知道。真的。我平时一直沉默不语，一直忍气吞声，却没想到还是会招人反感，惹人讨厌。你说我活得是不是很失败啊？有时候，我简直想一死了之，但却做不到。你说我是不是很没出息啊？</p><p>袁河听到这里已经彻底没有知觉了，脸上满是泪水，是我活得失败，是我没有出息……</p><p>林依然像是没有听见袁河的话，继续道，后来赵燕告诉我，你想和我交往。你知道我当时听后是什么反应吗？</p><p>袁河摇了摇头，不知道。</p><p>林依然说，我当时觉得你真虚伪。既然你那么讨厌我，为什么还想和我交往呢？所以我在心里特别抵触你。但是碍于情面，我还是答应了。你还记得那天，我们第一次打篮球吗？那是赵燕用心安排的，就为了消除以前你对我的误解。她希望我们可以成为朋友。我当时觉得完全没有必要这样做。我有赵燕这个朋友，就已经足够了，为什么还要千方百计和讨厌自己的人成为朋友呢？但是看到赵燕脸上期望的表情，我什么也没说就答应了。</p><p>林依然说到这里看了一眼袁河，继续道，可我真的不会打篮球，所以第一个就把篮球投进了前面这个排水沟中。当时赵燕让你下去捡，但是你却不愿意。最后在赵燕的哀求下，你才下去把篮球捡了上来。我们一起去清洗篮球的时候，你说“无论是谁把篮球弄下去的，我都应该下去捡。因为我是男子汉大丈夫嘛”。虽然表面上我一直都在和你说笑，但是心里却在想，你还是那么虚伪，这样的话你怎么说得出口。不过我什么都没有表现出来。因为我怕你会伤心。但是我去问赵燕借钱的时候，你为什么要把对我的讨厌表现得那么明显？你有没有想过我会不会伤心啊？</p><p>袁河木然道，是，我虚伪，谢谢你的好意，我心领了。</p><p>林依然没有理会，接着说，我们洗完篮球就下课了。当时你直接就回教室去了。我和赵燕在操场上说了几句话，才向教室走去。你知道我们在一起说的什么吗？</p><p>袁河低沉地说，不知道。</p><p>林依然说，我对赵燕讲，我不想再跟你交往了，因为我们根本不适合做朋友。她说，其实袁河这人挺好的，如果你们不能成为朋友的话，那就太可惜了。最后在赵燕的劝说下，我才没有和你绝交。没想到现在，我们还真的成为了朋友。</p><p>袁河黯然道，那你现在，是不是，特别后悔，和我成为朋友啊？</p><p>林依然说，你还记得我在送给你的第一个纸飞机里面，写的什么吗？我写道，上高中能够遇到像你这样待人真诚而又善于倾听的人，是我今生最大的幸运，也是我今生最大的快乐。这句话说真的。自从和你成为朋友后，我才慢慢地发现，你这人确实挺不错的，待人真诚，善于倾听，一点都不虚伪。后来你一直那样默默地关心我，静静地照顾我。这让我特别感动。但是这并不能完全消除我们之间的隔膜。因为你曾经那样强烈地讨厌过我。当时你脸上那种愤怒的表情，我永远都忘不了。没办法。对于那些伤害我自尊的东西，我真的忘不了。但是同样的，我也会永远记住你对我的好。其实我早就知道你喜欢我。从你那关切的眼神，我就看出来了。但是……我们只能做朋友。因为我真正喜欢的人是陆可凡。</p><p>28</p><p>袁河悲伤地问，那你从什么时候起，开始喜欢陆可凡的？</p><p>过了很久，林依然才回答道，赵燕曾对我说，她跟你讲过她和陆可凡之间的交往过程。那么你应该还记得，赵燕把陆可凡的圆珠笔踩碎后，为了表示歉意，第二天中午请陆可凡吃了一顿饭。当时我也在场。虽然那天中午吃饭的时候，我自始至终都没有说一句话，但是我却注意到了陆可凡。不知道为什么，看到他，我总是感觉特别亲切，就像见到了某个阔别已久的朋友一样。而且在他身上，我隐约可以看见自己的影子。你说，遇到一个和自己性格相似的人，这算不算缘分？</p><p>袁河忽然想起刚开学的时候，有人曾说他与陆可凡长得有些像。</p><p>也许，这只是别人随口讲的一个笑话，但是，他却认为这是缘分，所以后来，他才会费尽心机，想要和陆可凡接触交往，直到最终成为朋友。</p><p>想到这里，袁河无力的点点头，应该算吧。</p><p>　　林依然说，嗯，我也是这样认为的。所以后来我就彻底喜欢上了他。我听别人说，他是一个清高孤傲而又狂妄自大的人。但是我却不信。所以在那节体育课上，我才会向你打听与陆可凡有关的事情。嗯，他果然不是那样的人。</p><p>　　袁河听到这里已经彻底死心了。原来她真正喜欢的人是陆可凡。原来从开始到现在，一直都是我自作多情。我真是太……</p><p>袁河忽然想起那天坐在陆可凡的位子上看到的那个纸飞机，心想，我还一直以为那个纸飞机是赵燕送给他的，直到现在方才明白，原来是林依然送给他的。我真是太笨了。</p><p>29</p><p>　　提到赵燕，袁河忽然想起来，自己今天来找林依然，并不是为了听她说这些打击人的话，而是为了弄清她与赵燕之间到底有什么样的误会，是为了化解她们之间矛盾的。于是努力让自己镇静下来，不再去想那些令人伤心难过失魂落魄的东西。</p><p>　　等自己情绪彻底稳定后，袁河才问林依然，那么你和赵燕之间到底怎么回事？</p><p>　　林依然反问道，你知道我为什么观看赵燕和陆可凡打篮球时会哭吗？你知道我为什么从此以后再也不看他们打篮球了吗？你知道上次赵燕受伤后，我为什么一直没有去看她吗？</p><p>　　袁河说，不知道。</p><p>　　林依然说，因为我喜欢陆可凡。</p><p>　　袁河困惑地问，这与那些事情有什么关系吗?</p><p>　　林依然说，有关系。因为我喜欢陆可凡，所以我见不得他对别的女生好，同样的，我也见不得别的女生对他好。如果陆可凡对哪个女生好，那么，我就会讨厌那个女生，怨恨那个女生，并且从次以后，再也不去理睬那个女生。即便是自己最好的朋友，也不例外。因为我实在无法容忍自己的朋友对自己不忠。</p><p>袁河问，可是，你怎么能这样对待赵燕呢？你怎么能这样绝情呢？无论如何，她毕竟是你最好的朋友啊。</p><p>袁河刚说完这句话，林依然就哭了起来。哭得很悲痛。哭得很伤心。边哭边说，你以为我想这样吗？我不想的。可是，每当看见陆可凡与赵燕在自己面前那样亲密。我心里真的很难受。真的很难受。就像被人砍了几刀一样，痛彻心扉。所以观看他们打篮球时，我才会忍不住突然哭出来。那种撕心裂肺般的感觉，你是不会明白的。如果是别的什么东西，我会毫不犹豫地让给赵燕。但是惟独陆可凡不行。因为陆可凡是我从小到大，遇到的第一个真正喜欢的人。我真的非常在乎他，珍惜他。可是，他为什么要对赵燕那样好？他为什么要那样关心赵燕？害得我现在与朋友反目成仇形同陌路。我不想这样的，我不想的，我不……</p><p>话还没有说完，早已哭得不成样子了。这是袁河到目前为止见过的，她哭得最厉害的一次。全身剧烈的抖动。仿佛这么多年来所有的积怨和委屈，全都在这一刻倾泻出来了。</p><p>袁河此时非常理解林依然的心情。对于之前她跟自己说的那些话，袁河早已抛于脑后了。他拍拍林依然的肩膀说，哭吧，哭出来吧。这样也许会好受些。说完用手揩干自己脸上的泪水，心里一阵难过。</p><p>30</p><p>后来有一次上体育课的时候，陆可凡与赵燕都没有去打篮球，而是并肩坐在草坪上聊天。</p><p>对于这种反常的举动。袁河百思不得其解。</p><p>他看到陆可凡的脸上，刚开始堆满了笑容和喜悦，但是后来却布满了痛苦和失望。</p><p>而赵燕则一直显得特别沉重。</p><p>好像从那以后，他们就再也没有聚在一起打过篮球了。</p><p>袁河当时见他们都不太高兴，所以也没好意思问他们怎么了。</p><p>后来，他就把这件事情给忘了。</p><p>31</p><p>距离高二上学期结束还有一个月的时候，学校组织放映了一场电影。赵燕想让袁河陪自己看电影，但是袁河却没有去。</p><p>因为首先天气比较寒冷。其次袁河并不喜欢人特别多的地方。最主要的是，那部电影他在很早之前就已经看过了，所以就坐在教室里面看书。赵燕感到无聊，只好也坐下来看书。</p><p>至于陆可凡和林依然，却不知去了哪里。</p><p>袁河看见他们是一起出去的。他们会去哪里呢？</p><p>袁河想，他们肯定不会去看电影的。因为他们都是喜欢安静的人，怎么会去那样吵闹的地方呢？那么，他们到底会去哪里呢？算了，管他呢，还是看书吧。</p><p>32</p><p>不知过了多久，陆可凡从外面回到教室对袁河说，我们出去走走吧。</p><p>　　袁河见他愁绪萦怀的样子，便点点头答应了。</p><p>其实他们出去后并没有到处走动，而是直接走进教学楼左边那片小树林中，然后在一块平地上坐了下来。</p><p>　　陆可凡说，我到商店去买瓶啤酒吧。我现在特别想喝酒。</p><p>袁河说，你有没有搞错？这么冷的天你喝啤酒？但是看到他脸上忧伤的表情，便改口说，好吧，买两瓶，我陪你喝。</p><p>　　陆可凡一口气喝掉半瓶啤酒，然后打着嗝说，你知道林依然刚才找我干什么吗？你知道林依然刚才跟我说什么吗？</p><p>　　袁河说，我哪里知道啊。</p><p>陆可凡冷笑了一下，她居然让我陪她去看电影。她居然跟我说她喜欢我，还问我喜欢不喜欢她？真是好笑啊。</p><p>陆可凡说着又冷笑了几声，我从来没见过，哪有女生会这样直接而生硬地问人家喜不喜欢她的？再说，我从来都没有跟她说过话，也从来没有跟她交往过，怎么会平白无故去喜欢她？你想想……怎么可能的事情？</p><p>陆可凡喝了一口啤酒，接着说道，所以我就告诉她。我不想去看什么电影，我也不喜欢过你。可是我话还没有说完，她就开始哭，哭得那是惊天动地翻江倒海啊。我当时正感到莫名其妙，忽然走过来两个男生，指着我破口大骂，你一个男生，居然欺负女生，真是太不像话了。说完就要揍我。我吓得落荒而逃。我在教室外面越想越气闷，所以就来找你喝酒了。真没想到那么文静的一个女生，居然会与别人串通好来整我。你说，我到底哪里得罪她了？大家有话好好说嘛，用得着这样吗？你说，用得着吗？说完将剩余的啤酒一饮而尽。</p><p>　　袁河说，林依然不是那样的人。她是真心喜欢你的。也许，她今晚是想要跟你表白的。却没想到……</p><p>　　陆可凡气愤地说，少来这套，你是她的朋友，当然会替她说话了。</p><p>　　袁河说，不是这样的。你听我讲啊。</p><p>然后便把那天林依然对自己说的话，全都讲给陆可凡听了。</p><p>　　陆可凡听后半信半疑，这是真的吗？真是这样的吗？你敢确定吗？不会骗我吧？有没有……</p><p>　　袁河打断他的话，你怎么婆婆妈妈的，到底要怎样你才相信啊？我告诉你，林依然是个很好的女孩，她是真心喜欢你的。至于刚才发生的事情，我看完全是一场误会。你不要放在心上。她绝对不会请人那样做的。我觉得你应该接受她……</p><p>袁河还没有说完，陆可凡就打断他说，就算那是一场误会。可是我对她一点感觉都没有，你让我怎么接受她啊？说的倒轻松。我也告诉你吧。我真正喜欢的人是赵燕。既然她跟你说过我们之间的交往过程，那么你就应该记得，其中有这样一个细节，就是，她将我的圆珠笔踩碎后，上课主动将她自己的钢笔传给我使用。可以说，就从那个时候起，我便彻底喜欢上了她。你知道为什么吗？</p><p>袁河说，我怎么知道啊。</p><p>陆可凡说，因为我非常喜欢转笔，但是水平不高，所以经常会把笔转到地上，为此别人都不知道踩坏我多少笔了。但是却没有一个人像赵燕那样，上课主动把笔传给我用。所以当时我特别感动。没想到我们班上还有这样善良的女孩。因此对她特有好感。你知道，我从来不和女生说话，也从来不和女生交往，但是在她面前，我却破例了。你知道为什么吗？</p><p>袁河又回答道，我怎么知道啊。</p><p>陆可凡说，因为我喜欢她。就这么简单。后来我收到了很多非常漂亮的蓝色纸飞机，每个纸飞机里面都写着几句话，写的都是喜欢我的话。而且末尾全都没有署名。开始我并不知道是谁送的。不过有一次，我给赵燕讲题的时候，无意中在她的课桌上，看到了两个这样的纸飞机，当时就想，原来那些纸飞机都是她送给我的呀。原来她也喜欢我啊。你知道我当时心里有多高兴吗？</p><p>袁河摇了摇头。</p><p>陆可凡说，我当时就像在腾云驾雾一样，觉得特别舒服，都有些忘形了。后来当我得知她会打篮球后，便经常邀请她和我们一起打。那些日子，我总是感觉特别快乐，特别充实。活力四射。前所未有。</p><p>陆可凡讲到这里看了一眼袁河，继续说，在后来的一节体育课上，我觉得时机差不多已经成熟了，便约她到草坪上聊天。希望可以跟她表白。但是我将那些话讲出来后，她却沉默了。很久之后她才对我说，我知道你是一很优秀的男生，但是我……我……真正……喜欢的人是……袁河。从我们做同桌开始，我就喜欢上了她。我喜欢他的幽默风趣，我喜欢他的乐观开朗，我喜欢他一切的一切。他是我从小到大，遇到的第一个真正喜欢的人。在他面前，我可以坦诚到不保留任何秘密或隐私。你永远都不会明白我对他的那种感情。我看我们还是做朋友吧。</p><p>陆可凡凄然一笑，和林依然对你讲的差不多。我当时突然就像掉进了冰窖中一样，瞬间没有知觉了。没想到，我平生第一个喜欢的人，就这样轻易拒绝了自己。真是太……我实在找不出一个词语，来形容自己当时的感受。我只晓得过了好半天，自己才反应过来。然后眼泪就开始拼命地往下掉。你知道我从来不哭的，不管别人怎么说我清高狂妄目中无人，我都没有哭过。但是那天我却哭得很伤心，就像小孩子受到委屈了一样。最后她告诉我，那些纸飞机并不是她送给我的，但却一直不肯告诉我，到底是谁送的。所以直到现在，我还不知道是谁送的。真搞笑！</p><p>陆可凡说完最后三个字，却开始哭了起来。</p><p>袁河听完心里七上八下的，赵燕说她喜欢自己，到底是不是真的？当他仔细回想了一遍赵燕曾经在自己面前的所有举止后，便完全确定，这是真的。但是……但是自己喜欢的人却是林依然。</p><p>33</p><p>袁河突然觉得这个世界真是太荒唐了。这样的事情怎么会发生在他们身上，而且还这样扑朔迷离，颠倒错乱。每个人都喜欢上了不喜欢自己的人，而且居然还奇迹般地围绕成了一个圆。真是太讽刺了。如果把这样的事情说出去，到底谁会相信？没有人会相信。就连他们自己，都不敢相信那是真的。这个圆真是太可笑了。它带给每个人的不是一种圆满，而是一段悲惨，甚至还有些荒诞。一切怎么会变成现在这个样子啊？</p><p>袁河像陆可凡那样一口气喝掉半瓶啤酒，然后抬起头望着天空发笑，但是却笑得很凄凉。笑着笑着便开始哭。上高中以来，自己哭过多少次了？袁河使劲想，努力想，但却想不起来了。袁河没想到，平时如此坚强的他，如此开朗的他，有时也会这么脆弱，这么忧伤。我到底是怎么了？袁河想了很久，但却始终想不明白。难道这就是所谓的成长吗？真是太荒唐了。太荒唐了。</p><p>34</p><p>陆可凡不知什么时候已经没再流泪了。他转过头问袁河，你知不知道，那些纸飞机，到底是谁送给我的？</p><p>　　袁河说，是林依然送给你的。那里面的话也是她写给你的。你现在应该明白了吧。</p><p>　　陆可凡说，我明白了。可是，我真的对她没有任何感觉。再说，她凭什么因为喜欢我，就和赵燕闹矛盾？我就没有因为喜欢赵燕，而和你闹矛盾。她这样做未免也太过分了吧。毕竟赵燕是她那么好的朋友。况且赵燕又没有做错什么。她为什么要那样对待赵燕？她的嫉妒心未免也太强了吧。我实在无法容忍她这样随便伤害自己的朋友。</p><p>袁河低声说，你不要这样想她，好不好？她不是那样的人。看来，你对她还是不了解。你不知道，她与赵燕闹矛盾后，一个人在背地里哭过多少回，流过多少泪。你也不知道，她有多么悲惨的过去。你更不知道，她是因为太在乎你，所以才会离开赵燕。</p><p>袁河停顿了一下，接着说，你没有意识到，你和赵燕在一起时，无形中给她施加了多么大的压力。你也没有意识到，你在无意中，给她强加了多么大的痛苦。而那些压力和痛苦，她是根本无法承受的。但是，她又不想连累自己的朋友，所以才会选择离开。你更没有意识到，所有这一切，都是你间接造成的。所以你不应该那样认为她，否则，就太对不起她寄托在你身上的那份感情了。</p><p>袁河说完，便给陆可凡讲了很多与林依然有关的事情。</p><p>　　陆可凡听完后，心里忽然感到特别不安，张了张口想要说什么。最终却没有说出来。</p><p>　　袁河看着陆可凡，你今天晚上对她讲的那些话，实在太伤她的心了。所以她才会忍不住当场哭出来。你难道不觉得应该为她做点什么吗？</p><p>　　陆可凡说，如果我现在去跟她道歉的话，她肯定不会接受的。你说我该怎么办啊？</p><p>　　袁河说，要不然这样吧，明天我去找她好好谈一下。把所有这些情况都跟她说清楚。她是一个明晓事理的人。我想她应该会原谅你的。说不定还会跟赵燕和好如初呢。</p><p>　　陆可凡说，如果是这样的话，那就太好了。明天我也会以小纸条的形式向她道歉，就说我不是故意的，因为最近一段时间，我心情不好，所以才会那样对她，希望她可以原谅我。如果以后她需要什么帮助的话，我会义不容辞尽力而为的。今后，我也会像对待你和赵燕那样跟她讲题，绝不敷衍。真的。</p><p>袁河说，好样的，这才是我的朋友陆可凡。</p><p>　　陆可凡忽然握住袁河的手说，谢谢你把林依然的这些情况都跟我讲了。否则，我也许会因为她伤害赵燕，而恨她一辈子，但是现在，我却不怪她了，我现在对她，甚至有些怜惜。以后，我会经常主动与她交往的，如果可能的话，我希望和像你一样，去关心他，去帮助她，去照顾她，去保护她。我没想到她对我的感情会那样浓烈，那样深厚。我确实不应该说那样的话来伤害她。我错了。错了。</p><p>　　袁河拍拍陆可凡的肩膀说，你明白就好。</p><p>　　陆可凡说，尽管赵燕真正喜欢的人是你。虽然后来我们再也没有聚在一起打过篮球。但是我对她却没有一点恨意。对你也没有。我和她，和你，都还是很好的朋友，对吧。</p><p>袁河说，对，我们都还是很好的朋友。嗯，很好的，朋友。</p><p>35</p><p>陆可凡忽然像记起什么东西似的说，那你和赵燕呢？她也是一个很好的女孩。她也是真心喜欢你的。你难道不觉得也应该为她做点什么吗？</p><p>　　袁河说，其实我也挺喜欢她的。只是程度不及林依然罢了。因为她那么阳光，那么坚强，那么开朗，每天都过的很快乐，很充实，很幸福，根本不需要我去保护她。相反，林依然是那么娇小，那么柔弱，那么无助，让人见到她，都会不由自主生出一种强烈的想要保护她的念头。所以……</p><p>陆可凡打断他说，不，你错了。其实赵燕更需要你去保护她。你知道那天在草坪上，她怎么跟我说吗？她说，我是那么喜欢袁河，我也是那么在乎林依然，所以为了消除他们之间的误会，我才会不惜一切，为他们做任何事情。但是我根本没有想到，自己付出了那么多，到头来却没有半点回报。我失去了袁河，我也失去了林依然。我一下子失去了生命中最重要的两个人。我现在变得一无所有。一无所有。你说，我是不是自作自受咎由自取啊？她说到这里早已泪流满面泣不成声。其实，她并没有你想象的那么坚强，那么乐观。有时候，她也很脆弱很忧伤很无助的。她经常也会遇到一些不开心的事情。但是在你面前，她却依然要保持乐观和坚强。你知道为什么吗？</p><p>袁河摇了摇头说，不知道。</p><p>陆可凡看了一眼袁河，她那天对我说，曾经有几次，因为极度伤心，实在控制不住自己，就在你面前哭了起来。却没有想到你也跟着哭了起来。所以后来，在你面前，她就一直保持乐观，保持坚强，再也不哭了。因为她怕你跟着一起伤心，一起难过。因为她怕你看到她的另一面会瞧不起她。</p><p>　　袁河惊道，怎么会呢？我怎么会瞧不起她呢？这完全不可能事情。</p><p>　　陆可凡说，这说明，你对她还是不了解。所以你也应该好好和她谈一下。</p><p>　　袁河说，嗯，我知道应该怎么做了。说完将剩余半瓶酒一饮而尽，走吧，时间不早了，回寝室睡觉吧。一切都等明天再说。你看，下面都没人了。</p><p>陆可凡点点头，嗯，走吧。</p><p>36</p><p>后来一切果然就像那天晚上袁河与陆可凡说的那样。林依然原谅了陆可凡的错误，接受了他的道歉。没过多久，便成为了朋友。</p><p>袁河与赵燕还是同桌，但是关系明显加深了一层，原因不言而喻。</p><p>　　而赵燕与林依然，也已经和好如初了。</p><p>　　大家知道他们是怎样和好的吗？我想大家应该都还记得那个天蓝色的笔记本吧。就是通过它和好的。</p><p>　　那天袁河将所有事情告诉林依然后，轻声问她，你愿意与赵燕和好吗？</p><p>林依然说，我当然愿意了。可是我那样对她，她肯定恨死我了。她还会和我做朋友吗？我现在知道错了。我不应该那样对她的。可是她会原谅我吗？</p><p>后来袁河又问赵燕，林依然之前那样对你，你恨她吗？如果她向你道歉，你会原谅她吗？如果现在林依然说，让我们和好吧，你会同意吗？</p><p>　　赵燕说，其实我一点都不恨她。如果她向我道歉的话，我会毫不犹豫就原谅她的。如果她对我那样说的话，我会不假思索就答应她的。毕竟我们曾经是那么好的朋友。</p><p>　　于是在袁河的劝说下，她们便通过那个天蓝色的笔记本向对方道歉。结果每人都写了两三页。看得两人都哭了。后来她们就冰释前嫌和好如初了。</p><p>　　袁河与林依然。陆可凡与赵燕。关系始终很好。</p><p>至于袁河与陆可凡，那就不用说了。依然是最好的朋友。</p><p>最让人欣喜的是，班上同学对陆可凡的态度和偏见，也都发生了改变。</p><p>因为林依然的缘故，陆可凡认识到，自己安静内向的性格，以及与世隔绝的做法，实在太不应该了。毕竟大家都是同学，能够聚在一起便是缘分，完全没有必要那么绝情，搞的别人误会，自己受气，何苦呢？</p><p>从此以后，陆可凡开始经常主动与人交往。别人向他请教题目时，他再也不会把解题过程写在草稿纸上面递给人家，而是认真地讲解，直到别人听懂为止。课间休息的时候，他有时也会出去和别人聚在一起，谈论自己感兴趣的话题。于是慢慢地，别人对他的态度就发生了改变。</p><p>袁河说，我早就知道，总有一天，你会变成一个活泼开朗的人。我也早就知道，总有一天，别人会重新认识你的。怎么样？我没有猜错吧。</p><p>在后来的日子里，他们四个人会一起去食堂吃饭，一起在教室聊天，一起上街闲逛，一起跑去上网……有人看了说，要是我能像他们那样的话，那我就是天下最快乐的人了。另一人道，废话，无论谁像她那样，都会觉得快乐的。不是吗？</p><p>37</p><p>　　高二下学期考试结束那天，袁河提议说，明天大家就要分开了，明年大家就要高三了，为了我们的友谊，为了将来的高考，我们今晚不如聚在一起吃顿饭吧，怎么样？同意的举手。说完四个人同时举起手来。然后大声笑着说，走，出发！</p><p>不用说，他们又是在校园外面那家名叫“三回头”的小餐馆里面吃的饭。到目前为止，除了袁河外，其他三人都在这里吃过三次饭了。真是名副其实的三回头啊。有意思！至于后来，他们还要回几次头，那就说不到了。</p><p>　　在吃饭的时候，大家脸上全都洋溢着欢乐，根本没有半分将要分别的痛苦。</p><p>　　袁河不知干掉了多少啤酒，反正喝到最后，眼前的一切全都开始变得飘渺起来，周围的一切全都幻化成了无数含苞欲放的花朵。在每个花朵上面都写有两个汉字，有的上面写着“友情”，有的上面写着“爱情”。然后袁河看到所有的花朵全都慢慢开放了，那样壮观，那样美丽。就像仙境一样。袁河仿佛还听到了花开的声音。那样婉转，那样动听。就像神曲一样。</p><p>　　袁河突然说，你们看，花开了！</p><p>　　三人听后面面相觑。陆可凡说，袁河，你是不是喝醉了。我们送你回寝室休息吧。</p><p>袁河想说，我没有醉，我还要喝！但是头昏昏沉沉的，话还没有说出口，就已经趴在桌子上睡着了。</p><p>　　后来袁河多次提到那天晚上，自己看到的情景。但是别人却都不相信。都说那是幻觉。都说他在做梦。</p><p>袁河自言自语说，难道那真是幻觉？难道我真在做梦？但是我分明看到了友情花和爱情花慢慢开放的情景。我确实真切地听到了那些花开的声音。</p><p>也许这不是幻觉，不是做梦，而是真的。</p><p>那时花开！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作品：《那时花开》&lt;/p&gt;
&lt;p&gt;字数：约 35000 字&lt;/p&gt;
&lt;p&gt;体裁：中篇小说&lt;/p&gt;
&lt;p&gt;关键字：校园青春&lt;/p&gt;
&lt;p&gt;背景：小说记录了自己以在高中时期一群小伙伴的学习生活，作者：陈晓雷&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ebd88c6345e5ad414d1007e6f121417e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;袁河是高二上学期转到陆可凡他们班的。至于转班的原因却不得而知。不过众所周知的是，陆可凡他们班的语文老师是袁河的爸爸，所以就有人猜测这可能是他爸爸的注意，目的很简单，无非就是为了方便监督和管教儿子学习。那为什么到了高二才转班呢？答案也很简单，因为高二是承上启下的关键学期，既能延续高一时的学习状态，又能为高三做准备，所以这时转班最合适不过了。&lt;/p&gt;
&lt;p&gt;转到陆可凡他们班上后，袁河发现了一个奇怪的现象。&lt;/p&gt;
&lt;p&gt;比如一般课间休息的时候，同学们都会以固有的方式来放松自己。其中少数同学会走出教室，站在外面的走廊上，抬头仰望天空，认真盘算自己忧伤的心事。或者靠在旁边的栏杆上，低头看着地面，仔细回忆某天的快乐心情。而大多数同学则会三五成群地聚在一起，找一个大家都感兴趣的话题，然后各抒己见，开始谈论。
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>应用架构设计原则</title>
    <link href="http://heartaway.cn/2017/12/07/Program/2017-12-07-architecture-design-rule/"/>
    <id>http://heartaway.cn/2017/12/07/Program/2017-12-07-architecture-design-rule/</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2018-11-09T14:27:04.088Z</updated>
    
    <content type="html"><![CDATA[<p>软件系统架构设计原则就是把我们在各种场景下的架构设计进行抽选化提取公共特征形成过一定的方法论，这些方法论是经过严格推敲并具备移植性的，我们在设计系统时遵从这些设计规则可以为我们的体统提供更高的扩展性、稳定性。</p><h2 id="抽象原则"><a href="#抽象原则" class="headerlink" title="抽象原则"></a>抽象原则</h2><p>各平台(含基础设施、中间件技术服务、各层业务服务等)需要通过合理地抽象，将内部信息、处理与扩展能力聚合成标准的服务于扩展接口，并通过统一的形式提供给使用者，屏蔽内部的实现与运行细节。</p><p>以下是一些符合抽象原则的架构规范或模式：<br>架构分层(layer)/级(tier)，层、级间提供标准服务与数据接口<br>根据业务模型，统一服务标准与数据标准<br>使用服务目录屏蔽服务位置等实现细节<br>使用“逻辑库”屏蔽数据库物理细节<br>通过SLA，标准化服务的质量水平<br>提供标准插件架构支持扩展<br>使用标准数据库特性，保持厂商无关性<br>使用逻辑的网络与系统名称<br>使用商品化硬件单元</p><h2 id="共享原则"><a href="#共享原则" class="headerlink" title="共享原则"></a>共享原则</h2><p>最大化重用数据、计算资源、业务组件等资产，防止数据、逻辑与技术实现不一致性带来的管理复杂性，避免重复建设成本与管理成本，通过安全机制保证共享资产的合法使用，通过业务分级保障共享资源效益最大化。<br>以下是一些符合共享原则的架构规范或模式：</p><ul><li>同一业务服务有唯一提供者</li><li>同一技术服务有唯一提供者</li><li>同一数据有唯一可信源</li><li>控制技术多样性 (但需要同时防止厂商绑定)</li><li>服务具备互操作性</li><li>服务具备易用性</li><li>统一的身份、访问控制与加解密机制</li><li>为共享服务提供多租户能力 (Multi-tenancy)</li><li>提供访问计量与控制能力</li><li>提供业务分级能力，对不同级别的业务提供区分服务</li></ul><h2 id="自治原则"><a href="#自治原则" class="headerlink" title="自治原则"></a>自治原则</h2><p>每一个组件（计算资源、业务组件、信息实体等）具备最大可能的自我完备性，可独立运行、监控、部署、配置与禁用，具备确定的SLA，并与其它组件之间以松散耦合的方式进行协作。当依赖的组件不存在或者无法正常提供服务时，能够以良好的方式降级，且在故障解除后自动恢复。<br>以下是一些符合自治原则的架构规范或模式：</p><ul><li>基于开-闭原则(OCP)设计组件</li><li>应用无启动依赖</li><li>最小化运行依赖集</li><li>根据运行依赖关系合理安排组件物理colocation</li><li>能够隔离依赖组件的故障</li><li>异步调用 (提升异常流量的承载能力，简化故障隔离的实现)</li><li>具备自我健康检查能力</li><li>具备自我恢复能力</li><li>无状态设计</li></ul><h2 id="冗余原则"><a href="#冗余原则" class="headerlink" title="冗余原则"></a>冗余原则</h2><p>各组件（计算资源、业务组件、数据等）都必须有充分、合理的冗余实例，保证单一组件实例失效不影响业务正常运行（多活/热备），或可以通过切换备份实例快速恢复（温备/冷备），不会丢失不可恢复的数据。针对不同类型的组件，需要明确定义冗余量与冗余类型。<br>以下是一些符合冗余原则的架构规范或模式：</p><ul><li>高可用水平扩展服务器集群（负载均衡、健康检查与自动切换）</li><li>无单点设计 (含逻辑单点)</li><li>采用“随机写”策略的数据库水平拆分</li><li>Failover数据库</li><li>N+1或N+x设计</li><li>“多活”数据中心</li><li>数据复制</li><li>灾难备份</li></ul><h2 id="分布原则"><a href="#分布原则" class="headerlink" title="分布原则"></a>分布原则</h2><p>整个系统拆分成职责清晰、粒度恰当、便于管理的组件，各组件（计算资源、业务组件、数据等）可分布部署运行。组件的拆分与分布可以采取复制、根据功能垂直拆分、或根据用户与访问模式水平拆分等形式。<br>以下是一些符合分布原则的架构规范或模式：</p><ul><li>读写分离设计</li><li>垂直分拆</li><li>水平分拆</li><li>柔性的分布事务</li></ul><h2 id="自动原则"><a href="#自动原则" class="headerlink" title="自动原则"></a>自动原则</h2><p>系统设计了具备自监控、自管理、自适应与自优化能力，可以随着业务量与访问模式的变化、以及其它内、外部因素的改变，自动地对资源进行调度、调整服务策略，保障自身的稳定与服务的质量。<br>以下是一些符合自动原则的架构规范或模式：</p><ul><li>监控每一个服务的质量与资源的状态与报警</li><li>从客户视角监控最终服务的质量</li><li>统一、自动的错误报告、管理与响应</li><li>提供完备的配置能力</li><li>自动化系统安装</li><li>自动化应用部署</li><li>自动化资源分配</li><li>可以mark up/mark down服务</li><li>支持优雅降级</li><li>自动拒绝超出SLA之外异常流量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件系统架构设计原则就是把我们在各种场景下的架构设计进行抽选化提取公共特征形成过一定的方法论，这些方法论是经过严格推敲并具备移植性的，我们在设计系统时遵从这些设计规则可以为我们的体统提供更高的扩展性、稳定性。&lt;/p&gt;
&lt;h2 id=&quot;抽象原则&quot;&gt;&lt;a href=&quot;#抽象原则
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>如何进行高效学习</title>
    <link href="http://heartaway.cn/2017/11/24/Think/2017-11-24-how-to-study/"/>
    <id>http://heartaway.cn/2017/11/24/Think/2017-11-24-how-to-study/</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-11-09T14:29:08.549Z</updated>
    
    <content type="html"><![CDATA[<ul><li><img src="/slides/how-to-study/01.jpg" alt=""></li><li><img src="/slides/how-to-study/02.jpg" alt=""></li><li><img src="/slides/how-to-study/03.jpg" alt=""></li><li><img src="/slides/how-to-study/04.jpg" alt=""></li><li><img src="/slides/how-to-study/05.jpg" alt=""></li><li><img src="/slides/how-to-study/06.jpg" alt=""></li><li><img src="/slides/how-to-study/07.jpg" alt=""></li><li><img src="/slides/how-to-study/08.jpg" alt=""></li><li><img src="/slides/how-to-study/09.jpg" alt=""></li><li><img src="/slides/how-to-study/10.jpg" alt=""></li><li><img src="/slides/how-to-study/11.jpg" alt=""></li><li><img src="/slides/how-to-study/12.jpg" alt=""></li><li><img src="/slides/how-to-study/13.jpg" alt=""></li><li><img src="/slides/how-to-study/14.jpg" alt=""></li><li><img src="/slides/how-to-study/15.jpg" alt=""></li><li><img src="/slides/how-to-study/16.jpg" alt=""></li><li><img src="/slides/how-to-study/17.jpg" alt=""></li><li><img src="/slides/how-to-study/18.jpg" alt=""></li><li><img src="/slides/how-to-study/19.jpg" alt=""></li><li><img src="/slides/how-to-study/20.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      学习方法论
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>消息收发中的中文乱码</title>
    <link href="http://heartaway.cn/2017/10/20/Java/2017-10-20-message-string-byte/"/>
    <id>http://heartaway.cn/2017/10/20/Java/2017-10-20-message-string-byte/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2018-11-09T14:24:06.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：<br>A发消息给B系统，A、B应用的编码均为UTF-8，但是B收到的消息出现中文乱码。</p></blockquote><p>A发送消息的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Message(TOPIC, TAG, <span class="keyword">null</span>,          (messageContent.toString()).getBytes())</span><br></pre></td></tr></table></figure><p>这里消息接受二进制byte数据，我们把消息string转换为byte的时候，默认使用了getBytes()，未指定编码方式，getBytes()方法的注释如下：</p><p>Encodes this {@code String} into a sequence of bytes using the<br> platform’s default charset, storing the result into a new byte array.</p><p>也就是会使用平台默认编码，查看StringCoding.encode方法中的Charset.defaultCharset().name()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the default charset of this Java virtual machine.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt; The default charset is determined during virtual-machine startup and</span></span><br><span class="line"><span class="comment">  * typically depends upon the locale and charset of the underlying</span></span><br><span class="line"><span class="comment">  * operating system.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  A charset object for the default charset</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (defaultCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Charset.class) &#123;</span><br><span class="line">             String csn = AccessController.doPrivileged(</span><br><span class="line">                 <span class="keyword">new</span> GetPropertyAction(<span class="string">"file.encoding"</span>));</span><br><span class="line">             Charset cs = lookup(csn);</span><br><span class="line">             <span class="keyword">if</span> (cs != <span class="keyword">null</span>)</span><br><span class="line">                 defaultCharset = cs;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 defaultCharset = forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> defaultCharset;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释的很清楚了，返回JVM默认的字符编码，如果在jvm启动参数中指定了-Dfile.encoding 编码，则优先使用此编码，如果未指定，则使用UTF-8编码；</p><p>登录服务器查看启动参数，发现A应用进程中指定了-Dfile.encoding=GB18030</p><p><img src="/images/posts/20171020/15084809508975.jpg" alt=""></p><p>示意图如下：<br><img src="/images/posts/20171020/15084807485727.jpg" alt=""></p><p>总结：<br>在进行string与byte转换的时候，最好使用getBytes(String charsetName)方法，明确指定字符编码方式，最好编写一个编码转换的工具类，统一类型转换时的编码方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：&lt;br&gt;A发消息给B系统，A、B应用的编码均为UTF-8，但是B收到的消息出现中文乱码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A发送消息的方式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Capture Html Content After Render</title>
    <link href="http://heartaway.cn/2017/09/21/Java/2017-09-21-phantomjs-use/"/>
    <id>http://heartaway.cn/2017/09/21/Java/2017-09-21-phantomjs-use/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2018-11-09T14:40:02.772Z</updated>
    
    <content type="html"><![CDATA[<p>在前端技术越来越注重用户体验的潮流下，异步数据渲染组件成为主流，但是异步渲染给爬虫和相关需要使用页面异步渲染后Dom结构的需求来说，变得很麻烦。要想获取渲染后的页面内容，常见的方法有：</p><ol><li>使用类似于PhantomJS的Headless浏览器，模拟页面渲染，获取页面HTML；</li><li>分析Ajax请求，获取请求后的数据。</li></ol><p>对于千变万化的页面结构来说，第一种方法更具备通用性，首选需要安装PhantomJS，然后编写js脚本，最后就是运行脚本获取结果啦。</p><p>比如我编写了一个loadPage.js,用于支持页面截图或者页面渲染后的HTML结构获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = require(<span class="string">'system'</span>).args;</span><br><span class="line"><span class="keyword">var</span> page = require(<span class="string">'webpage'</span>).create();</span><br><span class="line"><span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> url;</span><br><span class="line"><span class="keyword">var</span> fileName = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> cookieJson = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> type = <span class="string">"html"</span>;</span><br><span class="line"><span class="keyword">var</span> viewWidth = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> viewHeight = <span class="number">768</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args.forEach(function(arg, i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">1</span>)&#123;</span><br><span class="line">      url = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">2</span>)&#123;</span><br><span class="line">      type = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(i === <span class="number">3</span>)&#123;</span><br><span class="line">      fileName = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">4</span>)&#123;</span><br><span class="line">      cookieJson = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">5</span>)&#123;</span><br><span class="line">      viewWidth = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">6</span>)&#123;</span><br><span class="line">      viewHeight = arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">page.viewportSize = &#123; width: viewWidth, height:viewHeight &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cookieJson != <span class="keyword">null</span> &amp;&amp; cookieJson != <span class="string">""</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieArray =  JSON.parse(cookieJson);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookieArray.length; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> cookieObj = cookieArray[i];</span><br><span class="line">          <span class="keyword">var</span> cookie = &#123;</span><br><span class="line">            <span class="string">'name'</span>     : cookieObj.name,</span><br><span class="line">            <span class="string">'value'</span>    : cookieObj.value,</span><br><span class="line">            <span class="string">'path'</span>     : cookieObj.path,</span><br><span class="line">            <span class="string">'domain'</span>   : cookieObj.domain,</span><br><span class="line">            <span class="string">'expires'</span>  : cookieObj.expires</span><br><span class="line">          &#125;;</span><br><span class="line">        phantom.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page.onError = function(msg, trace) &#123;</span><br><span class="line">    console.log(<span class="string">"[Warning]This is page.onError"</span>);</span><br><span class="line">    <span class="keyword">var</span> msgStack = [<span class="string">'ERROR: '</span> + msg];</span><br><span class="line">    <span class="keyword">if</span> (trace &amp;&amp; trace.length) &#123;</span><br><span class="line">        msgStack.push(<span class="string">'TRACE:'</span>);</span><br><span class="line">        trace.forEach(function(t) &#123;</span><br><span class="line">          msgStack.push(<span class="string">' -&gt; '</span> + t.file + <span class="string">': '</span> + t.line + (t.function ? <span class="string">' (in function "'</span> + t.function +<span class="string">'")'</span> : <span class="string">''</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.error(msgStack.join('\n'));</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">phantom.onError = function(msg, trace) &#123;</span><br><span class="line">    console.log(<span class="string">"[Warning]This is phantom.onError"</span>);</span><br><span class="line">    <span class="keyword">var</span> msgStack = [<span class="string">'PHANTOM ERROR: '</span> + msg];</span><br><span class="line">    <span class="keyword">if</span> (trace &amp;&amp; trace.length) &#123;</span><br><span class="line">      msgStack.push(<span class="string">'TRACE:'</span>);</span><br><span class="line">      trace.forEach(function(t) &#123;</span><br><span class="line">        msgStack.push(<span class="string">' -&gt; '</span> + (t.file || t.sourceURL) + <span class="string">': '</span> + t.line + (t.function ? <span class="string">' (in function '</span> + t.function +<span class="string">')'</span> : <span class="string">''</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">      console.error(msgStack.join(<span class="string">'\n'</span>));</span><br><span class="line">      phantom.exit(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">page.onLoadFinished = function() &#123;</span><br><span class="line">   setTimeout(function()&#123;</span><br><span class="line">      <span class="keyword">if</span>(type == <span class="string">"image"</span>)&#123;</span><br><span class="line">        page.render(fileName,&#123;format: <span class="string">'jpg'</span>, quality: <span class="string">'100'</span>&#125;);</span><br><span class="line">        console.log(<span class="string">"render page finished: "</span> + url);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(type == <span class="string">"html"</span>)&#123;</span><br><span class="line">         fs.write(fileName, page.content, <span class="string">'w'</span>);</span><br><span class="line">         console.log(<span class="string">"page html gen success: "</span> + url);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      phantom.exit();         </span><br><span class="line">   &#125;,<span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">page.open(url, function (status) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">"success"</span>) &#123;</span><br><span class="line">        console.log(<span class="string">"load status: "</span> + status);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        phantom.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务端通过Process类调用Linux中的shell脚本，运行截图或者页面渲染服务，然后把获取到的结果存储到文件存储系统中，返回文件存储的地址URL给业务方，业务方通过URL访问原始数据，减少网络数据传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String type = <span class="string">"html"</span>;</span><br><span class="line">String[] params =</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;DiamondUtil.getPhantomJsPath(), DiamondUtil.getCaptureJsPath(), url,type , htmlName,</span><br><span class="line">                        cookieJson&#125;;</span><br><span class="line">                ShellUtil.executeShell(params, <span class="string">" capture url "</span> + url);</span><br><span class="line">                File htmlFile = <span class="keyword">new</span> File(defaultFilePath(htmlName));</span><br><span class="line">                <span class="keyword">if</span> (checkFileEixst(htmlFile)) &#123;</span><br><span class="line">                    String htmlOssUrl = fileService.updateObjectToOss(htmlName, htmlFile);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>ShellUtil中的运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeShell</span><span class="params">(String[] params, String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader stdBufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader errorBufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(params);</span><br><span class="line">            pb.directory(<span class="keyword">new</span> File(DiamondUtil.getCaptureImagePath()));</span><br><span class="line">            pb.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">            process = pb.start();</span><br><span class="line">            stdBufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">            errorBufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = stdBufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(message + <span class="string">":"</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((line = errorBufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(message + <span class="string">":"</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">            process.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(message, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stdBufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stdBufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (errorBufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stdBufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (process != <span class="keyword">null</span>) &#123;</span><br><span class="line">                process.destroy();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在截图服务中，首次出现了中文乱码，网上有同学说安装bitmap-fonts，但是并不好使，建议删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove bitmap-fonts bitmap-fonts-cjk</span><br></pre></td></tr></table></figure><p>网页查看我们使用的字体内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#123;  ...  font-family: Helvetica, arial, "microsoft yahei", Monaco, sans-serif;  ...&#125;</span><br></pre></td></tr></table></figure><p>可以看到有 多种字体，最后的 sans-serif 默认对应是黑体，需要把这5种字体装到截图的 Linux 服务器，分别从osx和windows上copy出来，注意一下，osx 中的字体是 .ttc 和 .dfont 格式的，我们 可以借助 <a href="http://transfonter.org/ttc-unpack来转换为" target="_blank" rel="noopener">http://transfonter.org/ttc-unpack来转换为</a> Linux 支持的 .ttf 的格式。</p><p>把这些文件拷到 Linux 服务器上，然后调用 fc-cache 更新一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/share/fonts/customsudo cp *.ttf  /usr/share/fonts/customfc-cache -fv</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端技术越来越注重用户体验的潮流下，异步数据渲染组件成为主流，但是异步渲染给爬虫和相关需要使用页面异步渲染后Dom结构的需求来说，变得很麻烦。要想获取渲染后的页面内容，常见的方法有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用类似于PhantomJS的Headless浏览器，模拟页面
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
</feed>
