{"meta":{"title":"Heartaway","subtitle":null,"description":null,"author":"Xinyuan","url":"http://heartaway.cn"},"pages":[{"title":"","date":"2018-11-09T14:09:21.501Z","updated":"2018-11-09T13:48:03.829Z","comments":true,"path":"lightslider/css/lightslider.css","permalink":"http://heartaway.cn/lightslider/css/lightslider.css","excerpt":"","text":"/*! lightslider - v1.1.5 - 2015-10-31 * https://github.com/sachinchoolur/lightslider * Copyright (c) 2015 Sachin N; Licensed MIT */ /*! lightslider - v1.1.3 - 2015-04-14 * https://github.com/sachinchoolur/lightslider * Copyright (c) 2015 Sachin N; Licensed MIT */ /** /!!! core css Should not edit !!!/**/ .lSSlideOuter { overflow: hidden; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none } .lightSlider:before, .lightSlider:after { content: \" \"; display: table; } .lightSlider { overflow: hidden; margin: 0; } .lSSlideWrapper { max-width: 100%; overflow: hidden; position: relative; } .lSSlideWrapper > .lightSlider:after { clear: both; } .lSSlideWrapper .lSSlide { -webkit-transform: translate(0px, 0px); -ms-transform: translate(0px, 0px); transform: translate(0px, 0px); -webkit-transition: all 1s; -webkit-transition-property: -webkit-transform,height; -moz-transition-property: -moz-transform,height; transition-property: transform,height; -webkit-transition-duration: inherit !important; transition-duration: inherit !important; -webkit-transition-timing-function: inherit !important; transition-timing-function: inherit !important; } .lSSlideWrapper .lSFade { position: relative; } .lSSlideWrapper .lSFade > * { position: absolute !important; top: 0; left: 0; z-index: 9; margin-right: 0; width: 100%; } .lSSlideWrapper.usingCss .lSFade > * { opacity: 0; -webkit-transition-delay: 0s; transition-delay: 0s; -webkit-transition-duration: inherit !important; transition-duration: inherit !important; -webkit-transition-property: opacity; transition-property: opacity; -webkit-transition-timing-function: inherit !important; transition-timing-function: inherit !important; } .lSSlideWrapper .lSFade > *.active { z-index: 10; } .lSSlideWrapper.usingCss .lSFade > *.active { opacity: 1; } /** /!!! End of core css Should not edit !!!/**/ /* Pager */ .lSSlideOuter .lSPager.lSpg { margin: 10px 0 0; padding: 0; text-align: center; } .lSSlideOuter .lSPager.lSpg > li { cursor: pointer; display: inline-block; padding: 0 5px; } .lSSlideOuter .lSPager.lSpg > li a { background-color: #222222; border-radius: 30px; display: inline-block; height: 8px; overflow: hidden; text-indent: -999em; width: 8px; position: relative; z-index: 99; -webkit-transition: all 0.5s linear 0s; transition: all 0.5s linear 0s; } .lSSlideOuter .lSPager.lSpg > li:hover a, .lSSlideOuter .lSPager.lSpg > li.active a { background-color: #428bca; } .lSSlideOuter .media { opacity: 0.8; } .lSSlideOuter .media.active { opacity: 1; } /* End of pager */ /** Gallery */ .lSSlideOuter .lSPager.lSGallery { list-style: none outside none; padding-left: 0; margin: 0; overflow: hidden; transform: translate3d(0px, 0px, 0px); -moz-transform: translate3d(0px, 0px, 0px); -ms-transform: translate3d(0px, 0px, 0px); -webkit-transform: translate3d(0px, 0px, 0px); -o-transform: translate3d(0px, 0px, 0px); -webkit-transition-property: -webkit-transform; -moz-transition-property: -moz-transform; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .lSSlideOuter .lSPager.lSGallery li { overflow: hidden; -webkit-transition: border-radius 0.12s linear 0s 0.35s linear 0s; transition: border-radius 0.12s linear 0s 0.35s linear 0s; } .lSSlideOuter .lSPager.lSGallery li.active, .lSSlideOuter .lSPager.lSGallery li:hover { border-radius: 5px; } .lSSlideOuter .lSPager.lSGallery img { display: block; height: auto; max-width: 100%; } .lSSlideOuter .lSPager.lSGallery:before, .lSSlideOuter .lSPager.lSGallery:after { content: \" \"; display: table; } .lSSlideOuter .lSPager.lSGallery:after { clear: both; } /* End of Gallery*/ /* slider actions */ .lSAction > a { width: 32px; display: block; top: 50%; height: 32px; background-image: url('../img/controls.png'); cursor: pointer; position: absolute; z-index: 99; margin-top: -16px; opacity: 0.5; -webkit-transition: opacity 0.35s linear 0s; transition: opacity 0.35s linear 0s; } .lSAction > a:hover { opacity: 1; } .lSAction > .lSPrev { background-position: 0 0; left: 10px; } .lSAction > .lSNext { background-position: -32px 0; right: 10px; } .lSAction > a.disabled { pointer-events: none; } .cS-hidden { height: 1px; opacity: 0; filter: alpha(opacity=0); overflow: hidden; } /* vertical */ .lSSlideOuter.vertical { position: relative; } .lSSlideOuter.vertical.noPager { padding-right: 0px !important; } .lSSlideOuter.vertical .lSGallery { position: absolute !important; right: 0; top: 0; } .lSSlideOuter.vertical .lightSlider > * { width: 100% !important; max-width: none !important; } /* vertical controlls */ .lSSlideOuter.vertical .lSAction > a { left: 50%; margin-left: -14px; margin-top: 0; } .lSSlideOuter.vertical .lSAction > .lSNext { background-position: 31px -31px; bottom: 10px; top: auto; } .lSSlideOuter.vertical .lSAction > .lSPrev { background-position: 0 -31px; bottom: auto; top: 10px; } /* vertical */ /* Rtl */ .lSSlideOuter.lSrtl { direction: rtl; } .lSSlideOuter .lightSlider, .lSSlideOuter .lSPager { padding-left: 0; list-style: none outside none; } .lSSlideOuter.lSrtl .lightSlider, .lSSlideOuter.lSrtl .lSPager { padding-right: 0; } .lSSlideOuter .lightSlider > *, .lSSlideOuter .lSGallery li { float: left; } .lSSlideOuter.lSrtl .lightSlider > *, .lSSlideOuter.lSrtl .lSGallery li { float: right !important; } /* Rtl */ @-webkit-keyframes rightEnd { 0% { left: 0; } 50% { left: -15px; } 100% { left: 0; } } @keyframes rightEnd { 0% { left: 0; } 50% { left: -15px; } 100% { left: 0; } } @-webkit-keyframes topEnd { 0% { top: 0; } 50% { top: -15px; } 100% { top: 0; } } @keyframes topEnd { 0% { top: 0; } 50% { top: -15px; } 100% { top: 0; } } @-webkit-keyframes leftEnd { 0% { left: 0; } 50% { left: 15px; } 100% { left: 0; } } @keyframes leftEnd { 0% { left: 0; } 50% { left: 15px; } 100% { left: 0; } } @-webkit-keyframes bottomEnd { 0% { bottom: 0; } 50% { bottom: -15px; } 100% { bottom: 0; } } @keyframes bottomEnd { 0% { bottom: 0; } 50% { bottom: -15px; } 100% { bottom: 0; } } .lSSlideOuter .rightEnd { -webkit-animation: rightEnd 0.3s; animation: rightEnd 0.3s; position: relative; } .lSSlideOuter .leftEnd { -webkit-animation: leftEnd 0.3s; animation: leftEnd 0.3s; position: relative; } .lSSlideOuter.vertical .rightEnd { -webkit-animation: topEnd 0.3s; animation: topEnd 0.3s; position: relative; } .lSSlideOuter.vertical .leftEnd { -webkit-animation: bottomEnd 0.3s; animation: bottomEnd 0.3s; position: relative; } .lSSlideOuter.lSrtl .rightEnd { -webkit-animation: leftEnd 0.3s; animation: leftEnd 0.3s; position: relative; } .lSSlideOuter.lSrtl .leftEnd { -webkit-animation: rightEnd 0.3s; animation: rightEnd 0.3s; position: relative; } /*/ GRab cursor */ .lightSlider.lsGrab > * { cursor: -webkit-grab; cursor: -moz-grab; cursor: -o-grab; cursor: -ms-grab; cursor: grab; } .lightSlider.lsGrabbing > * { cursor: move; cursor: -webkit-grabbing; cursor: -moz-grabbing; cursor: -o-grabbing; cursor: -ms-grabbing; cursor: grabbing; }"},{"title":"","date":"2018-11-09T14:09:21.502Z","updated":"2018-11-09T13:48:03.829Z","comments":true,"path":"lightslider/css/lightslider.min.css","permalink":"http://heartaway.cn/lightslider/css/lightslider.min.css","excerpt":"","text":"/*! lightslider - v1.1.3 - 2015-04-14 * https://github.com/sachinchoolur/lightslider * Copyright (c) 2015 Sachin N; Licensed MIT */.lSSlideWrapper,.lSSlideWrapper .lSFade{position:relative}.lSSlideWrapper .lSSlide,.lSSlideWrapper.usingCss .lSFade>*{-webkit-transition-timing-function:inherit!important;transition-timing-function:inherit!important;-webkit-transition-duration:inherit!important;transition-duration:inherit!important}.lSSlideOuter,.lSSlideOuter .lSPager.lSGallery{-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none}.lSSlideOuter .lSPager.lSGallery:after,.lSSlideWrapper>.lightSlider:after{clear:both}.lSSlideOuter{overflow:hidden;user-select:none}.lightSlider:after,.lightSlider:before{content:\" \";display:table}.lightSlider{overflow:hidden;margin:0}.lSSlideWrapper{max-width:100%;overflow:hidden}.lSSlideWrapper .lSSlide{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);transform:translate(0,0);-webkit-transition:all 1s;-webkit-transition-property:-webkit-transform,height;-moz-transition-property:-moz-transform,height;transition-property:transform,height}.lSSlideWrapper .lSFade>*{position:absolute!important;top:0;left:0;z-index:9;margin-right:0;width:100%}.lSSlideWrapper.usingCss .lSFade>*{opacity:0;-webkit-transition-delay:0s;transition-delay:0s;-webkit-transition-property:opacity;transition-property:opacity}.lSSlideWrapper .lSFade>.active{z-index:10}.lSSlideWrapper.usingCss .lSFade>.active{opacity:1}.lSSlideOuter .lSPager.lSpg{margin:10px 0 0;padding:0;text-align:center}.lSSlideOuter .lSPager.lSpg>li{cursor:pointer;display:inline-block;padding:0 5px}.lSSlideOuter .lSPager.lSpg>li a{background-color:#222;border-radius:30px;display:inline-block;height:8px;overflow:hidden;text-indent:-999em;width:8px;position:relative;z-index:99;-webkit-transition:all .5s linear 0s;transition:all .5s linear 0s}.lSSlideOuter .lSPager.lSpg>li.active a,.lSSlideOuter .lSPager.lSpg>li:hover a{background-color:#428bca}.lSSlideOuter .media{opacity:.8}.lSSlideOuter .media.active{opacity:1}.lSSlideOuter .lSPager.lSGallery{list-style:none;padding-left:0;margin:0;overflow:hidden;transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-webkit-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;user-select:none}.lSSlideOuter .lSPager.lSGallery li{overflow:hidden;-webkit-transition:border-radius .12s linear 0s .35s linear 0s;transition:border-radius .12s linear 0s .35s linear 0s}.lSSlideOuter .lSPager.lSGallery li.active,.lSSlideOuter .lSPager.lSGallery li:hover{border-radius:5px}.lSSlideOuter .lSPager.lSGallery img{display:block;height:auto;max-width:100%}.lSSlideOuter .lSPager.lSGallery:after,.lSSlideOuter .lSPager.lSGallery:before{content:\" \";display:table}.lSAction>a{width:32px;display:block;top:50%;height:32px;background-image:url(../img/controls.png);cursor:pointer;position:absolute;z-index:99;margin-top:-16px;opacity:.5;-webkit-transition:opacity .35s linear 0s;transition:opacity .35s linear 0s}.lSAction>a:hover{opacity:1}.lSAction>.lSPrev{background-position:0 0;left:10px}.lSAction>.lSNext{background-position:-32px 0;right:10px}.lSAction>a.disabled{pointer-events:none}.cS-hidden{height:1px;opacity:0;filter:alpha(opacity=0);overflow:hidden}.lSSlideOuter.vertical{position:relative}.lSSlideOuter.vertical.noPager{padding-right:0!important}.lSSlideOuter.vertical .lSGallery{position:absolute!important;right:0;top:0}.lSSlideOuter.vertical .lightSlider>*{width:100%!important;max-width:none!important}.lSSlideOuter.vertical .lSAction>a{left:50%;margin-left:-14px;margin-top:0}.lSSlideOuter.vertical .lSAction>.lSNext{background-position:31px -31px;bottom:10px;top:auto}.lSSlideOuter.vertical .lSAction>.lSPrev{background-position:0 -31px;bottom:auto;top:10px}.lSSlideOuter.lSrtl{direction:rtl}.lSSlideOuter .lSPager,.lSSlideOuter .lightSlider{padding-left:0;list-style:none}.lSSlideOuter.lSrtl .lSPager,.lSSlideOuter.lSrtl .lightSlider{padding-right:0}.lSSlideOuter .lSGallery li,.lSSlideOuter .lightSlider>*{float:left}.lSSlideOuter.lSrtl .lSGallery li,.lSSlideOuter.lSrtl .lightSlider>*{float:right!important}@-webkit-keyframes rightEnd{0%,100%{left:0}50%{left:-15px}}@keyframes rightEnd{0%,100%{left:0}50%{left:-15px}}@-webkit-keyframes topEnd{0%,100%{top:0}50%{top:-15px}}@keyframes topEnd{0%,100%{top:0}50%{top:-15px}}@-webkit-keyframes leftEnd{0%,100%{left:0}50%{left:15px}}@keyframes leftEnd{0%,100%{left:0}50%{left:15px}}@-webkit-keyframes bottomEnd{0%,100%{bottom:0}50%{bottom:-15px}}@keyframes bottomEnd{0%,100%{bottom:0}50%{bottom:-15px}}.lSSlideOuter .rightEnd{-webkit-animation:rightEnd .3s;animation:rightEnd .3s;position:relative}.lSSlideOuter .leftEnd{-webkit-animation:leftEnd .3s;animation:leftEnd .3s;position:relative}.lSSlideOuter.vertical .rightEnd{-webkit-animation:topEnd .3s;animation:topEnd .3s;position:relative}.lSSlideOuter.vertical .leftEnd{-webkit-animation:bottomEnd .3s;animation:bottomEnd .3s;position:relative}.lSSlideOuter.lSrtl .rightEnd{-webkit-animation:leftEnd .3s;animation:leftEnd .3s;position:relative}.lSSlideOuter.lSrtl .leftEnd{-webkit-animation:rightEnd .3s;animation:rightEnd .3s;position:relative}.lightSlider.lsGrab>*{cursor:-webkit-grab;cursor:-moz-grab;cursor:-o-grab;cursor:-ms-grab;cursor:grab}.lightSlider.lsGrabbing>*{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:-o-grabbing;cursor:-ms-grabbing;cursor:grabbing}"},{"title":"","date":"2018-11-09T14:09:21.503Z","updated":"2018-11-09T13:48:03.830Z","comments":true,"path":"lightslider/js/lightslider.min.js","permalink":"http://heartaway.cn/lightslider/js/lightslider.min.js","excerpt":"","text":"/*! lightslider - v1.1.5 - 2015-10-31 * https://github.com/sachinchoolur/lightslider * Copyright (c) 2015 Sachin N; Licensed MIT */ !function(a,b){\"use strict\";var c={item:3,autoWidth:!1,slideMove:1,slideMargin:10,addClass:\"\",mode:\"slide\",useCSS:!0,cssEasing:\"ease\",easing:\"linear\",speed:400,auto:!1,pauseOnHover:!1,loop:!1,slideEndAnimation:!0,pause:2e3,keyPress:!1,controls:!0,prevHtml:\"\",nextHtml:\"\",rtl:!1,adaptiveHeight:!1,vertical:!1,verticalHeight:500,vThumbWidth:100,thumbItem:10,pager:!0,gallery:!1,galleryMargin:5,thumbMargin:5,currentPagerPosition:\"middle\",enableTouch:!0,enableDrag:!0,freeMove:!0,swipeThreshold:40,responsive:[],onBeforeStart:function(a){},onSliderLoad:function(a){},onBeforeSlide:function(a,b){},onAfterSlide:function(a,b){},onBeforeNextSlide:function(a,b){},onBeforePrevSlide:function(a,b){}};a.fn.lightSlider=function(b){if(0===this.length)return this;if(this.length>1)return this.each(function(){a(this).lightSlider(b)}),this;var d={},e=a.extend(!0,{},c,b),f={},g=this;d.$el=this,\"fade\"===e.mode&&(e.vertical=!1);var h=g.children(),i=a(window).width(),j=null,k=null,l=0,m=0,n=!1,o=0,p=\"\",q=0,r=e.vertical===!0?\"height\":\"width\",s=e.vertical===!0?\"margin-bottom\":\"margin-right\",t=0,u=0,v=0,w=0,x=null,y=\"ontouchstart\"in document.documentElement,z={};return z.chbreakpoint=function(){if(i=a(window).width(),e.responsive.length){var b;if(e.autoWidth===!1&&(b=e.item),ie.responsive[0].breakpoint)for(var g in f)f.hasOwnProperty(g)&&(e[g]=f[g]);e.autoWidth===!1&&t>0&&v>0&&b!==e.item&&(q=Math.round(t/((v+e.slideMargin)*e.slideMove)))}},z.calSW=function(){e.autoWidth===!1&&(v=(o-(e.item*e.slideMargin-e.slideMargin))/e.item)},z.calWidth=function(a){var b=a===!0?p.find(\".lslide\").length:h.length;if(e.autoWidth===!1)m=b*(v+e.slideMargin);else{m=0;for(var c=0;b>c;c++)m+=parseInt(h.eq(c).width())+e.slideMargin}return m},d={doCss:function(){var a=function(){for(var a=[\"transition\",\"MozTransition\",\"WebkitTransition\",\"OTransition\",\"msTransition\",\"KhtmlTransition\"],b=document.documentElement,c=0;c'+e.prevHtml+''+e.nextHtml+\"\"),e.autoWidth?z.calWidth(!1)"},{"title":"","date":"2018-11-09T14:09:21.503Z","updated":"2018-11-09T13:48:03.830Z","comments":true,"path":"lightslider/js/lightslider.js","permalink":"http://heartaway.cn/lightslider/js/lightslider.js","excerpt":"","text":"/*! lightslider - v1.1.5 - 2015-10-31 * https://github.com/sachinchoolur/lightslider * Copyright (c) 2015 Sachin N; Licensed MIT */ (function ($, undefined) { 'use strict'; var defaults = { item: 3, autoWidth: false, slideMove: 1, slideMargin: 10, addClass: '', mode: 'slide', useCSS: true, cssEasing: 'ease', //'cubic-bezier(0.25, 0, 0.25, 1)', easing: 'linear', //'for jquery animation',// speed: 400, //ms' auto: false, pauseOnHover: false, loop: false, slideEndAnimation: true, pause: 2000, keyPress: false, controls: true, prevHtml: '', nextHtml: '', rtl: false, adaptiveHeight: false, vertical: false, verticalHeight: 500, vThumbWidth: 100, thumbItem: 10, pager: true, gallery: false, galleryMargin: 5, thumbMargin: 5, currentPagerPosition: 'middle', enableTouch: true, enableDrag: true, freeMove: true, swipeThreshold: 40, responsive: [], /* jshint ignore:start */ onBeforeStart: function ($el) {}, onSliderLoad: function ($el) {}, onBeforeSlide: function ($el, scene) {}, onAfterSlide: function ($el, scene) {}, onBeforeNextSlide: function ($el, scene) {}, onBeforePrevSlide: function ($el, scene) {} /* jshint ignore:end */ }; $.fn.lightSlider = function (options) { if (this.length === 0) { return this; } if (this.length > 1) { this.each(function () { $(this).lightSlider(options); }); return this; } var plugin = {}, settings = $.extend(true, {}, defaults, options), settingsTemp = {}, $el = this; plugin.$el = this; if (settings.mode === 'fade') { settings.vertical = false; } var $children = $el.children(), windowW = $(window).width(), breakpoint = null, resposiveObj = null, length = 0, w = 0, on = false, elSize = 0, $slide = '', scene = 0, property = (settings.vertical === true) ? 'height' : 'width', gutter = (settings.vertical === true) ? 'margin-bottom' : 'margin-right', slideValue = 0, pagerWidth = 0, slideWidth = 0, thumbWidth = 0, interval = null, isTouch = ('ontouchstart' in document.documentElement); var refresh = {}; refresh.chbreakpoint = function () { windowW = $(window).width(); if (settings.responsive.length) { var item; if (settings.autoWidth === false) { item = settings.item; } if (windowW < settings.responsive[0].breakpoint) { for (var i = 0; i < settings.responsive.length; i++) { if (windowW < settings.responsive[i].breakpoint) { breakpoint = settings.responsive[i].breakpoint; resposiveObj = settings.responsive[i]; } } } if (typeof resposiveObj !== 'undefined' && resposiveObj !== null) { for (var j in resposiveObj.settings) { if (resposiveObj.settings.hasOwnProperty(j)) { if (typeof settingsTemp[j] === 'undefined' || settingsTemp[j] === null) { settingsTemp[j] = settings[j]; } settings[j] = resposiveObj.settings[j]; } } } if (!$.isEmptyObject(settingsTemp) && windowW > settings.responsive[0].breakpoint) { for (var k in settingsTemp) { if (settingsTemp.hasOwnProperty(k)) { settings[k] = settingsTemp[k]; } } } if (settings.autoWidth === false) { if (slideValue > 0 && slideWidth > 0) { if (item !== settings.item) { scene = Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove)); } } } } }; refresh.calSW = function () { if (settings.autoWidth === false) { slideWidth = (elSize - ((settings.item * (settings.slideMargin)) - settings.slideMargin)) / settings.item; } }; refresh.calWidth = function (cln) { var ln = cln === true ? $slide.find('.lslide').length : $children.length; if (settings.autoWidth === false) { w = ln * (slideWidth + settings.slideMargin); } else { w = 0; for (var i = 0; i < ln; i++) { w += (parseInt($children.eq(i).width()) + settings.slideMargin); } } return w; }; plugin = { doCss: function () { var support = function () { var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition']; var root = document.documentElement; for (var i = 0; i < transition.length; i++) { if (transition[i] in root.style) { return true; } } }; if (settings.useCSS && support()) { return true; } return false; }, keyPress: function () { if (settings.keyPress) { $(document).on('keyup.lightslider', function (e) { if (!$(':focus').is('input, textarea')) { if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; } if (e.keyCode === 37) { $el.goToPrevSlide(); } else if (e.keyCode === 39) { $el.goToNextSlide(); } } }); } }, controls: function () { if (settings.controls) { $el.after('' + settings.prevHtml + '' + settings.nextHtml + ''); if (!settings.autoWidth) { if (length elSize) { /**/ var tWr = 0, tI = 0; for (var k = 0; k < $children.length; k++) { tWr += (parseInt($el.find('.lslide').eq(k).width()) + settings.slideMargin); tI++; if (tWr >= (elSize + settings.slideMargin)) { break; } } var tItem = settings.autoWidth === true ? tI : settings.item; /**/ if (tItem < $el.find('.clone.left').length) { for (var i = 0; i < $el.find('.clone.left').length - tItem; i++) { $children.eq(i).remove(); } } if (tItem < $el.find('.clone.right').length) { for (var j = $children.length - 1; j > ($children.length - 1 - $el.find('.clone.right').length); j--) { scene--; $children.eq(j).remove(); } } /**/ for (var n = $el.find('.clone.right').length; n < tItem; n++) { $el.find('.lslide').eq(n).clone().removeClass('lslide').addClass('clone right').appendTo($el); scene++; } for (var m = $el.find('.lslide').length - $el.find('.clone.left').length; m > ($el.find('.lslide').length - tItem); m--) { $el.find('.lslide').eq(m - 1).clone().removeClass('lslide').addClass('clone left').prependTo($el); } $children = $el.children(); } else { if ($children.hasClass('clone')) { $el.find('.clone').remove(); $this.move($el, 0); } } }; refresh.clone(); } refresh.sSW = function () { length = $children.length; if (settings.rtl === true && settings.vertical === false) { gutter = 'margin-left'; } if (settings.autoWidth === false) { $children.css(property, slideWidth + 'px'); } $children.css(gutter, settings.slideMargin + 'px'); w = refresh.calWidth(false); $el.css(property, w + 'px'); if (settings.loop === true && settings.mode === 'slide') { if (on === false) { scene = $el.find('.clone.left').length; } } }; refresh.calL = function () { $children = $el.children(); length = $children.length; }; if (this.doCss()) { $slide.addClass('usingCss'); } refresh.calL(); if (settings.mode === 'slide') { refresh.calSW(); refresh.sSW(); if (settings.loop === true) { slideValue = $this.slideValue(); this.move($el, slideValue); } if (settings.vertical === false) { this.setHeight($el, false); } } else { this.setHeight($el, true); $el.addClass('lSFade'); if (!this.doCss()) { $children.fadeOut(0); $children.eq(scene).fadeIn(0); } } if (settings.loop === true && settings.mode === 'slide') { $children.eq(scene).addClass('active'); } else { $children.first().addClass('active'); } }, pager: function () { var $this = this; refresh.createPager = function () { thumbWidth = (elSize - ((settings.thumbItem * (settings.thumbMargin)) - settings.thumbMargin)) / settings.thumbItem; var $children = $slide.find('.lslide'); var length = $slide.find('.lslide').length; var i = 0, pagers = '', v = 0; for (i = 0; i < length; i++) { if (settings.mode === 'slide') { // calculate scene * slide value if (!settings.autoWidth) { v = i * ((slideWidth + settings.slideMargin) * settings.slideMove); } else { v += ((parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove); } } var thumb = $children.eq(i * settings.slideMove).attr('data-thumb'); if (settings.gallery === true) { pagers += ''; } else { pagers += '' + (i + 1) + ''; } if (settings.mode === 'slide') { if ((v) >= w - elSize - settings.slideMargin) { i = i + 1; var minPgr = 2; if (settings.autoWidth) { pagers += '' + (i + 1) + ''; minPgr = 1; } if (i < minPgr) { pagers = null; $slide.parent().addClass('noPager'); } else { $slide.parent().removeClass('noPager'); } break; } } } var $cSouter = $slide.parent(); $cSouter.find('.lSPager').html(pagers); if (settings.gallery === true) { if (settings.vertical === true) { // set Gallery thumbnail width $cSouter.find('.lSPager').css('width', settings.vThumbWidth + 'px'); } pagerWidth = (i * (settings.thumbMargin + thumbWidth)) + 0.5; $cSouter.find('.lSPager').css({ property: pagerWidth + 'px', 'transition-duration': settings.speed + 'ms' }); if (settings.vertical === true) { $slide.parent().css('padding-right', (settings.vThumbWidth + settings.galleryMargin) + 'px'); } $cSouter.find('.lSPager').css(property, pagerWidth + 'px'); } var $pager = $cSouter.find('.lSPager').find('li'); $pager.first().addClass('active'); $pager.on('click', function () { if (settings.loop === true && settings.mode === 'slide') { scene = scene + ($pager.index(this) - $cSouter.find('.lSPager').find('li.active').index()); } else { scene = $pager.index(this); } $el.mode(false); if (settings.gallery === true) { $this.slideThumb(); } return false; }); }; if (settings.pager) { var cl = 'lSpg'; if (settings.gallery) { cl = 'lSGallery'; } $slide.after(''); var gMargin = (settings.vertical) ? 'margin-left' : 'margin-top'; $slide.parent().find('.lSPager').css(gMargin, settings.galleryMargin + 'px'); refresh.createPager(); } setTimeout(function () { refresh.init(); }, 0); }, setHeight: function (ob, fade) { var obj = null, $this = this; if (settings.loop) { obj = ob.children('.lslide ').first(); } else { obj = ob.children().first(); } var setCss = function () { var tH = obj.outerHeight(), tP = 0, tHT = tH; if (fade) { tH = 0; tP = ((tHT) * 100) / elSize; } ob.css({ 'height': tH + 'px', 'padding-bottom': tP + '%' }); }; setCss(); if (obj.find('img').length) { if ( obj.find('img')[0].complete) { setCss(); if (!interval) { $this.auto(); } }else{ obj.find('img').load(function () { setTimeout(function () { setCss(); if (!interval) { $this.auto(); } }, 100); }); } }else{ if (!interval) { $this.auto(); } } }, active: function (ob, t) { if (this.doCss() && settings.mode === 'fade') { $slide.addClass('on'); } var sc = 0; if (scene * settings.slideMove < length) { ob.removeClass('active'); if (!this.doCss() && settings.mode === 'fade' && t === false) { ob.fadeOut(settings.speed); } if (t === true) { sc = scene; } else { sc = scene * settings.slideMove; } //t === true ? sc = scene : sc = scene * settings.slideMove; var l, nl; if (t === true) { l = ob.length; nl = l - 1; if (sc + 1 >= l) { sc = nl; } } if (settings.loop === true && settings.mode === 'slide') { //t === true ? sc = scene - $el.find('.clone.left').length : sc = scene * settings.slideMove; if (t === true) { sc = scene - $el.find('.clone.left').length; } else { sc = scene * settings.slideMove; } if (t === true) { l = ob.length; nl = l - 1; if (sc + 1 === l) { sc = nl; } else if (sc + 1 > l) { sc = 0; } } } if (!this.doCss() && settings.mode === 'fade' && t === false) { ob.eq(sc).fadeIn(settings.speed); } ob.eq(sc).addClass('active'); } else { ob.removeClass('active'); ob.eq(ob.length - 1).addClass('active'); if (!this.doCss() && settings.mode === 'fade' && t === false) { ob.fadeOut(settings.speed); ob.eq(sc).fadeIn(settings.speed); } } }, move: function (ob, v) { if (settings.rtl === true) { v = -v; } if (this.doCss()) { if (settings.vertical === true) { ob.css({ 'transform': 'translate3d(0px, ' + (-v) + 'px, 0px)', '-webkit-transform': 'translate3d(0px, ' + (-v) + 'px, 0px)' }); } else { ob.css({ 'transform': 'translate3d(' + (-v) + 'px, 0px, 0px)', '-webkit-transform': 'translate3d(' + (-v) + 'px, 0px, 0px)', }); } } else { if (settings.vertical === true) { ob.css('position', 'relative').animate({ top: -v + 'px' }, settings.speed, settings.easing); } else { ob.css('position', 'relative').animate({ left: -v + 'px' }, settings.speed, settings.easing); } } var $thumb = $slide.parent().find('.lSPager').find('li'); this.active($thumb, true); }, fade: function () { this.active($children, false); var $thumb = $slide.parent().find('.lSPager').find('li'); this.active($thumb, true); }, slide: function () { var $this = this; refresh.calSlide = function () { if (w > elSize) { slideValue = $this.slideValue(); $this.active($children, false); if ((slideValue) > w - elSize - settings.slideMargin) { slideValue = w - elSize - settings.slideMargin; } else if (slideValue < 0) { slideValue = 0; } $this.move($el, slideValue); if (settings.loop === true && settings.mode === 'slide') { if (scene >= (length - ($el.find('.clone.left').length / settings.slideMove))) { $this.resetSlide($el.find('.clone.left').length); } if (scene === 0) { $this.resetSlide($slide.find('.lslide').length); } } } }; refresh.calSlide(); }, resetSlide: function (s) { var $this = this; $slide.find('.lSAction a').addClass('disabled'); setTimeout(function () { scene = s; $slide.css('transition-duration', '0ms'); slideValue = $this.slideValue(); $this.active($children, false); plugin.move($el, slideValue); setTimeout(function () { $slide.css('transition-duration', settings.speed + 'ms'); $slide.find('.lSAction a').removeClass('disabled'); }, 50); }, settings.speed + 100); }, slideValue: function () { var _sV = 0; if (settings.autoWidth === false) { _sV = scene * ((slideWidth + settings.slideMargin) * settings.slideMove); } else { _sV = 0; for (var i = 0; i < scene; i++) { _sV += (parseInt($children.eq(i).width()) + settings.slideMargin); } } return _sV; }, slideThumb: function () { var position; switch (settings.currentPagerPosition) { case 'left': position = 0; break; case 'middle': position = (elSize / 2) - (thumbWidth / 2); break; case 'right': position = elSize - thumbWidth; } var sc = scene - $el.find('.clone.left').length; var $pager = $slide.parent().find('.lSPager'); if (settings.mode === 'slide' && settings.loop === true) { if (sc >= $pager.children().length) { sc = 0; } else if (sc < 0) { sc = $pager.children().length; } } var thumbSlide = sc * ((thumbWidth + settings.thumbMargin)) - (position); if ((thumbSlide + elSize) > pagerWidth) { thumbSlide = pagerWidth - elSize - settings.thumbMargin; } if (thumbSlide < 0) { thumbSlide = 0; } this.move($pager, thumbSlide); }, auto: function () { if (settings.auto) { clearInterval(interval); interval = setInterval(function () { $el.goToNextSlide(); }, settings.pause); } }, pauseOnHover: function(){ var $this = this; if (settings.auto && settings.pauseOnHover) { $slide.on('mouseenter', function(){ $(this).addClass('ls-hover'); $el.pause(); settings.auto = true; }); $slide.on('mouseleave',function(){ $(this).removeClass('ls-hover'); if (!$slide.find('.lightSlider').hasClass('lsGrabbing')) { $this.auto(); } }); } }, touchMove: function (endCoords, startCoords) { $slide.css('transition-duration', '0ms'); if (settings.mode === 'slide') { var distance = endCoords - startCoords; var swipeVal = slideValue - distance; if ((swipeVal) >= w - elSize - settings.slideMargin) { if (settings.freeMove === false) { swipeVal = w - elSize - settings.slideMargin; } else { var swipeValT = w - elSize - settings.slideMargin; swipeVal = swipeValT + ((swipeVal - swipeValT) / 5); } } else if (swipeVal < 0) { if (settings.freeMove === false) { swipeVal = 0; } else { swipeVal = swipeVal / 5; } } this.move($el, swipeVal); } }, touchEnd: function (distance) { $slide.css('transition-duration', settings.speed + 'ms'); if (settings.mode === 'slide') { var mxVal = false; var _next = true; slideValue = slideValue - distance; if ((slideValue) > w - elSize - settings.slideMargin) { slideValue = w - elSize - settings.slideMargin; if (settings.autoWidth === false) { mxVal = true; } } else if (slideValue < 0) { slideValue = 0; } var gC = function (next) { var ad = 0; if (!mxVal) { if (next) { ad = 1; } } if (!settings.autoWidth) { var num = slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove); scene = parseInt(num) + ad; if (slideValue >= (w - elSize - settings.slideMargin)) { if (num % 1 !== 0) { scene++; } } } else { var tW = 0; for (var i = 0; i < $children.length; i++) { tW += (parseInt($children.eq(i).width()) + settings.slideMargin); scene = i + ad; if (tW >= slideValue) { break; } } } }; if (distance >= settings.swipeThreshold) { gC(false); _next = false; } else if (distance = settings.swipeThreshold) { $el.goToPrevSlide(); } else if (distance xMovement) { e.preventDefault(); } $this.touchMove(endCoords.pageY, startCoords.pageY); } else { if ((xMovement * 3) > yMovement) { e.preventDefault(); } $this.touchMove(endCoords.pageX, startCoords.pageX); } }); $slide.on('touchend', function () { if (w < elSize) { if (w !== 0) { return false; } } var distance; if (settings.vertical === true) { distance = endCoords.pageY - startCoords.pageY; } else { distance = endCoords.pageX - startCoords.pageX; } $this.touchEnd(distance); }); } }, build: function () { var $this = this; $this.initialStyle(); if (this.doCss()) { if (settings.enableTouch === true) { $this.enableTouch(); } if (settings.enableDrag === true) { $this.enableDrag(); } } $(window).on('focus', function(){ $this.auto(); }); $(window).on('blur', function(){ clearInterval(interval); }); $this.pager(); $this.pauseOnHover(); $this.controls(); $this.keyPress(); } }; plugin.build(); refresh.init = function () { refresh.chbreakpoint(); if (settings.vertical === true) { if (settings.item > 1) { elSize = settings.verticalHeight; } else { elSize = $children.outerHeight(); } $slide.css('height', elSize + 'px'); } else { elSize = $slide.outerWidth(); } if (settings.loop === true && settings.mode === 'slide') { refresh.clone(); } refresh.calL(); if (settings.mode === 'slide') { $el.removeClass('lSSlide'); } if (settings.mode === 'slide') { refresh.calSW(); refresh.sSW(); } setTimeout(function () { if (settings.mode === 'slide') { $el.addClass('lSSlide'); } }, 1000); if (settings.pager) { refresh.createPager(); } if (settings.adaptiveHeight === true && settings.vertical === false) { $el.css('height', $children.eq(scene).outerHeight(true)); } if (settings.adaptiveHeight === false) { if (settings.mode === 'slide') { if (settings.vertical === false) { plugin.setHeight($el, false); }else{ plugin.auto(); } } else { plugin.setHeight($el, true); } } if (settings.gallery === true) { plugin.slideThumb(); } if (settings.mode === 'slide') { plugin.slide(); } if (settings.autoWidth === false) { if ($children.length"}],"posts":[{"title":"Capture Html Content After Render","slug":"Java/2017-09-21-phantomjs-use","date":"2018-11-09T13:48:02.844Z","updated":"2018-11-09T13:48:02.844Z","comments":true,"path":"2018/11/09/Java/2017-09-21-phantomjs-use/","link":"","permalink":"http://heartaway.cn/2018/11/09/Java/2017-09-21-phantomjs-use/","excerpt":"","text":"在前端技术越来越注重用户体验的潮流下，异步数据渲染组件成为主流，但是异步渲染给爬虫和相关需要使用页面异步渲染后Dom结构的需求来说，变得很麻烦。要想获取渲染后的页面内容，常见的方法有： 使用类似于PhantomJS的Headless浏览器，模拟页面渲染，获取页面HTML； 分析Ajax请求，获取请求后的数据。 对于千变万化的页面结构来说，第一种方法更具备通用性，首选需要安装PhantomJS，然后编写js脚本，最后就是运行脚本获取结果啦。 比如我编写了一个loadPage.js,用于支持页面截图或者页面渲染后的HTML结构获取： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102var args = require('system').args;var page = require('webpage').create();var fs = require('fs');var url;var fileName = \"\";var cookieJson = \"\";var type = \"html\";var viewWidth = 1024;var viewHeight = 768;args.forEach(function(arg, i) &#123; if(i === 1)&#123; url = arg; &#125; if(i === 2)&#123; type = arg; &#125; if(i === 3)&#123; fileName = arg; &#125; if(i === 4)&#123; cookieJson = arg; &#125; if(i === 5)&#123; viewWidth = arg; &#125; if(i === 6)&#123; viewHeight = arg; &#125;&#125;);page.viewportSize = &#123; width: viewWidth, height:viewHeight &#125;;if(cookieJson != null &amp;&amp; cookieJson != \"\")&#123; var cookieArray = JSON.parse(cookieJson); for (var i = 0; i &lt; cookieArray.length; i++) &#123; var cookieObj = cookieArray[i]; var cookie = &#123; 'name' : cookieObj.name, 'value' : cookieObj.value, 'path' : cookieObj.path, 'domain' : cookieObj.domain, 'expires' : cookieObj.expires &#125;; phantom.addCookie(cookie); &#125;&#125;page.onError = function(msg, trace) &#123; console.log(\"[Warning]This is page.onError\"); var msgStack = ['ERROR: ' + msg]; if (trace &amp;&amp; trace.length) &#123; msgStack.push('TRACE:'); trace.forEach(function(t) &#123; msgStack.push(' -&gt; ' + t.file + ': ' + t.line + (t.function ? ' (in function \"' + t.function +'\")' : '')); &#125;); &#125; // console.error(msgStack.join('\\n'));&#125;;phantom.onError = function(msg, trace) &#123; console.log(\"[Warning]This is phantom.onError\"); var msgStack = ['PHANTOM ERROR: ' + msg]; if (trace &amp;&amp; trace.length) &#123; msgStack.push('TRACE:'); trace.forEach(function(t) &#123; msgStack.push(' -&gt; ' + (t.file || t.sourceURL) + ': ' + t.line + (t.function ? ' (in function ' + t.function +')' : '')); &#125;); &#125; console.error(msgStack.join('\\n')); phantom.exit(1);&#125;;page.onLoadFinished = function() &#123; setTimeout(function()&#123; if(type == \"image\")&#123; page.render(fileName,&#123;format: 'jpg', quality: '100'&#125;); console.log(\"render page finished: \" + url); &#125; if(type == \"html\")&#123; fs.write(fileName, page.content, 'w'); console.log(\"page html gen success: \" + url); &#125; phantom.exit(); &#125;,5000);&#125;;page.open(url, function (status) &#123; if (status === \"success\") &#123; console.log(\"load status: \" + status); &#125;else&#123; phantom.exit(); &#125;&#125;); 服务端通过Process类调用Linux中的shell脚本，运行截图或者页面渲染服务，然后把获取到的结果存储到文件存储系统中，返回文件存储的地址URL给业务方，业务方通过URL访问原始数据，减少网络数据传输。 123456789String type = \"html\";String[] params = new String[] &#123;DiamondUtil.getPhantomJsPath(), DiamondUtil.getCaptureJsPath(), url,type , htmlName, cookieJson&#125;; ShellUtil.executeShell(params, \" capture url \" + url); File htmlFile = new File(defaultFilePath(htmlName)); if (checkFileEixst(htmlFile)) &#123; String htmlOssUrl = fileService.updateObjectToOss(htmlName, htmlFile); &#125; ShellUtil中的运行代码： 1234567891011121314151617181920212223242526272829303132333435public static void executeShell(String[] params, String message) throws Exception &#123; Process process = null; BufferedReader stdBufferedReader = null; BufferedReader errorBufferedReader = null; try &#123; ProcessBuilder pb = new ProcessBuilder(params); pb.directory(new File(DiamondUtil.getCaptureImagePath())); pb.redirectErrorStream(true); process = pb.start(); stdBufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream())); errorBufferedReader = new BufferedReader(new InputStreamReader(process.getErrorStream())); String line; while ((line = stdBufferedReader.readLine()) != null) &#123; logger.info(message + \":\" + line); &#125; while ((line = errorBufferedReader.readLine()) != null) &#123; logger.error(message + \":\" + line); &#125; process.waitFor(); &#125; catch (Exception e) &#123; logger.error(message, e); &#125; finally &#123; if (stdBufferedReader != null) &#123; stdBufferedReader.close(); &#125; if (errorBufferedReader != null) &#123; stdBufferedReader.close(); &#125; if (process != null) &#123; process.destroy(); &#125; &#125; &#125; 在截图服务中，首次出现了中文乱码，网上有同学说安装bitmap-fonts，但是并不好使，建议删除： 1sudo yum remove bitmap-fonts bitmap-fonts-cjk 网页查看我们使用的字体内容： 1...&#123; ... font-family: Helvetica, arial, \"microsoft yahei\", Monaco, sans-serif; ...&#125; 可以看到有 多种字体，最后的 sans-serif 默认对应是黑体，需要把这5种字体装到截图的 Linux 服务器，分别从osx和windows上copy出来，注意一下，osx 中的字体是 .ttc 和 .dfont 格式的，我们 可以借助 http://transfonter.org/ttc-unpack来转换为 Linux 支持的 .ttf 的格式。 把这些文件拷到 Linux 服务器上，然后调用 fc-cache 更新一下 1sudo mkdir /usr/share/fonts/customsudo cp *.ttf /usr/share/fonts/customfc-cache -fv","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"他人经受的，我必经受","slug":"Think/2018-10-06-marriage-quarrel","date":"2018-10-05T16:00:00.000Z","updated":"2018-11-09T14:28:31.146Z","comments":true,"path":"2018/10/06/Think/2018-10-06-marriage-quarrel/","link":"","permalink":"http://heartaway.cn/2018/10/06/Think/2018-10-06-marriage-quarrel/","excerpt":"","text":"早上起床后，悠然自得地在阳台上晒着太阳看着柴静的《看见》这本书。突然楼上吵架吵的甚是厉害，这已经不是第一次听到楼上吵架了，每次都是伴随着咕咕嘟嘟的物品跌落到地板上声音、妇女歇斯底里的呼喊声、小孩声嘶力竭的哇哇哭闹声、间歇性的愤怒的男性咆哮声。 这一次吵闹的比之前几次都要凶，我感觉不太对劲，打开门，走上楼梯，准备去帮他们和解一下，心想：毕竟是一家人，没必要闹到这个份上。当我走到楼上时，女主站在门外，朝着门内哭喊道“你为什么打我，我出来没有打过你，你为什么打我”，他们的门没关，我看到他们玄关的台面上堆满了书籍，放不下的书籍已经被实实在在的塞在了竖立起来的书层上面，想必也是一定程度上的知识分子，我刚准备去拦架，就听到女主对着门外吼道：“我是在受不了你了，你给我走”，听到这些，我的脚步迈不开了，感觉自己想好的劝解的话不一定能凑效，反而可能让他们觉得不堪的场面，此刻他们需要的是冷静，然后控制住自己的情绪。 我重新回到阳台，继续翻看书籍《看见》，正好看到讲述十几位女性因为无法忍受自己的丈夫而杀害丈夫的故事，调查中的大部分女性都是在无数次沉默忍耐之后才爆发了最后的还击。我从小也经历过父亲喝醉酒，发了疯似的，拿着砍刀要杀人，当时母亲哭泣着抱着我躲在房间的角落里，我至今还清晰的记得那门框旁边残留的被刀砍下的凹痕；母亲的性格是那种凡事都隐忍，不主动把事情摊开来说的那种，我之前还嘲笑母亲懦弱的性格，后来我才明白这是“恐惧留下的阴影”，一个没有当过弱者的人，不会体会到这种恐惧。那些女犯人之所以环击，正是因为恐惧的一层层积累，积累到一定程度后，就会以暴力的方式爆发。 “叮咚，叮咚”，一阵门铃响声打断了我的思绪，我打开门，看到是天猫超市的配送员，他说打我手机没人接，担心我家的东西又丢了，现在都不敢放门口了，听到楼上的吵闹神，他说：“我也是离过婚的人，一个人来到异地杭州，无依无靠”。我不知道该说回答他，脑子中对婚姻这件事有了缕缕疑惑。 楼上的声音渐渐消停了下来，我也看到这篇报道的结尾了，结尾处柴静写到“他人经受的，我必经受”。在最近的几年里，我愈发的明白一个道理，那就是：==不要随意地站在自我的立场上使用自己那有限的人生经历去揣测与评判别人的人生，我们不曾经历过的一切都让我们的评论显得格外肤浅。== 此时，老婆问我，“我们如果吵架了，你会怎么样？”，我笑了笑。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"如何解决技术焦虑","slug":"Think/2018-04-13-how-to-resolve-tech-anxious","date":"2018-04-12T16:00:00.000Z","updated":"2018-11-09T14:28:42.230Z","comments":true,"path":"2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/","link":"","permalink":"http://heartaway.cn/2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/","excerpt":"","text":"从事软件编程已经长达8年之后，曾经中间有很长一段时间感觉自己的技术能力没有得到根本性提升，与那些优秀的同龄人相比，技术自卑油然而生，面对日新月息的技术变更和时不我待的岁月流逝，步入中年的我不得不变的焦虑起来。回顾自己的编程生涯，刚毕业的头几年，通过自主学习实现了编程语言的基本掌握，紧接着使用学到的技术完成各种项目，然后日复一日，有时候也会看看技术书籍，但是终究未能突破语言层而知晓技术背后的本质。而后通过长时间的摸索与交流，寻找到了一些解决技术人技术焦虑的方法，这些问题和方法更多的是一种思维方式，一种看问题的视角，希望这些建议能够让我们有所收获和思考。 技术焦虑的起因技术热情变低有人说：职业倦怠是做了大量重复劳动缺乏调整，或者努力完成高风险问题最后却以失败告终而导致的。在软件行业，接触了很多人，发现一开始大家对技术都非常热情，当把它编程职业后，时间一长，就索然无味了，但是又不得不从事这个行业，毕竟还要养家糊口。缺乏热情，可能是我们进入了瓶颈期，在大量重复劳动当中，自然提不起什么兴趣。我们可以有两种方法破局：1. 主要要求承担自己感兴趣又没做过的事情。阿里有一句老话，“今天最好的表现是明天最低的要求”，我们要时刻突破自己所在的“舒适区”，让自己跳跃到“学习区”。2. 为自己而工作。为别人工作就很容易消耗的我们的热情，如果我们转变思路，把学习工作转变为为自己工作，就会有所动力。我过观察到的是，那些在专业领域上付出了极大热情的人，往往因为这个工作领域的投入而成就了自己的影响力，难道这不是在为自己工作，为自己打造信用背书，为自己打造个人品牌吗。 新技术层出不穷新技术的迭代更新速度远远超过了我们获取新知识的速度，然而我们并没有过多时间去深入学习每一门技术。当我们还没有把Java并发包下的每一个核心类的原理弄清楚的时候，Java库已经从7升级到了10，我们还在谈服务化的时候，微服务、ServiceMesh、Serverless、FaaS这些新技术迎面而来，让我们应接不暇。工作多年的你，想一想，自己多久没有利用业余时间系统性的学习一门新技术了，我们往往以为通过多看微信朋友圈中的技术转发帖就能获取精华知识，以为我们自己在学习，其实这只是我们在安慰我们那颗想学习有不想付出太多精力的心而已。 加班太多，没时间学习在之前离开阿里出去创业的几年时间里，几乎把能用的时间都用在了做业务系统，有很长一段时间，每天工作12小时以上，一周工作6天，深切能体会到长时间做业务系统的研发那种迫不得已。在面对各种Deadline时，我们做技术调研、技术方案也就马马虎虎过去了，恨不得一拿到需求就开始编码，每天拼命加班完成那些似乎并不那么重要的需求，反而搁浅了那些更重要的事情。一接到任务就开始 Coding 的程序员，通常就是加班最多的程序员，切记积极工作和勤于思考都要占时间。加班占用了我们太多的精气神，即便是有一时的闲暇，也想着让疲惫的身心得到一丝舒缓，哪再有学习的动力，我们似乎陷入已经坠入了加班与没有时间学习带来的焦虑陷阱。 有一些团队文化中，非常推崇加班文化，甚至开始攀比谁加班多，似乎谁加班多谁付出就多绩效就好。我曾经竟然可笑的认为通过加班付出的越多，自己的价值也就越大，团队也就越信任你，其实这是非常错误的思维，常态加班只能证明我们不会选择或者效率低下。考核一个人对业务和团队付出多少是拿业务结果来说话的，并不是那加班。认真想一想通过加班透支太多个人时间这件事情，我们为什么要加班？我们之所以加班，是因对之前承诺的内疚；加班让我们成为了一个只会低头做事情的人，让我们缺少了抽身看全局的机会。从时间投资的角度讲，常态加班，也是对我们自身时间的极大浪费，我们应该学会选择，学会拒绝，学会借力，做最重要的事情，给自己预留空闲时间，用来做自己喜欢做的事情。 解决技术焦虑在意识在自我对技术的焦虑后，开始关注如何解决这种焦虑感，解铃还须系铃人，那些往往让我们害怕或者恐慌的东西才是我们需要去弥补的。技术焦虑也是一样，是一种技术不自信，是自己技术上有很多短板和盲区，伴随着中年危机的到来，害怕因为专业性的不成熟而被整个行业淘汰。去年华为去大龄码农，去的正是那些不能提供技术专业性的员工。解决办法自然是通过沉下心来，慢慢的把基础中的短板不起来，拓宽自己知识宽度的同时，挖掘技术深度。在整个学习过程中，一些几点也许能让我们跟轻松跟高效的来面对技术的学习以及技术焦虑的消除。 寻找兴趣点很多时候，技术之所以对我们的吸引力不够，不能让我们为之废寝忘食的一个原因，那就是我们没有找到一个自己感兴趣的点。比如，我之前有一段时间对技术几乎麻木了，没有任何动力去翻看技术文章，遇到大家都转载的博文，也就是顺手收藏起来，明知道自己不会再看，还是自我安慰到兴许后续会有时间学习，一年下来技术基本没什么积累，我甚至开始怀疑自己是否适合程序员的岗位。直到有一天，朋友向我推荐了一本书《编码·隐匿在计算机背后的语言》，这本书从手电筒开合讲到继电器编解码，再讲到计算机的构造，让我大跌眼镜，以前觉得计算机非常高深莫测，看完这本书之后才觉得原来如此，我竟然有了在淘宝上购买继电器回家自己一台计算机的冲动。应用举一反三以及类比的方法，把“编码”、“解码”的思维应用在生活的各个细节当中，发现很多道理都是想通的。有人对它的评价是“这本书花两个半天读上一般的内容，你的人生就赚到了”。 自此，我似乎重新拾起了对计算机的兴趣。然后重新找回一些计算机理论知识中的经典书籍，一本一本开始看，以前觉得深不可测、遥不可及的知识点，掌握其理念之后，觉得也就那么回事。所谓技术自信，就是自身具备盖世武功，面对对手的花样进攻，坦然处之了的心态。 调整学习方式作为一名技术从业者，“终身学习”的道理自然不必多讲。那如何学习呢，学习有哪些方式呢？这个问题我出来没有认真考虑过，难道还有人不会学习吗？引发我对学习方式的思考，是源于跟同事的一次闲聊。同事说“我喜欢整体性学习，对一门新技术，势必先全部通读一遍，然后知晓其原理在开始编码，防坑，可控性更强”，我想了想我的学习方式，说“我自己属于模仿性学习，现学现用，不懂就查”；为什么会有这两种学习方式呢？他们之间有什么区别，哪一种效率更高呢？带着这些疑问，我查阅了《如何高效学习》、李善友老师的《混沌大学》、许岑老师的《如何成为有效学习的高手》、小马宋的《朋友圈的尖子生》等多本有关学习方法的书，最后得出一个结论：一切事情都有方法论或套路，我们需要看清楚变化事物背后不变的本质。所谓套路，就是大家从历史中总结出来的可复制的经验，我们每一个个体按照套路行事，也能学会的东西。比如围棋的定式、程序中的算法、设计模式、菜谱等等，这些都称得上是套路。 那学习方式目前主要分为两类，一类是自然主义学习；一类是结构主义学习。自然主义学习是基于模仿，通过向他人学习然后进行自我实践，比如我们学习说话、绘画、溜冰、弹钢琴等；而结构主义学习是系统性的构建并创造新的知识晶体，比如数学、物理、编程。针对学习任务的不同，采用合适的学习方法能让我们学习效率事半功倍。在回过来看看自己过往在软件编程上的学习策略，一直是在是在基于点的模仿性学习，而非像结构主义学习那样，讲究面，讲究整体性和系统性。只知道各个点的弊端是让我们看不到面的边界，不知道还有多少我们看不到，这不仅给我让我们对技术产生焦虑，也让自己的视野变得越来越窄；看似每天很努力的工作和学习，其实效率不高、结果不好正是这个原因。所以，面对编程技术的学习，做好的做法是结构化学习，拿整块的时间来学、系统的学，学习技术的历史背景、技术的核心思想、技术的使用范围以及边界，然后再通过自然主义学习策略下的模仿进行逐步实践，方能让我们更快更好的获取到知识。 看清事情本质我们重复编码了多年，还是不得要领，就像学习了各种武功，还是无法突破招数的局限一样，这可能就是我们只知道使用技术，而忽略了技术背后真正的核心思想。在过去一年中，我面试了很多的同学，发现很多技术从业者都有一个共性，那就是只会基本使用，不知其实现原理，即便有一些知晓原理，稍微变通一下后，就无法应答，说明还是理解不深。其实计算机技术知识跟其它门类的只是也是一样的，总有一个核心思想在里面，比如《论语》的核心就是“仁”和“礼”，《孙子兵法》中的借刀杀人的核心就是“敌已明,友未定,引友杀敌,不自出力”。 那么计算机编程的核心思想是什么呢？是那些变化多端的设计模式，是不断演化的架构形式？这些都不是，我查阅多本资料，发现其本质是 “程序 = 算法 + 结构”，然后拿着这个本质在去看spring 源码、Mybatis源码，寻找他们实现的核心数据结构是什么，算法又是什么，使用了什么套路(设计模式)，在横向上跟其它技术做一下比对。比如spring中有缓存、Mybatis中有两段缓存、数据库有缓存、Redis分布式缓存、操作系统有缓存、CPU有缓存，为什么要使用缓存，这些缓存实现之间有什么共同之处？这还只是局限在编程里面，在现实世界中是不是到处都有缓存的实例呢，比如我们背诵各种诗词歌赋或者数据乘法表，以便在大脑中缓存这些知识，要得就是在最短的时间提取出答案，即便是占用大脑的一些记忆空间。再比如我们去食堂吃饭排队，这个队列是FIFO还是具有优先级的队列，如果队列为空了，打饭的是否是不是处于阻塞状态，如果队列满了，后来的人怎么办？当我们从学习的事情中进行抽象化，看到事情的本质后，在进行举一反三，多领域多维度验证，我们就会觉得“大道至简”，很多道理都是相同的，即便复杂如计算机系统也是一样。 当然除了看清楚技术的本质，我们在团队沟通协作当中也是需要应用这一思维，比如一个人发表了一个观点，那我们就应该想一想他说出这个观点的本意是什么，他是怎么想的，为什么会提出这样观点，这个观点的核心理念是什么，如果我们要说服他改变观点，我们要怎么做。在日常生活当中多刻意练习这一思维习惯，并通过与当事人的正面沟通寻求其真实本意的想法来及时矫正自己的思维模式（及时反馈），时间一长，习惯就培养出来了，这个时候，我们说话办事就不会再冲动和肤浅了。 独立思考伴随着长大，让我们逐渐养成了“趋利避害”的行为习惯，原本自身上的各种棱角也被残酷的现实社会磨得异常圆滑，在各种决策中，我们似乎养成了随大流的习惯；学习技术，我们跟大流，别人学什么，我们也学什么；离职创业，在我们还没有想清楚自己是不是合适的时候，总理说“万众创业、大众创新” ，我们就投入到了创业的大潮当中；我们似乎活在了别人的思维模式下。那我们自己也有大脑，为什么就不能好好想一想自己目前的处境，未来的规划呢？ 思考本身就是一件苦差事，我们身体的本能就是尽量大脑降低负荷，能不动脑就不动脑，我们要克服这种情况，如果大脑长时间不用，就会退化，让我们成为独立个体的正式我们透过独立思考展示出来的人格魅力。 我之前老板有一个习惯，就是每天吃完晚饭后，回到工作岗位上，给自己预留半个小时，让自己处于冥想状态，思考自己当前在做什么，为什么做，需求本质是什么，能不能不做，做的怎么样，是不是有更高效的做法，同行业是怎么做的，整个市场是怎么样的，未来三到五年会有什么变化。 他建议我也尝试此方法，我在尝试此方法之前，就感觉每天忙忙碌碌，也不知道为什么忙，做日常工作似乎只是为了生计或者不得不做，通过这样的训练，发现自己成为了这件事情的主人，看到了很多之前不曾看到的东西，之前只能这低头走路，看路好不好走，而忽略了路的方向以及路边精彩的风景。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Mybatis 核心理念","slug":"Java/2018-04-09-mybatis-core-thought","date":"2018-04-08T16:00:00.000Z","updated":"2018-11-09T14:24:37.642Z","comments":true,"path":"2018/04/09/Java/2018-04-09-mybatis-core-thought/","link":"","permalink":"http://heartaway.cn/2018/04/09/Java/2018-04-09-mybatis-core-thought/","excerpt":"","text":"Mybatis的本质：混合型Java对象持久化工具； 前置说明：需要提前具备SQL、JDBC、RDBMS、XML、OOP等知识； 什么是Mybatis：核心点： 支持了SQL、存储过程、对象/关系映射的持久化框架； 消除了几乎所有的JDBC代码和需要手工处理的参数和结果； 支持XML和注解两种方式来配置sqlmap、mapper、pojo三者之间的关系。 Mybatis理念：坚信SQL、RDBMS将继续使用30年； Mybatis 核心概念数据模型： Configuration SqlSessionFactory SqlSession MappedStatement 运行期四大组件： Executor StatementHandler ParameterHandler ResultSetHandler 算法： Java静态&amp;动态代理 待补充 Mybatis 发展历程ibatis → mybatis ibatis 于2002年由 Clinton Begin创建；ibatis 于2010年暂停维护，专有apache维护，改名为mybatis，版本定位mybatis 3； Mybatis 工作流程​ （选自CSDN：亦山） Mybatis 中的设计思想 外部化SQL&amp;参数配置化，将设置与运行策略分离； 采用配置化原因：降低编码复杂度，提高可读性和可维护性； 封装SQL；基于接口编程，屏蔽SQL对外部的具体实现； 随处可见的工厂模式、builder模式、Proxy模式、装饰器模式； 将大系统设计为多个子系统，每个子系统的功能相对集中，尽可能将那些需要由不同的开发角色处理的任务分离开来。 Cache的实现模式：链式静态代理，原始对象PerpetualCache； 代理模式三要素：共同接口，真实对象、代理对象（装饰器模式）； 我们可以采用对象工程屏蔽代理类的生成； 静态代理的本质：不侵入代码的情况下，扩展原对象功能； Plugin实现采用Java动态代理方式，责任链模式实现； 基于注解或者路径的自动扫描； Mybatis主要功能 使用XML或Java API配置Mybatis 使用XML或注解配置SQL映射器（Mapper） 基于OGNL表达式的动态SQL构建 事务支持 Executor层次 CachingExecutor 是正式Executor实现类的一个代理wrapper。 动态SQL4个核心关键词: if choise(when,otherwise) trim（where,set） foreach 缓存体系 本地缓存； 作用域：SqlSession内数据本地缓存； 数据结构：PerpetualCache （HashMap） 作用：利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 配置： localCacheScope=STATEMENT|SESSION设置作用域，建议使用STATEMENT，防止分布式环境下导致的脏读； 二级缓存 作用域：namespace；SqlSession间数据缓存； 默认底层缓存结构：LruCache包装的PerpetualCache 选择：在分布式环境下，建议使用外部分布式缓存系统，而非Mybatis的本地缓存； 作用域：scope SqlSessionFactory 建议应用级别； SqlSession 请求或方法级别（非线程安全）； Mapper Instance 方法级别； 与Spring集成下回详解； 官方文档:http://www.mybatis.org/spring/index.html 版本说明：http://www.mybatis.org/spring/index.html 工程示例：大家可以基于测试工程自行联系相关设计理念以及工作原理： https://github.com/heartaway/mybatis-study-demo 参考文档:http://www.mybatis.org/mybatis-3/zh/configuration.html http://www.mybatis.org/spring/index.html https://blog.csdn.net/column/details/mybatis-principle.html 《iBatis实战》","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"阿里云多机房部署网络架构","slug":"HighAvailability/2018-03-29-aliyun-mutil-region","date":"2018-03-28T16:00:00.000Z","updated":"2018-11-09T14:17:55.179Z","comments":true,"path":"2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/","link":"","permalink":"http://heartaway.cn/2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/","excerpt":"","text":"","categories":[{"name":"HighAvailability","slug":"HighAvailability","permalink":"http://heartaway.cn/categories/HighAvailability/"}],"tags":[]},{"title":"POJO 对象setter 方法是否合适return \"this\"","slug":"Java/2018-03-22-java-bean-setter-return","date":"2018-03-21T16:00:00.000Z","updated":"2018-11-09T14:24:30.095Z","comments":true,"path":"2018/03/22/Java/2018-03-22-java-bean-setter-return/","link":"","permalink":"http://heartaway.cn/2018/03/22/Java/2018-03-22-java-bean-setter-return/","excerpt":"","text":"通常的POJO对象setter方法return 为void 123public void setStatus(String status) &#123; this.status = status;&#125; 但是面对对象属性填充时，一堆的set方法让代码看起来很臃肿，部分同学采用类build模式，对setter方法进行改造，改造后就可以使用链式处理简化属性设置； 1234public Employee setName(String name) &#123; this.name = name; return this;&#125; 流式编码风格如： 1new Employee().setName(\"Xin yuan\").setHeight(178); 有人认为这让pojo方法设置变得更加便捷，有其使用之处，但是也有人认为return this打破了Java Bean的规约，破坏了每个函数单一职责的原则，也可能会破坏一些工具库的使用，或组织JVM做一些优化。而且在IDE中getter&amp;setter的自动生成内容中并没有“return this”。综其所述，setter方法“return this”并不建议。 当然还有其它选择方案： 方法一： 采用java内置语法： 123456new Employee()&#123;&#123; setName(\"Jack Sparrow\"); setId(1); setFoo(\"bacon!\");&#125;&#125;); 方法二： 采用更加复杂的内部类builder模式： 123456789101112public Employee setName(String name) &#123; this.name = name; return this;&#125;public static class Builder &#123; private String name; public Builder name(Strig name) &#123; this.name = name; return this; &#125;&#125; 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。但是一般POJO 类都比较简单，非复杂对象，所以采用builder模式并不会让代码变得简洁，反而会显得更加臃肿。 方法三： 属性新增withXxx方法： 1234567891011public Employee setName(String name) &#123; this.name = name; return this;&#125;public Employee withName(String name) &#123; setName(name); return this;&#125;//使用方式new Employee().withName(\"Xin yuan\").withHeight(178); 结论：不建议在POJO： Java Bean的setter方法中添加‘return this’，我们遵循Java规范，如果期望简化Java Bean的属性设置，可以采用with或build方法。 参考： https://en.wikipedia.org/wiki/Plain_old_Java_object https://stackoverflow.com/questions/1345001/is-it-bad-practice-to-make-a-setter-return-this","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"AWS应用自动发现服务","slug":"HighAvailability/2018-03-15-aws-application-discovery","date":"2018-03-14T16:00:00.000Z","updated":"2018-11-09T14:17:45.676Z","comments":true,"path":"2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/","link":"","permalink":"http://heartaway.cn/2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/","excerpt":"","text":"定义：AWS Application Discovery Service 收集并呈现数据，以使企业客户能了解其本地环境中服务器的配置、使用和行为。 工作模式：无代理自动发现原理：基于 VMware vCenter Server 的环境的数据上报； 弊端： 采用VMware 方式在国内并不常用； 采集到的数据有限，只是系统层面的静态数据与CPU、MEM的指标数据； 基于代理(Agent)的发现模式：通过Agent可以采集更加丰富的数据集合，比如系统进程，系统间的网络连接；这里重点了解Agent模式。 采集的数据： 静态配置数据： 系统标识信息：主机名、IP地址、MAC地址、操作系统名称、操作系统版本号，cpuType； 运行中的进程数据； 系统间的网络调用（TCP/IP v4 和 v6）； sourceIP、sourceProcess、destinationIp、destinationPort、dstProcess，ipVersion； 性能指标数据： 操作系统层面： 参考之前的OS监控采集项； 进程层面： %CPU %MEM %DISK 网络层面： 待补充 数据安全性：采用SSL协议进行数据传输；数据存储采用AWS KMS静态加密； Agent模式下的自动发现Agent启动时，自动注册到Arsenal中，并频繁对该服务执行 ping 操作以获取配置信息。 数据收集数据的收集需要自动显示开启； 数据采集状态： STARTED – 收集工具已开始收集和发送数据到 Discovery Service。 START_SCHEDULED – 已计划数据收集开始时间。下次收集工具联系 AWS 时，它将开始将数据发送到 Discovery Service，并且收集状态将更改为 STARTED。 STOPPED – 收集工具已停止发送数据到 Discovery Service。 STOP_SCHEDULED – 已计划数据收集停止时间。下次收集工具联系 AWS 时，它将停止向 DiscoveryService 发送数据，并且收集状态将更改为 STOPPED。 组件分类DiscoveryService识别组件后，通过TAG标签的方式，对资源进行标记；用户也可以同通过控制台进行自定义TAG标记； 进程数据分类方法： 通过采集到的进程数据，可以推测出aws判断进程属于哪一类基础设施应该是通过进程名称与commondLine来判断的。 Agent模式自动发现不足： 不能保存资源组件快照或跟踪资源变更； 收集的性能数据不是通用的运行状况监控解决方案； 自动发现API Agent相关API Agent的启动、停止数据采集操作； Agent的描述信息； Agent的运行状态； 配置相关API server、application、process、connection 的指标查询、过滤与配置； 标签相关API TAG的增删改查； 其他：产品链接：https://aws.amazon.com/cn/documentation/application-discovery/ API地址：https://docs.aws.amazon.com/zh_cn/application-discovery/latest/APIReference/discovery-api.pdf#discovery-api-queries","categories":[{"name":"HighAvailability","slug":"HighAvailability","permalink":"http://heartaway.cn/categories/HighAvailability/"}],"tags":[]},{"title":"《基于中间件的基础设施自动发现》","slug":"Paper/2018-03-14-infrastructure-auto-discovery","date":"2018-03-13T16:00:00.000Z","updated":"2018-11-09T14:26:02.852Z","comments":true,"path":"2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/","link":"","permalink":"http://heartaway.cn/2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/","excerpt":"","text":"论文地址：https://patents.google.com/patent/US7912749B2/en 论文主体内容：通过分析中间件网络数据，建立信息模型；从网络数据中判断组件性能阈值、基础设施组件之间的依赖关系以及业务流程与基础设施的映射关系； 建议采用分层（图层）模型；（比如Dynatrace中的5层模型） 架构基线特征 基于对象的； 对象也就是架构实体或者信息模型的组合； 策略驱动的； 安全的； 自我管理的； 自我描述； 自我描述有利于新组件加入后的关系挖掘，而不依赖人工的定义与配置； 能够提供信息透明度； 架构基线是简化系统主要部分的识别和结构化组织的催化剂。 架构发现本质上是对信息的识别和分类过程，识别和分类过程最好与任何特定的知识库，上下文，协议或平台 无关。 模型划分可以提供元模型来定义用于在业务管理环境中指定模型的语言。元模型可以具有描述动态语义的能力。元模型图层中的一些对象示例包括类，属性，操作，关联，组件等 可以提根据核心模型来定义抽象类的集合，核心模型是分析师确定如何扩展核心模型以创建领域模型的起点。抽象类的一些例子，比如交易、客户等； 按照信息的抽象程度划分：元模型 &gt; 信息模型 &gt; 核心模型 &gt; 领域模型； 信息模型和核心模型通常更稳定，这两个模型是定义域模型的来源，这些模型也提供了跨不同领域的元素视图，可发现有价值的业务相关数据。 信息过滤从多个数据源创建有用的信息非常关键。但是，业务相关性需要适当、一致且相关的信息，而不是分散的数据。信息透明度服务可以将离散的实时或历史数据源分离出来，作为有用的信息源。该过程涉及通过使用明确定义的‘聚合’和‘转换规则’以及信息模型作为信息交换的基础来聚合和转换数据源。 模式软件模块存储在数据库中。库中的各个模块称为模式，而库本身称为模式目录。模式可以根据其规模和抽象进一步分类为 架构模式 设计模式 语言模式 架构模式：表达了软件系统的基本结构组织模式。它提供了一组预定义的子系统，指定了他们的职责，并包括组织它们之间关系的规则和准则。 扩展功能基础设施的自动发现，可衍生出通过诊断分析进行故障定位或影响分析等功能。可以提供自我修复程序，并且可以通过动态资源管理和嵌入式服务意识来解决基础结构优化问题。比如Dynatrace的故障定位； 扩展产品了解：dynatraceamazon-application-discovery","categories":[{"name":"Paper","slug":"Paper","permalink":"http://heartaway.cn/categories/Paper/"}],"tags":[]},{"title":"自用型监控系统方案","slug":"HighAvailability/2018-03-14-monitor-system","date":"2018-03-13T16:00:00.000Z","updated":"2018-11-09T14:17:34.222Z","comments":true,"path":"2018/03/14/HighAvailability/2018-03-14-monitor-system/","link":"","permalink":"http://heartaway.cn/2018/03/14/HighAvailability/2018-03-14-monitor-system/","excerpt":"","text":"一、监控系统整体概述 系统背景：在当前项目中，当我们对特定流程注入故障后，如何评估故障的效果以及系统应对故障的表现？传统方式是用户需要登录线上机器或者各种监控系统去查看具体的指标信息，然后通过人工判断，来判断故障的影响范围，产品使用上不够自动化，且没有闭环。我们期望引入监控系统，把之前需要人来做的事情交给系统来做，为故障注入后的影响进行量化分析。 整个监控系统对数据处理的四个步骤： 系统架构图： 组件说明： API Gateway：agent 与 Server 所有交互都会通过API Gateway，统一由API Gateway进行管控，为整个MK提供一致的数据门面接口，实现之前约定的数据总线的方案。 Data Collector：为数据采集器，接受来自客户端推送上来的监控数据 或 拉去外部监控数据； Data Transfer： 数据转换器，把采集到的非一致性架构的数据转换为统一的数据模型； Config： 此模块主要提供一些Agent、Collector、Analyzer需要的一些元数据； Schedule： 依赖Schedule，主要是期望能把周期性数据拉取采集任务转换为 schedule任务，降低重复编写分布式任务调度的复杂度，其次，借助schedule实现周期任务分发的负载均衡； Diamond：采用Diamond作为数据采集规则的动态配置中心。 MQ： 把数据采集器采集到的数据转换为统一的消息格式，解耦数据采集与数据分析对数据使用差异性；其次，当数据分析器Data Analyzer集群宕机或处理性能下降时，MQ能起到数据缓存池的作用，一定程度上防止采集上来的数据未能处理而导致的数据丢失。 Data Analyzer： 数据分析器，对收集到的监控数据进行一定程度上的计算转换，并根据关注点规则，进行事件监控处理； 自研监控系统，需要面临一系列的抉择： 二、行业监控系统架构：OneAPM CAT 参考：https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html 三、数据采集方案数据采集面的的挑战： 数据源多种多样 数据量大 变化快 如何保证数据采集的可靠性的性能 如何避免重复数据 如何保证数据的质量 3.1 采集方案目前常用的数据采集方式有两种： 主动监控（客户端推模式-Push）； 优势： 实时性好； 对服务端的压力相对较小； 插件化支持用户自定义采集脚本； 监控自动发现； 劣势： 数据聚合与异常处理复杂； 被动监控（服务端拉模式-Pull）； 优势： 数据处理方便； 数据准确性、完备性更好； Edas已经存在根据staragent进行数据拉去的实践方案； 劣势： 集群规模大时，服务器压力大，任务分发易积压，分发线程忙，带来一定数据延迟； 数据拉取时服务隔离难(twitter)； 无法区分服务失效和代理失效(twitter)； 现有监控系统采集方案： 系统 采集方式 备注 AliMonitor Push Ali-Sunfire Pull TLog Pull aliyun-sls-ilogtail Push Zabbix push+pull Open-falcon Push OneAPM Push Cacti Pull 主动监控示意图（Push）： 服务端提供一个接受数据请求的域名地址，客户端把数据推送到服务端，服务端负责数据解析与存储； 被动监控示意图（Pull）： Agent一般具备的功能: LogFinder: 能够根据请求的时间区间返回区间内的监控数据； LogQuery: 能够根据偏移量定位到日志位置； LogCompression： 支持日志数据压缩； 此部分可以参考LogAgent的实现逻辑。 我们的需求： 轻量级； 可扩展； 支持系统监控（OS）、业务监控（Agent） 支持Agent自动注册以及静态数据主动上报； 监控项受控开启与关闭，具备开关功能（非常态化挂载）； 需要具备数据堆积能力； 需要具备多数据源扩展能力； 方案结论： 客户端通过写本地磁盘日志的方式写指标数据，服务端通过 主动拉的方式到客户端上进行拉去数据； 3.2 分布式任务调度我们采用服务端拉去日志的方式，所以需要一套对多个节点进行周期性调度拉取日志的框架。目前分布式定时调度服务阿里集团内有scheduleX以及开源的Quartz，考虑到服务单独输出减少依赖组件的需求，对Quartz的分布式持久化任务整合工作量评估后， 我们选择了使用quartz的方式。目前spring有对quartz进行整合，简化对quartz的使用。不仅在监控数据采集上需要调度，在演练定时触发、演练监控定时开启等场景下都需要分布式任务调度服务，所以提供一套通用型的与业务无关的分布式调度服务API很有必要。基于spring-quartz进行接口封装出统一的分布式调度服务接口服务SchedulerService， 这部分是单独的一个模块。 3.3 数据Metric指标客户端打印的日志非Metric格式，通过日志数据采集上来的数据需要通过转换器Transfer进行转换为统一的Metric格式； 当前监控系统采集的数据指标分为两类： 系统OS监控指标； 应用性能指标； 系统监控指标Metric含义： category Metric Type Tag Description cpu system.cpu.idle GAUGE host system.cpu.system GAUGE host system.cpu.user GAUGE host system.cpu.util GAUGE host cpu使用率 load system.load.1min GAUGE host system.load.5min GAUGE host system.load.15min GAUGE host mem system.mem.buffers GAUGE host 当前系统的buffer cache的内存数(单位kb) system.mem.cached GAUGE host 当前系统的pagecache里的内存数(单位kb) system.mem.free GAUGE host 当前系统的空闲内存(单位kb) system.mem.total GAUGE host 当前系统的总内存(单位kb) system.mem.used GAUGE host 当前系统的已经使用的内存(单位kb) system.mem.util GAUGE host 当前系统的已经使用的内存占比 disk.partition system.disk.partition.total GAUGE host、device 当前系统的磁盘总字节数 system.disk.partition.free GAUGE host、device 当前系统的磁盘空闲字节数 system.disk.partition.used GAUGE host、device 当前系统的磁盘使用字节数 system.disk.partition.used_ratio GAUGE host、device 当前系统的磁盘使用率 disk.io system.disk.io.read_merge GAUGE host、device 每秒合并读完成次数 system.disk.io.write_merge GAUGE host、device 每秒合并写完成次数 system.disk.io.read GAUGE host、device 每秒读完成次 system.disk.io.write GAUGE host、device 每秒写完成次数 system.disk.io.util GAUGE host、device io占比 processs system.process.switches GAUGE host system.process.total GAUGE host traffic system.net.in.bytes GAUGE host system.net.out.bytes GAUGE host system.net.in.packets GAUGE host system.net.out.packets GAUGE host system.net.packet.errs GAUGE host system.net.packet.dropped GAUGE host tcp system.tcp.active_opens GAUGE host 最近1min平均每秒主动建连的连接数 system.tcp.passive_opens GAUGE host 最近1min平均每秒被动建连的连接数 system.tcp.current_estab GAUGE host 最近1min平均每秒处于ESTABLISHED和CLOSE-WAIT状态的TCP连接数 system.tcp.estab_resets GAUGE host 最近1min平均每秒reset次数 system.tcp.out_segs GAUGE host 最近1min平均每秒发送的tcp包数量 system.tcp.in_segs GAUGE host 最近1min平均每秒接收到的tcp包数量 system.tcp.attempt_fails GAUGE host 最近1min平均每秒建连失败次数 system.tcp.retran_segs GAUGE host 最近1min平均每秒重传的包数量 udp system.udp.in_dgm GAUGE host 收到的udp报数目 system.udp.out_dgm GAUGE host 发送的udp报数目 system.udp.noport GAUGE host udp协议层接收到目的地址或目的端口不存在的数据包 system.udp.in_errs GAUGE host udp层接收到的无效数据包的个数 应用性能监控指标Metric含义： category Metric Type Tag Description servlet app.servlet.request.count COUNTER host、transaction，device 时间区间内，请求总次数 app.servlet.request.durations COUNTER host、transaction，device 时间区间内，请求总时间 app.servlet.request.rt.mean GAUGE host、transaction，device 请求的平均rt app.servlet.request.rt.max GAUGE host、transaction，device 请求的最大rt app.servlet.request.rt.min GAUGE host、transaction，device 请求的最小rt app.servlet.request.error_count COUNTER host、transaction，device 其中device存储agentId，transaction存储请求名称； Metric命名规范 key和tag只支持：[a-z][A-Z][0-9][-_./], 不能有空格, 大小写敏感, key原则上不包含大写。格式为xxx.category[.sub_category]*, category和sub_category里面如果有多个单词，用下划线’_’连接， 不要用’.’连接。需要动态聚合的维度， 放在tag里面， 同时在tagKey也在key中体现。 不需要聚合的维度， 放在key里面。 3.4 数据转换transfer针对不同类型的类型，采用工厂方法提供自适配的解析器。针对system系统监控，继续拆分为领域适配器，比如针对CPU域、mem域提供不同的处理方式。 12345678910public interface MetricTransfer extends Transfer &#123; /** * format data to metric list * * @param sourceData * @return */ List&lt;MetricObject&gt; format(MetricMeta metricMeta, String sourceData);&#125; 四、数据分析方案4.1 分析方案：现有的监控系统数据分析模块主要分为两类： 批处理模型； 流处理模型（Spark Streaming、Storm、Flink）； 结论：考虑到我们要求部署节点少、拓扑简单以及本期研发周期时间紧，我们采暂且不采用流式处理方案，数据获取到后，直接给到后端进行分析处理； 4.2 监控点分析：用户可以通过配置监控指标，来对关心的系统指标进行阈值判断，比如选择一批机器，关注CPU利用率超过90%，那么监控系统就需要把这批机器在演练期间CPU利用率超过90%的指标都找出来，并转换为Event事件。这点类似于监控系统中的报警系统模型。 数据分析器中处理监控指标的流程如下： 流程分析： 每一个Data Analyzer模块中都会包含一个Rule Set集合，Rule Set集合存放着生效后的关注点规则，在监控数据到达分析引擎中后，分析引擎通过filter机制，判断是否命中规则，如果命中规则，则根据规则与数据形成一条Event 事件数据，用于描述某次监控指标命中了监控指标阈值。后续复盘时，可以对Event 库中的指标事件进行聚合分析，形成需要的结论报告。 规则注册与更新机制： 关注点规则为内存数据集，当用户在界面是哪个新增了规则或者变更了规则的时候，都需要对内存中维护的这份规则集合进行修改操作。 规则存储： 当前规则为内存存储方式，在系统启动时从数据库中进行load全量有效关注点指标；带来的影响每一台机器都需要在内存中维护一份数据，如果某台机器数据更新失败，会带来数据的一致性问题，后续会考虑这部分数据移动到公共的外部快速存储设备中，比如Redis中。 数据模型： 我们把用户配置的关注点在系统指标上的阈值简称为“告警”，告警条件的判断以及存储流程中，主要涉及的领域模型为：Hosts、Metrics、triggers、functions、items、events、actions； hosts： 存储被监控的主机信息； metrics：存储监控到的数据指标； items： 存储支持的监控项配置信息。 triggers：存储触发器的相关信息； events： 存储事件数据； actions：存储当触发器触发时，需要采取的动作（不再本期研发范围内）； 触发器计算模型： 我们的需求是：监控某个关注对象下的某类监控指标下的特定聚合函数值 是否超过(也可能是其它运算符)某个固定阈值；那么我们把需求中拆解出几个对象出来，分别是：监控对象、监控指标、聚合函数、运算符、固定阈值，我们通过这几个对象的组合，可以对我们的意图进行对象化描述，表达式函数格式如下：{:.()} 计算模型举例： 关注点描述为： 11.23.45.67 这台机器的 最近十分钟 load 指标 大于2 ， 那么 表达式函数为：{11.23.45.67:system.cpu.load.last(10m)} &gt; 2 触发器中的聚合函数： max 最大值 min 最小值 avg 平均值 数据模型： 在监控指标分析域中涉及到的领域模型对象为： items triggers events actions 数据模型以及关联关系如下： 资源组与触发器为1：n的关系，监控项与触发器为1:1关系，触发器与事件为1:1关系； 五、数据存储方案5.1 数据分类：我们把数据类型分为五类： Metric指标数据（分为服务器和容器） 定义：metric描述一个指标在某个时间点的值是多少，可以使用tag来进行元数据标记划分；比如OS的系统监控指标； Event 事件数据（包括：系统、Docker数据采集） 定义：event记录系统在特定时刻下发生的具体信息，比如规则下发、故障启停、MkKit安装与卸载、Metric触发规则配置产生的事件等； Log 运行时日志数据 定义：event数据可以根据业务需求打上tag便于分析时筛选，统计，text中记录事件丰富上下文信 Heartbeat 心跳数据 定义：定期执行的状态汇报，比如agent的心跳信息，进程的状态等； Trace 数据 定义：记录故障注入请求trace的信息； 5.2 数据存储方案：监控数据是时间序列的数据，由于监控的对象数量巨大，所以存储的介质需要支持高的写入吞吐量，良好的扩充性，读取最近的数据速度要快，支持多数据类型，支持多种扫描方式等特点，目前主要的存储方式有SQL和NoSQL两种。通过对比，NoSQL在数据存储吞吐量，扩充性等方面具有优势，SQL在数据类型的支持，扫描多样性具有优势。 总而言之，监控数据更适合采用时序性存储媒介，比如OpenTSDB、HiTSDB等；考虑到种种原因，我们临时使用 Mysql，Mysql 能在一定程度上简化我们架构，让业务跑的更快一些。 不压缩的情况下：100台机器同时采集长达30天，占用空间49G；（单条1kb计算，5秒存储一次）。 5.3 行业常用存储方案CassandraInfluxDBMongoDBOpenTSDBKairosDBHBase 5.4 监控指标存储规范遵循metric规范； 一个metric由两部分组成，metric key和metric tag： metric key：它是用英文点号分隔的字符串，用来表征这个指标的含义 metric tag：它定义了这个指标的不同切分维度，可以是单个，也可以是多个 tag key: 用于描述维度的名称 tag value: 用于描述维度的值 Metric的数据格式如下： metric key：存储当前指标的key metric tag：存储当前指标的tag metric value：存储当前指标的值 timestamp：存储当前的时间戳 metadata：存储当前指标的一些元信息 在Metric规范下，针对云上的多租户设计，我们增加了两个字段namespace、scope，用来对metric进行分类，一个是从用户角度进行划分，一个是从功能集角度划分，形成 MetricObject 对象属性描述如下： 字段 类型 描述 是否必填 namespace ​String 命名空间，用于区分不同租户，存储userId 必填 scope String 范围，比如system、jvm、hsf、servlet等 必填 metric String 指标Key 必填 metricType MetricType 指标类型 必填 tags map&lt;string,string&gt; 附加信息，当前只支持内置tag，不支持用户自定义tag（原因是采用mysql而不是nosql） 必填，遵循OpenTSDB规范，至少要求有一个Tag timestamp Long 时间戳 必填 value Double 指标值 必填 举例： 1234567891011&#123; \"namespace\": \"1114805108664848\", \"scope\": \"system\", \"metric\": \"sys.memory.total\", \"metricType\": \"COUNTER\", \"tags\": &#123; \"host\": \"127.0.0.1\" &#125;, \"timestamp\": 1470298287916, \"value\": 1167126&#125; MetricType 指标类型(参考：http://metrics.dropwizard.io/4.0.0/getting-started.html)： COUNTER: 用于累加型的数据，反映的是数据随着时间单调递增的关系，如Tomcat接受到的HTTP请求的总次数 GAUGE: 用于瞬态数据，表示指标在当前时间点的瞬时情况，反映的是数据随着时间上下波动的关系，如系统的load，JVM的内存使用率 METER：用于对变化速率型指标进行度量，反映的是数据随时间的增长快慢关系，如某个接口的QPS HISTOGRAM：用于对分布型数据进行度量，反映的是数据随时间的统计学分布关系 Tags 标签存储方案： 由于生产环境中存储方案当前技术选型为使用Mysql存储Metric数据，Mysql不支持schemaless结构，所以无法做到Tags的key-value的动态扩展，我们使用Mysql的固定列模式，通过提供内置tag来达到相同的目的；Tags中的key为Mysql中的列名称，字段值为tags的value； 内置的tag字段为： 字段名称 字段描述 举例 tag_host 主机信息 127.0.0.1 tag_device 设备信息，比如磁盘盘符 /usr/dev1 tag_trace 请求链路标识 tid tag_transaction 请求事务标识 createOrder Mysql数据模型如下： 六、监控数据查询方案6.1 数据查询分类：用户对时序数据的查询场景多种多样，总的来说时序数据的查询分为两种： 原始数据的查询（比如业务监控数据） 时序数据聚合运算的查询（比如系统监控数据） 某监控 指标展示计算解析： 监控中用户日志的计算逻辑是由用户自定义的计算方式（因为是业务监控），主要由求行数、对列值求和、对列值求平均、对列值求最大值、对列值求最小值；其大盘数据展示中并未对数据做再次聚合处理，展示的是采集的原始数据（原始数据分为秒级和分钟级），如果需要做计算，是通过前端的聚合函数进行的业务处理。 6.2 数据聚合分类：在监控数据使用过程中，我们往往会针对单台机器进行分析或者多台(集群)机器进行分析，每一种分析中又会加入时间的概念，比如是采用原始采集的数据点还是进行多个点的合并形成一个新点。所以我们把数据分析计算分为两个维度，一个是‘机器’维度(空间聚合)，一个时间维度(时间聚合)；在Metric模型中我们通过两个方法分别定义，一个是Aggregator，一个是Down sample。 Aggregator：用来描述同一个时间点下，数据集合的聚合方式；比如一个集群的CPU使用率，在某一时刻下集群中所有机器的CPU使用率的平均值；需要注意的是，当随着集群规模越来越大的时候，我们也是需要从这个数据集合中进行采样，然后再做聚合计算。 Down sample：用来描述在多个时间点下，数据聚合的聚合方式；比如一台机器每隔5秒采集一个CPU使用率，最终数据展示时，需要按照1分钟一个点的方式进行展示，那么这个数据集合中在不丢数据的情况下会有12个数据项，我们需要将这12个数据项聚合为一个数据项。 6.3 数据聚合方式：数据的聚合方式一般可以分为‘预聚合’和‘后聚合’；提前聚合可能引起数据膨胀但可以加速访问请求时的响应速度，访问时聚合虽然降低了一定的存储成本但可能会加慢响应速度。 大部分监控系统一般都支持预聚合(归档)数据处理（比如zabbix的数据归档表trends）；由于一般原始数据采集周期比较小，比如分钟级，那么展示长时间的数据的视图需要扫描过多数据，展示比较慢，如果将数据归档成按小时，和按天的数据，那么展示时间跨度大的数据的效率大大提高；基于Metric的数据预处理，一般采用流式预聚合引擎，对数据进行降精度处理，比如阿里的DBPass产品，会对指标数据事先降时间精度，分为6个精度：1秒、5秒、15秒、1分钟、5分钟、15分钟。 基于Metric规范的时序数据库中，OpenTSDB支持预聚合和后聚合，Aliyun的HiTSDB优先采用后聚合，其通过采用倒排索引+前缀索引来加速数据查询。 6.4 数据计算算法：在客户端数据采集计算的时候，通常也会遇到数据聚合的需求，主要是基于单机维度的数据聚合，比如我们期望采集固定周期周期范围内的数据，假如每个周期范围内存在多个数据点（D1，D2，D3），我们要怎样计算才能得到一个点的数据呢？ 通常会有以下计算方式： 随机采样； 滑动窗口； 滑动时间窗口； 指数衰减随机采样（EWMA）； EWMA的Java实现方式可以参考：EWMA.javaEWMA算法 维护一个固定大小的集合，并认为该集合中的元素的权重不一样，元素的权重随元素距离当前时间的远近而呈现指数型的衰减。主要是解决数据集合中的离散点，让数据曲线跟加平滑。比如Load1、Load5、Load15目前的计算逻辑就采用EWMA算法； 6.5 数据查询API：待补充 七、扩展阅读：metric起源： https://www.youtube.com/watch?v=czes-oa0yik 小米 open-falcon： http://open-falcon.com/ 网易企业级监控： http://blog.163yun.com/archives/900 salesforce-Argus：https://github.com/salesforce/argus 使用Metrics监控应用程序的性能： http://www.cnblogs.com/yangecnu/p/Using-Metrics-to-Profiling-WebService-Performance.html 深入浅出时序数据库之预处理篇： http://www.infoq.com/cn/articles/pretreatment-in-sequential-databases","categories":[{"name":"HighAvailability","slug":"HighAvailability","permalink":"http://heartaway.cn/categories/HighAvailability/"}],"tags":[]},{"title":"spring quartz 指定trigger的执行机器","slug":"Java/2018-03-06-spring-quartz-trigger","date":"2018-03-05T16:00:00.000Z","updated":"2018-11-09T14:24:24.761Z","comments":true,"path":"2018/03/06/Java/2018-03-06-spring-quartz-trigger/","link":"","permalink":"http://heartaway.cn/2018/03/06/Java/2018-03-06-spring-quartz-trigger/","excerpt":"","text":"我们在使用spring-quartz的时候，常常会遇到一个场景，那就是任务的调度会随着争取锁的先后顺序而出现不固定机器执行的场景，这在正常业务逻辑中具备了很好的容灾能力，但是在我们排查问题时，却带来了困绕，如果出现问题，我们期望任务调度固定在一台机器上进行执行，方便我们对问题的定位和排查。 这里就探讨如何扩展spring-quartz来实现任务的固定机器执行。 整体思路要指定机器运行trigger，那首先我们必须清楚spring-quartz cluster模式下，任务的触发时如何进行分布式执行的。spring-quartz cluster 是借助数据锁来实现并发控制的，需要注意的是分布式环境下需要保证各机器系统时间一致性； 核心处理线程QuartzSchedulerThread决定了扫描那些JOB，以及触发执行和生命周期的维护。QuartzSchedulerThread中run方法： 123456789101112//在trigger表中扫描指定SCHED_NAME、状态为WAITING，下次触发时间在30秒内的触发器triggers = qsRsrcs.getJobStore().acquireNextTriggers( now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());.... //触发器执行List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers); ...//释放触发器qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));...//完成触发器qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR); 我们就可以在acquireNextTriggers中做扩展，获取全部或者指定了实例ID的trigger。 延伸思考：acquireNextTriggers获取到trigger列表后，假设机器宕机，这些trigger如何路由到其他机器中正常运行？ 扩展实例ID的生成策略spring-quartz一般配置的org.quartz.scheduler.instanceId：AUTO，采用的是SimpleInstanceIdGenerator ID生成策略。 123456789public class SimpleInstanceIdGenerator implements InstanceIdGenerator &#123; public String generateInstanceId() throws SchedulerException &#123; try &#123; return InetAddress.getLocalHost().getHostName() + System.currentTimeMillis(); &#125; catch (Exception e) &#123; throw new SchedulerException(\"Couldn't get host name!\", e); &#125; &#125;&#125; SimpleInstanceIdGenerator 采用机器主机名称与当前时间戳作为instanceId,我们期望在开发环境使用hostName，在生产环境(Linux)采用IP作为实例ID。 实现InstanceIdGenerator接口，实现自己的ID生成策略，QuartzSchedulerInstanceIdGenerator的实现逻辑为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class QuartzSchedulerInstanceIdGenerator implements InstanceIdGenerator &#123; private static final Logger log = LoggerFactory.getLogger(QuartzSchedulerInstanceIdGenerator.class); private static final String OS_NAME = \"os.name\"; private static final String WINDOWS = \"Windows\"; private static final String MAC = \"Mac OS\"; @Override public String generateInstanceId() throws SchedulerException &#123; String id; try &#123; if (isLocalDev()) &#123; id = getHostName(); &#125; else &#123; id = IpUtil.getIp(); &#125; if (StringUtils.isBlank(id)) &#123; id = InetAddress.getLocalHost().getHostName() + System.currentTimeMillis(); &#125; &#125; catch (Exception e) &#123; throw new SchedulerException(\"Couldn't generate instance id!\", e); &#125; return id; &#125; private String getHostName() throws SchedulerException &#123; try &#123; return InetAddress.getLocalHost().getHostName(); &#125; catch (Exception e) &#123; throw new SchedulerException(\"Couldn't get host name!\", e); &#125; &#125; private boolean isLocalDev() &#123; if (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), WINDOWS) &gt;= 0) &#123; return true; &#125; if (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), MAC) &gt;= 0) &#123; return true; &#125; return false; &#125;&#125; 在quartz.properties中配置： 1org.quartz.scheduler.instanceIdGenerator.class=com.xx.ext.QuartzSchedulerInstanceIdGenerator 扩展StdJDBCDelegateSchedulerFactoryBean 工厂Bean负责加载配置信息，初始化SchedulerFactory和Scheduler实例，jobStore负责job、trigger等的持久化工作，针对不同的数据库类型，可以配置不同的DriverDelegate。Spring中默认使用LocalDataSourceJobStore作为JobStore的处理类。 SchedulerFactory中initSchedulerFactory方法: 123456789101112 if (this.configLocation != null) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Loading Quartz config from [\" + this.configLocation + \"]\"); &#125; PropertiesLoaderUtils.fillProperties(mergedProps, this.configLocation); &#125;CollectionUtils.mergePropertiesIntoMap(this.quartzProperties, mergedProps);if (this.dataSource != null) &#123; mergedProps.put(StdSchedulerFactory.PROP_JOB_STORE_CLASS, LocalDataSourceJobStore.class.getName());&#125; 可以看到SchedulerFactoryBean中设置PROP_JOB_STORE_CLASS属性是在合并用户设置的配置文件之后，也就是PROP_JOB_STORE_CLASS的实现类Spring强制指定为LocalDataSourceJobStore而无法更改，即便是我们在quartz.properties中配置了org.quartz.jobStore.class属性，也会被LocalDataSourceJobStore覆盖掉。 LocalDataSourceJobStore继承自JobStoreSupport，JobStoreSupport默认配置使用StdJDBCDelegate作为与数据库交互的代理处理类；我们可以通过扩展StdJDBCDelegate类，来实现底层数据库交互的扩展。通过配置org.quartz.jobStore.driverDelegateClass属性，指定driverDelegate为我们扩展后的Delegate。 在quartz.properties中配置： 1org.quartz.jobStore.driverDelegateClass=com.xx.ext.StdJDBCDelegateExt 针对${table_prefix}_quartz_triggers表新增字段INSTANCE_NAME，此字段为InstanceIdGenerator生成的实例ID，此字段会透传到StdJDBCDelegate中的属性instanceId中，因此我们可以扩展StdJDBCDelegate，通过instanceId字段来指定获取的trigger列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class StdJDBCDelegateExt extends StdJDBCDelegate &#123; String INSTANCE_NAME_VALUE = \"&#123;2&#125;\"; String SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT = \"SELECT \" + COL_TRIGGER_NAME + \", \" + COL_TRIGGER_GROUP + \", \" + COL_NEXT_FIRE_TIME + \", \" + COL_PRIORITY + \" FROM \" + TABLE_PREFIX_SUBST + TABLE_TRIGGERS + \" WHERE \" + COL_SCHEDULER_NAME + \" = \" + SCHED_NAME_SUBST + \" AND \" + COL_TRIGGER_STATE + \" = ? AND \" + COL_NEXT_FIRE_TIME + \" &lt;= ? \" + \" AND (\" + COL_INSTANCE_NAME + \" IS NULL OR \" + COL_INSTANCE_NAME + \" = \" + INSTANCE_NAME_VALUE + \")\" + \"AND (\" + COL_MISFIRE_INSTRUCTION + \" = -1 OR (\" + COL_MISFIRE_INSTRUCTION + \" != -1 AND \" + COL_NEXT_FIRE_TIME + \" &gt;= ?)) \" + \"ORDER BY \" + COL_NEXT_FIRE_TIME + \" ASC, \" + COL_PRIORITY + \" DESC\"; /** * 允许设置trigger 指定一台机器进行任务调度执行； * * @param conn * @param noLaterThan * @param noEarlierThan * @param maxCount * @return * @throws SQLException */ @Override public List&lt;TriggerKey&gt; selectTriggerToAcquire(Connection conn, long noLaterThan, long noEarlierThan, int maxCount) throws SQLException &#123; PreparedStatement ps = null; ResultSet rs = null; List&lt;TriggerKey&gt; nextTriggers = new LinkedList&lt;TriggerKey&gt;(); try &#123; ps = conn.prepareStatement(rtp(SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT, instanceId)); // Set max rows to retrieve if (maxCount &lt; 1) &#123; maxCount = 1; &#125; ps.setMaxRows(maxCount); // Try to give jdbc driver a hint to hopefully not pull over more than the few rows we actually need. // Note: in some jdbc drivers, such as MySQL, you must set maxRows before fetchSize, or you get exception! ps.setFetchSize(maxCount); ps.setString(1, STATE_WAITING); ps.setBigDecimal(2, new BigDecimal(String.valueOf(noLaterThan))); ps.setBigDecimal(3, new BigDecimal(String.valueOf(noEarlierThan))); rs = ps.executeQuery(); while (rs.next() &amp;&amp; nextTriggers.size() &lt;= maxCount) &#123; nextTriggers.add(triggerKey( rs.getString(COL_TRIGGER_NAME), rs.getString(COL_TRIGGER_GROUP))); &#125; return nextTriggers; &#125; finally &#123; closeResultSet(rs); closeStatement(ps); &#125; &#125; protected final String rtp(String query, String instanceName) &#123; return MessageFormat.format(query, new Object[] &#123;tablePrefix, getSchedulerNameLiteral(), \"'\" + instanceName + \"'\"&#125;); &#125;&#125; 至此，完成了指定trigger在特定instanceId上运行，但是有一个问题，假如我们期望trigger可以在多台instanceId上随机执行的话，该如何实现呢？","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Spring中property-placeholder的使用与解析","slug":"Java/2018-01-19-spring-properties","date":"2018-01-18T16:00:00.000Z","updated":"2018-11-09T14:24:17.743Z","comments":true,"path":"2018/01/19/Java/2018-01-19-spring-properties/","link":"","permalink":"http://heartaway.cn/2018/01/19/Java/2018-01-19-spring-properties/","excerpt":"","text":"在我们程序开发中，进程会需要把一些变量通过property方式进行提取，方便不同环境配置不同的属性，替换变量的方法通常有两种，一种是静态替换，一种是动态替换；所谓静态替换，是在打包编译的时候，把变量替换掉，动态替换，是在程序运行起来时，通过把属性注入到程序的环境变量中，类初始化的时候，再使用环境变量进行替换的一种方法。 静态替换常用工具：autoconfig动态替换常用工具：spring.property-placeholder spring动态替换变量实践简洁配置法： 12&lt;context:property-placeholder location=\"classpath:xxx.properties\" ignore-unresolvable=\"true\"/&gt; 等价于： 12345&lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\"&gt; &lt;value&gt;myConfig.properties&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 完整配置属性： 12345678910&lt;context:property-placeholder location=\"\" file-encoding=\"\" ignore-resource-not-found=\"\" ignore-unresolvable=\"\" properties-ref=\"\" local-override=\"\" system-properties-mode=\"\" order=\"\" /&gt; ignore-resource-not-found：如果属性文件找不到，是否忽略，默认false，即不忽略，找不到将抛出异常 ignore-unresolvable：是否忽略解析不到的属性，如果不忽略，找不到将抛出异常 order：当配置多个context:property-placeholder/时的查找顺序 不推荐将ignore-resource-not-found和ignore-unresolvable的值设置为ture，默认为false，可以有效避免程序运行异常 使用PropertySource注解配置Spring3.1添加了@PropertySource注解,方便添加property文件到环境. properties的注入与使用 java中使用@Value注解获取 12@Value( \"$&#123;jdbc.url&#125;\" )private String jdbcUrl; 在Spring的xml配置文件中获取 123&lt;bean id=\"dataSource\"&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt;&lt;/bean&gt; 配置多个property-placeholder属性Spring容器是采用反射扫描的发现机制，通过标签的命名空间实例化实例，当Spring探测到容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderCVonfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描，即只能存在一个实例！ 所以一遍不建议配置多个property-placeholder对象，但是在必须使用多个的场景下，如何配置呢？ 123&lt;context:property-placeholder location=\"xxx.properties\" ignore-unresolvable=\"true\"/&gt;&lt;context:property-placeholder location=\"xxx.properties\" ignore-unresolvable=\"true\"/&gt; 需要设置ignore-unresolvable=”true”，否则后面的property-placeholder不会被加载； ignore-unresolvable单独使用来看是“是否忽视不存在的配置项”，不仅如此，其还有一个隐含意思：是否还要扫描其他配置项：如果为false，则会忽视后续的property-placeholder，如果需要配置多个property-placeholder则应该设置为true； context:property-placeholder 工作原理在 ContextNamespaceHandler 中对于 context中的property-placeholder 标签，会采用PropertyPlaceholderBeanDefinitionParser解析器进行解析； 123456789101112131415public class ContextNamespaceHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser()); &#125;&#125; PropertyPlaceholderBeanDefinitionParser解析器会将property-placeholder 标签解析为一个PropertySourcesPlaceholderConfigurer的单例 bean 。 可以看出 PropertySourcesPlaceholderConfigurer 或者 PropertyPlaceholderConfigurer 仅仅是做了一个配置文件的解析工作，真正的注入并不由它们完成，而是托付给了Spring 的Bean初始化流程。之所以这么做可以生效，是因为这两个类实现了 BeanFactoryPostProcessor 接口，这个接口的优先级高于后续的Spring Bean。 属性元素的注入依赖于 AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues。 通过解析PropertySourcesPlaceholderConfigurer 查询得到元素值。 12345678910public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass()); try &#123; metadata.inject(bean, beanName, pvs); return pvs; &#125; catch (Throwable var7) &#123; throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", var7); &#125;&#125; PropertySourcesPlaceholderConfigurer本质上是一个BeanFactoryPostProcessor。解析XML的流程在BeanFactoryPostProcessor之前， 优先将配置文件的路径以及名字通过Setter传入PropertySourcesPlaceholderConfigurer。 如上BeanFactoryPostProcessor的优先级又优于其余的Bean。因此可以实现在bean初始化之前的注入。 Spring @Value注入流程 Spring Context 的初始化开始 读取到context:property-placeholder标签或者PropertySourcesPlaceholderConfigurer 解析并实例化一个PropertySourcesPlaceholderConfigurer。同时向其中注入配置文件路径、名称 PropertySourcesPlaceholderConfigurer自身生成多个StringValueResolver备用，Bean准备完毕 Spring在初始化非BeanFactoryPostProcessor的Bean的时候，AutowiredAnnotationBeanPostProcessor 负责找到Bean内有@Value注解的Field或者Method 通过PropertySourcesPlaceholderConfigurer寻找合适的StringValueResolver并解析得到val值。注入给@Value的Field或Method。(Method优先)2 Spring的其他流程。 参考：http://blog.csdn.net/qyp199312/article/details/54313784","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"系统权限控制体系","slug":"Program/2018-01-04-permission-system-degisn","date":"2018-01-03T16:00:00.000Z","updated":"2018-11-09T14:26:45.566Z","comments":true,"path":"2018/01/04/Program/2018-01-04-permission-system-degisn/","link":"","permalink":"http://heartaway.cn/2018/01/04/Program/2018-01-04-permission-system-degisn/","excerpt":"","text":"在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。比如我们开放的功能页面需要登录授权之后才能访问，一些功能需要具备特定权限的人才能操作；再比如我们开放了数据API接口，如果不做访问控制，那么任何人都可以调用，当被不法分子操作时将给我们带来巨大的麻烦。那么在Java 整个体系中访问控制是否有一套理论技术支撑呢，我们是否可以做一个通用性的访问控制系统来完成分布式系统架构下的复杂的权限控制？接下来会一一介绍。 访问控制的本质：系统权限控制 本质上是访问控制（Access Control），那访问控制的本质又是什么呢？其实就是合法的访问受保护的资源，通俗的解释就是“【谁】是否有可以对某个【资源】进行某种【操作】”；可以看出访问控制的三个基本要素：主体（请求实体）、客体（资源实体）、控制策略（属性集合）； 访问控制需要完成的两个任务：识别和确认访问系统的用户；决定该用户可以对某一系统资源进行何种类型的访问； 访问控制理论模型： DAC&amp;MAC模型 DAC：自主访问控制； MAC：强制访问控制，一般用于多级安全军事系统； IBAC模型： 基于身份的访问控制模型 举例：登录验证 比如Java中使用cookie、session存储回话标识； RBAC模型： 基于角色的访问控制（Role-Based Access Control） 用户、角色、权限 RBAC是ABAC的一种单属性特例； 1992年David F.Ferraiolo &amp; D.Richard Kuhn在第十五届国家计算机安全会议上提出； 论文：https://csrc.nist.gov/projects/role-based-access-control 举例：丰趣-小二后台的认证授权模型设计； Spring Security、Apache Shiro、Ali ACL ABAC模型： 基于属性的访问控制模型 (Attribute Based Access Control) 举例：阿里云、AWS； 论文： https://csrc.nist.gov/projects/attribute-based-access-control https://link.springer.com/chapter/10.1007/978-3-319-25645-0_14 http://profsandhu.com/dissert/xin_slides.pdf 示意图：基于RBAC权限模型的常见数据库模型设计：设计的核心主题: 用户、权限、角色、用户角色、角色权限、用户组、用户组角色、操作审计阿里巴巴登录鉴权与审计的三驾马车：BUC、ACL、OpLog； Java常用访问控制框架： JAAS框架： Authentication（鉴别）， Authorization（授权），Accounting（计费）； Java认证和授权服务（Java Authentication and Authorization Service，简称JAAS） 支持的框架：LDAP 特点：面世时间早，使用受限，不建议使用； Spring Security框架 Apache Shiro框架 权限系统的演变历史：1： 标准的JAAS 时代；J2ee时代，Java提出了标准的鉴权服务，即jaas；通过简单的容器配置和文件配置，通过一个LDAP（可以用数据库，只是效率不高），就可以提供一个极为高效便捷的权限管控服务。这个模式不仅支持页面管控，还支持ejb服务接口管控。其鉴权因为ldap的数倍于数据库的查询效率而无需任何缓存，速度很快。但是伴随着分布式服务化进程，应用的数量无限度增长，这种散落在各个容器的配置给容灾和修改，都带来了极大的挑战，ldap的可读化差，修改和编辑极为不便，当需求一旦个性化超过了树能够表达的模型便很难在适应。并且当ldap的数据爆炸式增长，且呈现28规律时（数据冷热不均），或者如果需要频繁的写ldap，查询效率会陡然下降。虽然这种方式目前并不流行的，但是由于历史原因，还存留着使用这种方式的管控方式，所以我们在Spring Security或者阿里的ACL中都还能看到对JAAS的支持。 2： 单点登录(SSO)+接口鉴权时代；把分散在各个系统的登录认证服务统一到一个系统中来，统一管控登录授权业务，用户只要在一个系统中登录了，在其它系统中就没必要再次登录了，这就是SSO。简单的实现是登录授权系统部署在一台机器上，不涉登录系统的多机部署，此架构具有单点风险；任何具备高可用思维的架构师都不会允许此风险存在，原因有二：1. 统一登录中心后，SSO成为极为核心的应用，如果SSO系统挂了，那么需要登录的任何服务器都无法正常提供服务；2. 单台机器不具备抵抗登录风暴的能力； 所以SSO系统必须成为集群部署模式。其次，在访问控制模型上，也必须放弃JAAS方式，转而使用RBAC模型； 3： 统一登录（分布式Session） + 接口鉴权时代；SSO系统集群部署后，面临的首要问题就是Session的共享问题，比如用户在sso-1 机器上登录了，下次访问sso-2机器时，也必须是登录态的。分布式Session使用较多的方案为：Session集中管理；比如阿里巴巴基于Tair 缓存体系的共享session体系tbsession。如果采用了session + cookie的方案，并且服务端集群是多域名共享登录的话，那么还需要提供cookie跨域同步的能力（解决cookie不能跨域的问题）。","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"Taobao SSO 跨域登录过程解析","slug":"Program/2018-01-04-taobao-sso","date":"2018-01-03T16:00:00.000Z","updated":"2018-11-09T14:26:38.603Z","comments":true,"path":"2018/01/04/Program/2018-01-04-taobao-sso/","link":"","permalink":"http://heartaway.cn/2018/01/04/Program/2018-01-04-taobao-sso/","excerpt":"","text":"今年的双十一和双十二已经告一段落，你是否买到了你想要的宝贝呢？我们知道双十一是天猫的主场，双十二是淘宝的主场，你有没有注意到你在登录了淘宝后，访问天猫或者飞猪，你还是处于登录态的，但是我们知道cookie是不能跨域的，那么阿里是如何做到了多域名下的登录态同步呢？接下来我们通过抓包进行请求解析来了解这个过程。 基础知识： 如果忘了Cookie和Session的区别，那么建议你先回顾一下，可以参考：https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md 如果不知道为什么需要鉴权，为什么需要SSO，为什么需要跨域登录，建议你先阅读上一篇文章“系统权限控制”。 测试过程： 访问www.taobao.com 请求登录，跳转到 login.taobao.com 输入用户名和密码后，登录成功，302 回调到www.taobao.com页面 Post 表单到 login.taobao.com , response 为 set-cookie，并通过redirectURL 跳会www.taobao.com首页； 访问 www.tmall.com www.tmall.com页面响应中发起新的请求 tmcc.tmall.com/pass.com 请求页面 https://tmcc.tmall.com/pass.htm 响应为 302 跳转到： https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1 tbpm=1表示：进行tbsession的跨域同步； 请求页面 https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1 在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息 响应为302跳转到：https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1 服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。 请求页面 https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1 携带cookie 信息的query string 参数请求 tmall.com域名下的信息，请求添加cookie。 响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步； 响应状态未302 重定向到 https://tmcc.tmall.com/pass.htm?tbpm=1 请求页面https://tmcc.tmall.com/pass.htm?tbpm=1 302 跳转到 https://tmcc.tmall.com/pass.htm 抓包信息：图中隐藏了非关键请求，比如页面的静态资源等； 同样： 访问 www.alitrip.com，会同步请求https://ffa.alitrip.com/userInfo.htm的请求 请求页面https://ffa.alitrip.com/userInfo.htm 响应为 302 跳转到：https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserInfo.htm 请求页面https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserIn 在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息 响应为302跳转到：https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4… 服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。 请求页面https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4 携带cookie 信息的query string 参数请求 alitrip.com 域名下的信息，请求添加cookie 响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步; 示意图： 访问原始url： tmcc.tmall.com 重定向，访问login.taobao.com/jump 重定向，访问pass.tmall.com 重定向，访问原始url（带有同步标识tbpm） 重定向，访问原始url（去掉同步标识tbpm） 如果我们taobao.com域下没有登录cookie，通过在login.tmall.com页面进行登录，那么cookie的传递是怎么样的呢？通过测试，发现在请求login.tmall.com的时候会同步请求login.taobao.com然后cookie依然是通过taobao域同步到tmall域名，也就是cookie的同步是单向； 当然，这个过程是正向流程，那退出登录的逆向流程是怎么样的呢？会同步请求login.taobao.com/clear, 通过set-cookie 清楚session cookie（会话cookie），然后进行 302 跳转到 https://pass.tmall.com/clear 进行cookie清理，然后 302 跳转到 https://pass.etao.com/clear 进行cookie清理，然后 302 跳转到https://pass.etao.com/clear 进行 cookie清理，如此重复知道所有域名cookie进行清理完毕。通过测试发现淘系的系统所有的退出登录都是走login.taobao.com/member/logout.jhtml , 然后通过一些列302 跳转pass系统进行登录态的清理。 登录态在到阿里云、支付宝是不通的,因为阿里云和支付宝的账号体系不一样。 禁用Cookie：可以看出整个跨域登录依赖的是cookie信息的传递与跨域设置，如果出于安全考虑，我们禁用了cookie，是否还能正常工作呢？经过测试，发现禁用cookie后，跨域自动登录不能正常执行了，跨域请求后对于受限的访问请求还是会自动跳登录。由于设计上没有考虑cookie禁用的情况，淘宝的登录页面竟然无法进入，一直循环跳转登录页面。 分布式Session 的常见解决方案： 通过cookie进行共享； 借助第三方进行存储，比如缓存； 不容服务器之间进行session同步； 这里面涉及到阿里两个重要级产品：tbsession、passcookie。 tbsession：用来解决多应用间session共享存储与同步问题；tbsession采用的是 方法1 + 方法2的结合； passcookie：用来解决不同域名之间cookie同步的问题，以及决定同步那些cookie； 思考：问：为什么有了cookie 还需要 session？ 答：cookie存储本身具备一些优势，比如信息存储在客户端，分散了资源消耗，cookie可以在客户端进行持久化存储（cookie在客户端分为：Permanent Cookies，Session Cookie）。 主要是只使用cookie作为资源访问的鉴权记录具备不安全性，容易引起CSRF（跨站请求伪造），比如攻击者劫持登录后的cookie信息进行页面操作，此时服务器以为还是用户自身在登录态下的本人操作。当然，只是简单的使用session也并不能彻底解决CSRF，使用session只是把用户的登录态信息保存在服务器端，客户端cookie往往会记录一个JSessionId 用来标识当前会话ID，jsessionid在网络中传输还是存在被劫持的可能性（参考下面的session劫持），所以需要配合响应的解决手段防止CSRF的发生。其次，cookie的使用在大小和条数上限制，大于需要存储大量用户态信息的场景下已经不够用了，此时需要借助session在服务端的存储设备来实现。 问：登录后会会话中的每一次访问受限资源都需要访问验证？ 答：是的，因为每一次请求都无法确认你的身份，所以为了降低复杂认证授权的过程，通过sessionId 来标识某一会话；如果我们的Cookie信息泄露，那么不法分子就可以使用我们包含登录态的Cookie进行访问我们的受限资源（比如拷贝登录后的cookie信息通过postman请求需要登录后才能查看的信息），即便是我们丢增删改的请求采用了crsf_token ,不法分子还是可以看到我们的信息，信息已经造成了泄露。所以对于持久化Cookie，尽量设置为httpOnly，不允许通过JS脚本读取Cookie信息。还有就是使用https协议代替http协议（从tcp到ssl），这样不法分子劫持了请求信息，也无法破解请求信息的内容。 问：是否采用了https就不需要防范CSRF了？ 答：不是的，我们采用https，是在数据传输层对请求进行进行加密后发送，但是如果CSRF是在浏览器的本地读取我们的Cookie信息（存储在我们浏览器中本地的Cookie信息确实明文的），还是可以读取到我们明文的Cookie信息。采用https只是防止了请求在传输中拦截后窃取我们的Cookie进行攻击而已。 Session 劫持与防范：这篇文章详细阐述了服务器端不做任何处理下的sessionId劫持的案例。https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md session 劫持的防范措施： 使用POST 请求 + Referer验证； 此方式简单容易实现； 弊端：1.所有请求都是用POST方式不符合规范，比如RestFul。2.很多场景下请求是无法携带referer的； 使用csrf_token：在涉及增删改的请求中，带上一个和服务器端同步的随机数(token)，然后在服务器端做校验。由于这个token是变化的，同时具有私密性，只会内嵌到当前用户的页面中，因此可以起到防止CSRF的作用，比如淘宝域下cookie中的_tb_token_参数。 csrftoken的整个生命周期一般是这样的： 后端针对每一个用户生成唯一的csrftoken后 将csrftoken存储在服务器端，且和当前用户一一绑定 当用户访问页面时，将csrftoken埋入前端页面 用户提交请求时，需要在请求中附带上csrftoken 后端对接收到的csrftoken进行校验，判断请求是否合法 根据请求，后端判断是非需要更新csrftoken 使用csrf_token 方案目前来说是最有效的安全措施，但是方案实施起来也相对复杂很多，需要考虑csrf_token的存储、更新、埋点以及校验等逻辑。 本质思考：SSO 跨域统一登录的本质就是【登录态信息的跨域共享，为了实现共享采用了复制的方式】，这跟我们现实世界中为了达到知识共享，需要把知识转化为书籍，然后通过书籍印刷进行分发。 抓包工具介绍： 工具采用 mac 下的 Charles； https由于安全限制无法抓取到具体的内容，所以需要通过一些列的设置才能抓到请求数据； Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate Proxy -&gt; SSL Proxying Setting -&gt; SSL Proxying 添加正则域名","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"二零一七，我的失败与伟大","slug":"Think/2017-12-29-2017-my-success-and-fail","date":"2017-12-28T16:00:00.000Z","updated":"2018-11-09T14:28:50.414Z","comments":true,"path":"2017/12/29/Think/2017-12-29-2017-my-success-and-fail/","link":"","permalink":"http://heartaway.cn/2017/12/29/Think/2017-12-29-2017-my-success-and-fail/","excerpt":"","text":"2017年飘然离去，留下的唯有回忆。这一年总有一些刻骨铭心，总有一些难以忘怀，依依不舍。或遗落在某一渡口，或消失在某段站台，或模糊在某页书籍。岁月洗礼而后，一一封存，装帧成册，遗忘的森林，层出不穷的景致，黯淡了记忆的门窗。当又一次轻扣，忽而想起那年夏天的故事，亦或冬天里的恋歌，轻捻时光，掀开了往事，撑开了回忆的帆。这一年有过痛苦、焦虑、烦躁，也有过欢乐，自信和拼搏。 如果说让我用一句话总结一下2017年，我想这句话会比较合适： 认知上升了一个台阶，但仍未能克服行为上的懒惰；工作生活，持续反思与学习，但仍沉溺于专业深度的自卑之中。 如果非要让我从过去一年中对自己的失败和伟大之处做一些“套路”上的总结的话，以下这几天应该被展现出来，愿它们像伴随我成长之路上的路灯，时时照亮我前行的路。 1. 认知升级，追本溯源这一年自己思想的改变应该算是最大的收获了。以前对待事情总是浮在表面，现在会主动去思考事情背后的关系与本质，到底是什么导致了当前的状态，每个人说的话其背后的逻辑是什么；比如当开会、讨论、看演讲时，都会跳出当前讨论的事情，去想他们为什么会这么说，理论基础是什么，期望达到一个什么目标。 近期通过研究高效学习的理论知识，逐步掌握学习知识的方法套路。学习的理论自己在高中和大学阶段坚持的不错，但是工作以来，坚持的并不算好，很多时候，一天过去了，回顾时，是浑浑噩噩的，对自己的人生似乎帮助并不大，感慨自己的浪费生命。记得之前看到过一句话，我们现在做的觉得有挑战的事情，之前已经有很多人应该都做过了，我们只需要看看他们踩过的吭和趟出的路就好的。这点无论是放在编程还是人生上来说，都适用。很多时候，我们不需要重复造轮子，有轮子直接购买使用就好，为自己的工作生活快速提效，这是一个一切为“效率”为核心的时代。 什么是认知升级，就是看到了之前自己看不到的地方，看问题的角度比之前上升了一个角度。如果把认知划分为本能层、情绪层、立场层、利益层、社会心理层、系统认知层和智慧认知层的话，我目前只能算是从本能层走到了情绪层，未来的路还有很多要走。 ​ （图片来自“雾满拦江”） 什么是认知，什么是格局，我觉得有一个例子很不错，值得自己记在心里： 《吕氏套秋》里记载着一则楚王失弓的故事，讲的是楚王去云梦泽打猎，不小心把自己心爱的弓丢了，侍从们要循原路寻找，楚王说，算了吧，不必去找了，楚人失之，楚人得之，到不了别处的。侍从们都很佩服楚王的豁达与胸怀。孔子听闻此事后说，这句话如果去掉“楚”字就好了，不妨说“人失之，人得之。”老子听说了孔子的评论后，也发表了自己的看法。他说再去掉“人”字会更好。那样就是“失之，得之”，这样才符合天道。 2. 把握自己的命运，不要把自己的未来寄托在别人手上 相信炒股的朋友都收到过推销内幕股的电话或者微信，他们通过前一天收盘后的预期与第二天开盘后的涨幅逐步获取你的信任，之后采用盈利分成或者入会费的方式，跟你合作，告诉你什么时间点买哪只股票，什么价位卖出。开始的时候，我确实在短时间内赚了好几千快，感觉他们太牛了，感觉这种赚钱方式比工作快多了，无法克制住自己的贪婪，投入大量的资金进去，此时一次正常的下跌也让我们损失惨重，炒作垃圾股，根本就没有持仓的信心。跳出来好好想一想，如果钱真的这么好赚，他们为什么还要花这么大的心思跟你分成呢？他们过分强调了平分你的收益而把风险完全抛给了你。其次，走位一个多年的老股票，完全听信一个不知专业深浅的人指导，这跟板上鱼肉有何区别呢？即使是赚了钱，你也获取不到技能的提升，对于你后续的投资思路不会有半毛钱帮助，有的只有那点钱了。 正确的投资股市方式是建立其自己投资模式，比如改“投机”为“投资”，注重收益与风险的管理，做优质企业的中长线价值投资等。 其次，这点在个人职业生涯中同样适用，我们伴随着团队成长的同时，也要明确知道自己在职业这个坐标体系中自己的位置，明确自己的目标坐标，通过资源争取或者个人努力，逐渐向目标靠拢，而不是等待着老板或者同事赶着你走。如果事事都是你的老板说了算，你自己没有主见的话，这跟被牵着鼻子走的牛没什么两样，在团队中，你也只能成为“老黄牛”了，当你老了，结果会是“卸磨杀驴”（2017年华为清退老员工事件）。反观自己，以前很少与老板探讨自己想要什么，不要做什么，现在有一定的自信说出自己的诉求，然后主动把握机会磨练自己的独特优势，这一点是一个进步。 3. 矫正心理饥饿的金钱观 由于自己出生在一个比较贫困的家庭，自幼对金钱就分外珍惜，什么钱都不舍得花，甚至认为除了基本保证生活的开支外，一切的花销都是多余的。很多人看到这点肯定会评价说是“抠门”，我们不能拿着自己优越的生活去评论不曾经历的贫穷生活，因为你想象不到，贫穷深入骨髓后是一种什么状态。每当在相亲节目中看到那些抠门的男方的时候，我都很难能理解，然而面对确实大家一边倒式的批判。改革开放40年来，人们的生活质量有了非常的提升，但是很多的养成的节省系统并不是说改掉就能改掉的，就像我父母，他们年幼时经历了大饥荒，知道现在全家年收入超过已经达到小康水平，但还每日担忧未来可能没有饭吃，非要在自家的储藏室中储藏上几袋大米，心理才有安全感，其实这个陈为“心理饥饿”。由于害怕失去钱，害怕自己变得一无所有，所以自己万事都尽量已保守节省的方式在生活，殊不知，在现代经济中，反而认为最安全的方式往往却是最危险的方式，比如父母为了少还一些利息，买房时尽量不让贷款，几乎全款买房，殊不知，合理负债才是家庭财务经营的正确指导。 这个世界正在以超乎我们想象的速度变化，如果我们还保守着过去看似正确的理念生活，那么我们会与优质生活质量相差越来越远。钱是用来花的，不是用来存储的，学会花钱也是一门艺术。合理的消费，不仅有助于提高自身生活质量，还能提高国家的经济效应。现在的我不在为一周多买一次水果而大呼小叫，不再为每餐两人三菜而觉得浪费，为了让自己生活有点品质，还是不是给家里买一些鲜花来装饰装饰，美好的生活反过来会对我们的工作行程正反馈，心情好了，工作效率也会高不少。 自从买了车之后，生活确实变得不一样了，说走就走的旅行变得不再那么困难，自驾游去千岛湖，飞行去昆明、丽江、大理和香格里拉，感受祖国的大美河山和不同的乡土文化，读千卷书，行万里路。世界这么大大，我们应该时长走出去看看，走出工作家庭两点一线之间的线性单调区间。 4. 为专业付费，免费的往往是最贵的互联网在过去5年，倡导的一直是“免费”的文化，让产品免费，让更多用户受益。我们在使用各种软件或者观看各种收费视频的时候，首先先到的是找一找有没有破解版或者不需要收费的服务，为了获得免费的东西，有时候我们花费了大量的时间和精力，事后想一想，如果把时间换算成钱的话，我们是亏了的。往往看似免费的东西是最贵的，这个世界上没有免费的午餐，一切事情都是有成本的，只是有些事情的成本是隐形的，不容易被我们察觉罢了。免费的东西，人人都能力，其质量就很差，我们长期阅读低质的信息，会阻碍我们思维升级。反而那些付费的内容，正因为我们的付费，才促就了内容生产者以更加严谨的态度来对待产品，这是一个良性循环。我们值得为优质内容付费，科学高效的方法论告诉我们，跟随业界一流的牛人学习，才是高效的学习策略之一。 5. 你的圈子决定了你的价值查尔斯琼斯说：通过一个人的朋友圈和他看的书就可以看到5年以后的他，也就是说呢，一个人是他周围5个人的综合体。从而形成了“五次元密友理论”。环境的力量，我们不得不信服。古代有孟母三迁，现代人为了一套学区房挤破脑袋。跟优秀的人在一起，我们会被优秀的气场所影响，观念、行为也逐步会发生改变。 所以很多成功学或者心灵鸡汤类的文章常常建议我们每年主动与比我们自身段位高的人的人交往与交流，虽然在我们与他们交往中会有一定的不适感，但我们需要认识到这是正常的生理反应，是突破舒适区的副作用，我们终究会逐渐习惯，这种不适感会随着我们段位的提升而逐渐消失。 反观身边那些职场中晋升非常快的人，在他们成长的路上，几乎都有一个伙伴，和他们一起成长，帮助他们坚持正确的决定，从而避开错误。一个好的有责任心的伙伴是这样的，无条件的爱你，他本身就渴望成功，成熟，会征求你的建议，在你需要帮助的时候能帮助你，能够陪伴鼓励你！你是不能一个人在成长的道路上走下去的，除非你不想达到顶峰。在看看自己当前身处的环境，是否有这样一个伙伴一同成长，如果没有，我们改如何破局？ 6. 感悟人性狗为什么会对陌生人狂吠，人为什么会对伤害自身利益的言论会极力反驳进而情绪失控？面对巨大利益的时候，我们为什么会贪婪？这些都跟本性有关，了解人性，对我们日常生活非常有帮助，无论是我们做投资还是与人相处。就好像，以前老婆跟我抱怨工作上的不顺利，每次在她还没有说完前，我就不耐烦的打断，一口要求都是你自己的错误，在无法改变别人的前提下，你为什么不改变自己呢，然后噼里啪啦的堆砌出一大推自认为很有哲理性的说教语句，换来的结果总是无话可说。当我知晓了这背后的人性需求后，从说教着改为倾听者、陪伴者，效果一下子就不一样了。人性，是需要持续学习和感悟的东西，未来我会花时间系统性的去了解人性的心理学体系。 7. 成为一名佛系青年 去了一趟香格里拉，接触藏民后，彻底改变了我对藏民和佛教的看法。认知中，藏M是野蛮和暴利的代名词，佛教是无知的人期望佛教来改变自身命运，现在看来，原来自己如井底之蛙般视野短浅，认知还停留在本能层。在一名叫做“幸福哥”的藏M导游解说藏传佛教的信仰之时，自己不知不觉中流下了真诚而感动的泪水。回来的途中，阅读了鬼脚七的《人生所有经过的路，都是必经之路》，感受他在出嫁求佛路中的点滴感悟，领悟颇多，自此下定决心，没事就开始背诵和抄写心经。佛教教会我们如何看待自己和这个世界，这个视角是脱离自我的视角，是以更高层的认识来看到实物的视角；比如“画外看画”，脱离自我，站在旁观者角度审视自己的举止言行，我们会有不一样的思考。 在工作生活中，我也不断践行佛教的自我审视的方法，遇到不开心的或者困惑的事情，也尝试着使用佛教中思想来指导言行，虽然有些时候还是不能控制住自己的身为人的本性，但是我相信，通过不断的练习，终究会抵达彼岸，菩提萨婆诃。 8. 让自己成为有一技之长的专业人才 身为一名软件工程师，但是迟迟没有专业自信，究其原因，是因为自己在专业性上的精力投入远远不够，由于积累的太薄，很多技术都不说不清其核心思想，当面对未知的问题时，顿时会觉得恐慌和无助，更不要谈自信了。如何成为专业的人才，方法和策略其实自己都已知晓，但是迟迟未能行动，即便是行动起来了，也是三天打鱼两天晒网。这是一个道理过剩，行动力匮乏的年代，我们不会因为知道了变得不一样，而会因我们做了什么而不一样。以此祭奠我过去5年的专业自卑感，计划用一到两年时间来培养自己的专业自信。 9. 认清自己的核心优势，差异化竞争总觉得自己啥都能干，但是啥都不专业。在面对当前追求效率的社会大浪潮中，分工越来越细化，我们必须清楚的自己在社会大分工中位置，知道自己相比于其他人有哪些优势，短板在哪里，如何发挥个人的差异化竞争。最近在招聘中，对于那些什么都能干，然后什么研究的都不深入，有没有任何亮点的同学，我们基本都会直接Pass掉。我们常常笑道：如果按照现在的标准，我们也许都面不过当前的岗位。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"The Twelve-Factor App","slug":"Program/2017-12-27-the-twelve-factor-app","date":"2017-12-26T16:00:00.000Z","updated":"2018-11-09T14:26:55.139Z","comments":true,"path":"2017/12/27/Program/2017-12-27-the-twelve-factor-app/","link":"","permalink":"http://heartaway.cn/2017/12/27/Program/2017-12-27-the-twelve-factor-app/","excerpt":"","text":"简介如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论： 使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。 和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。 适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。 将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。 可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。 这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。 背景本文的贡献者者参与过数以百计的应用程序的开发和部署，并通过 Heroku 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。 本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。 我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： Patterns of Enterprise Application Architecture ， Refactoring 。 读者应该是哪些人？任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。 12-factorsI. 基准代码一份基准代码（Codebase），多份部署（deploy）12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。 在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。 基准代码和应用之间总是保持一一对应的关系： 一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。 多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。 尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。 所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。 II. 依赖显式声明依赖关系（ dependency ）大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。 12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。 例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。 显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。 12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。 III. 配置在环境中存储配置通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括： 数据库，Memcached，以及其他 后端服务 的配置 第三方服务的证书，如 Amazon S3、Twitter 等 每份部署特有的配置，如域名等 有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。 需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。 另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。 12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。 配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。 12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。 IV. 后端服务把后端服务(backing services)当作附加资源后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。 类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。 12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。 每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。 部署可以按需加载或卸载资源## 部署可以按需加载或卸载资源部署可以按需加载或卸载资源部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。 V. 构建，发布，运行 严格分离构建和运行 基准代码 转化为一份部署(非开发环境)需要以下三个阶段： 构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。 发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。 运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。 12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。 部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。 每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。 新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。 VI. 进程以一个或多个无状态进程运行应用运行环境中，应用程序通常是以一个和多个 进程 运行的。 最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。 12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。 内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。 源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤做此动作——正如 Rails资源管道 ，而不是在运行阶段。 一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。 VII. 端口绑定通过端口绑定(Port binding)来提供服务互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。 12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。 本地环境中，开发人员通过类似http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。 通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。 HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。 还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。 VIII. 并发通过进程模型进行扩展任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。扩展表现为运行中的进程，工作多样性表现为进程类型。 在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。 这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。 上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。 12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。 IX. 易处理快速启动和优雅终止可最大化健壮性12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。 进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。 进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。 对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。 进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。 X. 开发环境与线上环境等价尽可能的保持开发，预发布，线上环境相同从以往经验来看，开发环境（* 从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面： 时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。 人员差异： 开发人员编写代码，运维人员部署代码。 工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。 想要做到 持续部署 就必须* 想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异: 缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。 缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。 缩小工具差异：尽量保证开发环境以及线上环境的一致性。 将上述总结变为一个表格如下： 传统应用 12-FACTOR 应用每次部署间隔 数周 几小时开发人员 VS 运维人员 不同的人 相同的人开发环境 VS 线上环境 不同 尽量接近后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。 类型 语言 类库 适配器数据库 Ruby/Rails ActiveRecord MySQL, PostgreSQL, SQLite队列 Python/Django Celery RabbitMQ, Beanstalkd, Redis缓存 Ruby/Rails ActiveSupport::Cache Memory, filesystem, Memcached开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。 与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。 不同后端服务的适配器仍然是## 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。 XI. 日志把日志当做事件流日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。 日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。 12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。 这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括： 找出过去一段时间特殊的事件。图形化一个大规模的趋势，比如每分钟的请求量。根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。 XII. 管理进程后台管理任务当作一次性进程运行进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如： 运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。运行一些提交到代码仓库的一次性脚本。一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。 所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。 12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。 转发自：https://12factor.net/zh_cn/","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"DevOps的三种方式","slug":"Program/2017-12-24-devops-three-method","date":"2017-12-23T16:00:00.000Z","updated":"2018-11-09T14:26:59.937Z","comments":true,"path":"2017/12/24/Program/2017-12-24-devops-three-method/","link":"","permalink":"http://heartaway.cn/2017/12/24/Program/2017-12-24-devops-three-method/","excerpt":"","text":"前言这篇博客中提到的“三种方式“源自 《DevOps Handbook》 及《凤凰项目》（The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win.），这三种方式描述了构成 DevOps 的理论框架、流程、实践及价值观和哲学。 感谢《Lean IT》的作者 Mike Orzen 为此文提供宝贵建议。 三种方式下文将介绍三种模式及在该种模式指导下的 DevOps 实践。 第一种方式： 系统思考 第一种方式强调全局优化，而非局部改进。— 大到部门职能划分（例如研发部和运维部门），小到个人（开发和系统工程师）。 这种方式将关注点放在整个业务价值流上。换句话说，整个团队应该关注在从需求被定义到开发，再到运维这个过程，直到价值被以服务的形式交付给最终用户。 将这种方式带到实践中的产出便是永远不要将已知的缺陷传递到下游工作，永远不要为了局部优化影响了整体价值流交付，总是为了增加价值流动努力，永远追求对架构的深刻理解。 涉及到这种方式的实践有： 所有环境和代码使用同一个仓库，将软件包纳入版本管理 团队共同决定发布流程 保持 DEV、TEST、PRODUCTION 环境的一致性 自动化回归测试 小步提交，每日部署；而不是一次部署大量变更 更快、更频繁发布 第二种方式：经过放大的反馈回路 第二种方式是创建从开发过程下游至上游的反馈环。几乎所有的流程改进都是为了从时间上缩短和从覆盖面上放大反馈循环，从而可以不断地进行必要的改正。 第二种方式的产出是关注到价值流中所有涉及到的用户，包括价值流内部和外部的，缩短和放大反馈回路，并且可以随时定位到需要改进的地方。 涉及到这种方式的实践有： 代码审查及配置变更检查 有纪律的自动化测试，使许多同时的小型敏捷团队能够有效地工作 尽早设置监控预警 修复 bug 为团队最高优先级 团队成员之间高度互相信任 团队之间保持沟通和良好合作第三种方式：持续做试验和学习的文化 第三种方式提倡持续做试验，承担风险、从失败中学习；通过反复实践来达到精通。 我们需要实验和冒着失败的风险，及时不断地尝试将我们置于一个危险的境地，我们要通过反复试错来掌握使我们远离危险的技能。 第三种方式的输出为为改善日常工作分配时间、奖励团队冒险精神，将错误人工引入系统以提高系统健壮性。 最具有代表性的就是 Netfilx 的 Chaos monkey ，Netflix 在他们的生产环境搭建一个服务用于定时随机关闭服务器，用以模拟服务器正常损坏或服务异常，他们的系统长期在这种环境下运行，“服务器故障”成为系统每日都要面临的问题，因此当服务器真的以外故障时不会对系统整体造成任何的影响。 译者后记全局优化、快速反馈、鼓励失败。我们发现其实敏捷、精益、持续交付、DevOps中间有很多相似的东西。 参考资料: https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec http://itrevolution.com/the-three-ways-principles-underpinning-devops/ 转发自：@duyidong","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"《那时花开》","slug":"Think/2017-12-20-high-school-years","date":"2017-12-19T16:00:00.000Z","updated":"2018-11-09T14:28:58.816Z","comments":true,"path":"2017/12/20/Think/2017-12-20-high-school-years/","link":"","permalink":"http://heartaway.cn/2017/12/20/Think/2017-12-20-high-school-years/","excerpt":"作品：《那时花开》 字数：约 35000 字 体裁：中篇小说 关键字：校园青春 背景：小说记录了自己以在高中时期一群小伙伴的学习生活，作者：陈晓雷 袁河是高二上学期转到陆可凡他们班的。至于转班的原因却不得而知。不过众所周知的是，陆可凡他们班的语文老师是袁河的爸爸，所以就有人猜测这可能是他爸爸的注意，目的很简单，无非就是为了方便监督和管教儿子学习。那为什么到了高二才转班呢？答案也很简单，因为高二是承上启下的关键学期，既能延续高一时的学习状态，又能为高三做准备，所以这时转班最合适不过了。 转到陆可凡他们班上后，袁河发现了一个奇怪的现象。 比如一般课间休息的时候，同学们都会以固有的方式来放松自己。其中少数同学会走出教室，站在外面的走廊上，抬头仰望天空，认真盘算自己忧伤的心事。或者靠在旁边的栏杆上，低头看着地面，仔细回忆某天的快乐心情。而大多数同学则会三五成群地聚在一起，找一个大家都感兴趣的话题，然后各抒己见，开始谈论。","text":"作品：《那时花开》 字数：约 35000 字 体裁：中篇小说 关键字：校园青春 背景：小说记录了自己以在高中时期一群小伙伴的学习生活，作者：陈晓雷 袁河是高二上学期转到陆可凡他们班的。至于转班的原因却不得而知。不过众所周知的是，陆可凡他们班的语文老师是袁河的爸爸，所以就有人猜测这可能是他爸爸的注意，目的很简单，无非就是为了方便监督和管教儿子学习。那为什么到了高二才转班呢？答案也很简单，因为高二是承上启下的关键学期，既能延续高一时的学习状态，又能为高三做准备，所以这时转班最合适不过了。 转到陆可凡他们班上后，袁河发现了一个奇怪的现象。 比如一般课间休息的时候，同学们都会以固有的方式来放松自己。其中少数同学会走出教室，站在外面的走廊上，抬头仰望天空，认真盘算自己忧伤的心事。或者靠在旁边的栏杆上，低头看着地面，仔细回忆某天的快乐心情。而大多数同学则会三五成群地聚在一起，找一个大家都感兴趣的话题，然后各抒己见，开始谈论。 如果是男生的话，通常都会选择这样的话题。比如昨天的美国篮球比赛。比如目前的世界足球状况。比如台湾当局复杂的问题。比如中国军队使用的武器。比如某部好看的电影。比如某款好玩的游戏。等等等等。 如果是女生的话。那能够谈论的话题可就非常多了。她们可以从几天前在报刊杂志上看到的一则新闻，一直谈论到当今娱乐圈最闪亮的某个明星。她们甚至可以从几年前在自家门前新栽的一棵小树，一直谈论到现在时尚界最前卫的某种发型。永远也说不完的样子。简直匪夷所思。 一般情况下，在上课前，大家都会得出一个令人满意的答案，然后意犹未尽地回到座位上，开始上课。当然也有同学因为观点对立，结果争得面红耳赤不可开交，最终在上课前也没有达成共识。于是等下节课上完后，再接着继续谈论，直到得出相同的观点为止。 对于这样的课间谈论，如果遇到比较感兴趣的话题，袁河有时也会参与其中的。虽然他对那些话题真正知道的并不多，而且发表的见解也有些自以为是。但这并不影响他参与其中的热情。他始终觉得这样做很有意思。特别是在上课感到烦躁不愿听讲的时候，稍微回想一下刚才热烈谈论时的情景，心情马上就会好起来。真有点不可思议。 但是陆可凡，却从来不会参与这样的课间谈论，也从不会关心任何与学习无关的话题。课间休息的时候，他除了上厕所外，几乎一直都坐在教室里面，要么一边左手不停地抚摸耳边的短头发，一边右手握笔默写各种各样的定律，完成各种各样的试题；要么就是一边右手不停地转动白色的圆珠笔，一边左手翻书回顾上节课老师所讲的知识，预习下节课老师要上的内容。好像永远都是这样。除了课间谈论外，对于学校举行的各种文艺晚会或者比赛，陆可凡也从来没有报名参加过。他所做的就是站在台下，当一名最普通的观众。如果节目精彩的话，就轻声鼓掌；如果比赛糟糕的话，就转身离开。仅此而已。 2 袁河曾经问过陆可凡为什么要这样。陆可凡笑着回答说，其实我并非完全排斥和拒绝这些热闹的东西。我知道这些东西确实很有意思。你们通过这些东西能够放松心情，获得快乐。这当然很好。但是我也有自己获得快乐的方法。那就是学习。对我来说，没有什么事情能比学习更让人感到快乐的了。所以我认为实在没有必要参与那些东西。而且你知道的，像我这样的性格，也根本不适合那些东西。怎么说呢？与热闹和喧嚣相比，我觉得只有安静才是最重要的。因为我是一个特别安静的人。我喜欢的只是安静而已。 听完这样的回答，袁河并没有予以反驳。他知道陆可凡所说的都是真的。这一点他非常肯定。因为陆可凡从来没有骗过他。而且在他面前，也从来没有隐瞒过任何事情。毕竟他们是那么好的朋友。 其实袁河转到他们班上没几天就已经知道，陆可凡获得快乐的方法，就是学习。因为他从来只有在课堂上回答问题时，才会格外积极兴奋。也只有在考场上运筹帷幄时，才会露出得意的笑容。整日心醉于很高的分数。完全沉浸在题海之中。几乎有点不可理喻。 而且从陆可凡下课后的表现来看，就会知道他是一个特别安静的人。有一个别人没有注意到的细节是，陆可凡在吵闹的环境下，总是紧皱眉头，有些厌恶的样子。如果吵闹声超出他的承受范围，就会用手掩耳，或者另找静地。向来都是如此。 既然袁河早就知道这些事情，那么他为什么还要明知故问呢？因为他觉得陆可凡一直这样默默无闻死气沉沉地生活很不好。他想认真听一下陆可凡的心里话，然后尽量帮他改变这种现状，让他变得活泼开朗起来。但是陆可凡却说，学习才是他最大的快乐。他真正喜欢的，只是安静而已。言下之意是，他对目前的生活很满意，根本不想改变什么现状，一切最好还是维持原样，不要有所变动。这样袁河就不好说什么了。他想，如果把自己的观点讲出来的话，也许会让陆可凡不高兴。既然如此，那就顺其自然吧。 对于陆可凡提出的“我是一个特别安静的人”这种说法，除了他的两个朋友袁河与赵燕外，几乎所有人都表示不赞同。因为陆可凡平时不爱说话，喜欢沉默。从来不会主动与人交往，更不会刻意去接近谁。走在路上遇到同学，从来不说一句话，总是随便点一下头，或者微笑一下，就算打过招呼了，然后直接走开。在陌生人面前，或者在认识但不熟悉的人面前，总是一副冷漠而又抗拒的表情。别人遇到难题向他请教时，他总是把解题过程写在草稿纸上递给人家，然后继续做自己的事情。所以别人用来形容他的词语，都像是结了冰的刺刀一样，寒冷而又尖锐。比如清高。比如孤傲。比如嚣张。比如狂妄。比如自以为是。比如目中无人。等等等等。反正没有一个好词。甚至还有人在背地里说，他不就是学习好吗？这有什么了不起的？清高什么啊？ 对于这样的评价，陆可凡感到非常气愤。他对袁河说，我只是因为不善言谈，所以才会很少说话。我只是因为害羞，所以才会不与他人交往。我只是因为内向，所以才会不习惯跟人打招呼。我只是因为拘谨，所以才会逃避陌生或不熟悉的人。而所有这一切，都只是因为我喜欢安静而已。我哪里清高孤傲了？我哪里嚣张狂妄了？我哪里自以为是了？我哪里目中无人了？我讲过自己了不起吗？他们怎么能这样说我呢？简直气死人了。 袁河拍了一下陆可凡的肩膀说，他们只是因为对你不了解，所以才会那样说你。这些话你不要放在心上就是了。袁河说完看着陆可凡脸上郁闷的表情，低声叹了一口气，唉，我跟你说过多少次了，要变得乐观开朗一点，要多与同学们交往，可你就是不听。陆可凡说，废话，谁不想跟你一样？可是这些我根本都做不到，你让我怎么变啊？陆可凡说的没错，这些他确实做不到。所以上次袁河才会忍住没有对他说那些话。一切还是顺其自然吧。 3 其实陆可凡一点都不知道，在他们交往之前，袁河也认为他是一个清高孤傲而又狂妄自大的人。因为刚转到他们班上不久，袁河向陆可凡请教学习上的问题，但是陆可凡却一言不发地把解题过程写在草稿纸上递给他后，就不再理他了。很自负的样子。每次在路上碰面，袁河都会主动跟他打招呼，但是陆可凡却向他随便点一下头，便直接走开了。这让袁河特别尴尬。课间休息的时候，袁河在他旁边高声重复某个话题，想吸引他的参与。但是陆可凡却一直无动于衷，总是安静地坐在那里，不停地转动手中白色的圆珠笔。这让袁河感到非常泄气。天下怎么会有这样的人啊？真是没见过！ 高二下学期，学校调整了一次寝室，他们被安排在了同一间宿舍。袁河以为机会来了，便想出各种办法去接近陆可凡。但是得到的依然是那张冷漠的脸。这让袁河相当懊丧。也就从那时起，袁河便认定陆可凡是一个清高孤傲而又狂妄自大的人，除了学习好外，简直一无是处，白白浪费自己的感情。直到后来通过辗转调位做了同桌，他们才逐渐开始交往起来。然而他们之间的关系却毫无进展。因为交往有限。直到那天晚上。一切才得以改变。 记得那天晚上是三个英语自习。平时自习课如果老师不在的话，那么同学们都会安静地坐在那里看书或者记单词。但是那天晚上却有些反常。根本不知怎么回事，教室里面一直闹哄哄的，到处都是噪音，那些班干部们非但对此视而不见，反而还带头说笑。在这样的环境下，袁河与陆可凡完全无心学习。于是便开始聊天。 袁河提议说，我们来谈论各自的初中生活，好不好？陆可凡想了一下，然后点点头表示同意。没想到在谈论的过程中，他们惊奇地发现，两人居然会有那么多类似或者相同的经历。比如，他们都曾当过班长。比如，他们都曾指挥过学校举行的合唱比赛。比如，他们都曾是学校鼓乐队中的一名鼓手。等等等等。两人越说越兴奋，说到最后都有种想哭的冲动。真是相交恨晚啊。 三个英语自习就在他们的追忆和谈笑中结束了。而以前袁河对陆可凡的所有误会，也都在谈笑间灰飞烟灭了。那天晚上，袁河才发现，其实陆可凡是一个很亲切，很随和，很容易接近的人。后来，他们就成为了朋友。 对于“陆可凡是一个很亲切很随和很容易接近的人”这种说法，又是除了他的两个朋友袁河与赵燕外，几乎所有人都表示不赞同。他们用来形容陆可凡的还是那些冰冷而又潮湿的词语。不过对此陆可凡已经不在乎了。他曾对袁河说，我发现想要取悦每一个人，或者指望别人都来理解你，那是根本不可能的。所以他现在常说的一句话就是，走自己的路，让别人说去吧，不管他们说什么，就当自己没听过。 对于陆可凡这样的心态，袁河当然可以理解。毕竟被人误会的滋味可不好受，与其怀恨与心，不如充耳不闻。没办法。不得已而为之。 对于那些出言贬斥陆可凡的人，袁河也能够理解。毕竟陆可凡所有的行为，给人的感觉，就是清高孤傲，目中无人。再说自己以前不也是这样认为他的吗？没办法。想要接近陆可凡实在太难了，想要成为陆可凡的朋友，那就更难了。别人当然会这样说他！ 袁河曾经试图想要跟别人解释陆可凡不是那样的人。但是他们根本不听，你以为我们会相信你所说的话吗？你是他的朋友，当然会替他开脱了！于是袁河只好闭嘴。但是他在心里却说，总有一天，你们会重新认识陆可凡的！ 4 对于陆可凡的另外一个朋友赵燕，袁河感到非常好奇。 因为在他和陆可凡成为朋友之前，他们就已经是朋友了。所以袁河并不清楚他们之间的交往过程。据他所知，陆可凡与赵燕是高一下学期分文理科之后才认识的。在这之前，他们陌生的就像间隔了几万光年的两个星球一样。根本不知彼此。 说到这一点，其实大家都一样。因为大家都是不同地方的人，初中都在不同的学校读书。经过中考的筛选，大家才来到了这所学校，走进了这个班级，然后才慢慢认识的。当然也有例外，就是两人从小便在一起读书，几乎没有分开过，当然这种情况很少。至少陆可凡与赵燕就不是。他们的确是高一下学期分到这个班后才认识的。并且也仅仅只是认识而已。彼此都不熟悉。 因为陆可凡从来都不会主动和人说话，尤其不和女生说话，至于跟女生交往做朋友，那就更别提了。那么他们到底是怎么成为朋友的？而且关系还那么好？ 直到袁河与赵燕成为同桌后，他才终于弄明白了陆可凡与赵燕之间的交往过程。 说起同桌，袁河已经想不起来赵燕究竟是他第几个同桌了。因为他爸爸经常毫无缘由地调座位。表面上说是为了促进大家团结，其实是为了防止男女生做同桌时间长了谈恋爱。所以他的同桌总是一变再变。最后同桌就从陆可凡换成了赵燕。至于陆可凡与赵燕之间到底穿插了几个同学，袁河早就已经记不起来了。有时袁河会想，那些人恐怕也早已忘记我这个同桌了吧。 那天中午，袁河在食堂吃完饭回到教室，发现陆可凡正坐在自己的位子上，给同桌赵燕讲题，于是就转身坐到了陆可凡的位子上。 陆可凡就是这样的人，如果别人向他请教题目时，他总是把解题过程写在草稿纸上，然后递给人家，就算完成任务了。但是袁河与赵燕向他请教题目时，他则会非常认真地讲解，绝不敷衍。而这也正是别人那样说他的原因。 袁河曾经问过陆可凡可不可以像对待他们那样给别人讲题。陆可凡摇摇头说，对不起，我做不到。袁河问为什么？陆可凡说因为那样会让他感到拘谨，浑身不自在。然后袁河就不再说什么了。因为无话可说。 5 袁河坐在陆可凡的位子上，随手拿起一本书，刚准备翻阅，却忽然有样东西从里面掉了下来。袁河低头一看，是一个非常漂亮的蓝色纸飞机，心想陆可凡真有闲情逸致，都这么大的人了，还折纸飞机玩，未免也太幼稚了吧。 袁河笑着拾起纸飞机，边看边想，等以后有机会了，好好嘲笑一下陆可凡，问他是不是还在过童年。真有意思。 袁河看着看着忽然发现，纸飞机被折叠起来的部分隐隐约约写有几行字，心想陆可凡居然能把公式定理之类的东西默写在这里面，真是太有才了。自叹不如。 袁河把纸飞机放在眼前，仔细看了看，觉得里面写的东西根本不像公式定理什么的，但是却又无法得知里面到底写的是什么。 因为首先那张纸有点厚，其次从外面看字体是反的，再者那些字由于折叠的缘故，大部分都重合在了一起，所以看来看去，毫无头绪。努力辨认，也只能看到个别字的大致轮廓。根本无法得知里面写的内容。 看到最后，袁河可以肯定的是，那些字绝对不是陆可凡写的。因为陆可凡的字，横七竖八，张牙舞爪，仿佛九曲黄河，亦如山路十八弯，如果不知道的，还以为那是甲骨文呢。像这样清秀美丽的字体，打死他都写不出来。如此说的话，这个纸飞机肯定不是陆可凡折的。那会是谁折的？从字体来看，应该是一个女生写的。那么这个女生到底是谁呢？ 袁河很想拆开纸飞机，看一下里面到底写的什么内容，但是后来一想，这可是陆可凡的隐私啊，自己不能这样做，于是便放弃了这个念头。算了，等以后有时间了再问他吧。这样想着就把纸飞机重新夹在了书中。 袁河刚把书放好，陆可凡就回来了。 袁河问，题目讲完了？ 陆可凡笑着点点头。 袁河起身拍了一下陆可凡的肩膀，然后回到自己的座位上，开始做数学题。仿佛刚才什么事情也没有发生过。 袁河才做了三道题就卡壳了，急得心烦意乱抓耳挠腮。 赵燕见状问他怎么了。他指着第四道综合题说，做着做着遇到一个碉堡，攻不下来，都快把我给急死了。 赵燕也幽默地说，那就让我来帮你炸掉它吧。说完看着袁河微微一笑，陆可凡刚才已经给我讲过这道题了。 提到陆可凡，袁河忽然想起有个问题还没有向她请教，于是等赵燕讲完题目便问，哎，那个，你和陆可凡是怎么成为朋友的？ 赵燕一愣，你怎么突然想起问我这个问题？ 袁河挠了一下头，到目前为止，我还没有看到陆可凡和其他女生说过话，但是他在你面前却无话不说。对此，我真的很好奇啊。 袁河用手捋了一下眼前的头发，你可不可以跟我说说你们之间的交往过程啊？当然，如果不方便说的话，那就算了。 赵燕看着他脸上略带祈求的表情，忍不住扑哧一笑，你真想知道吗？ 袁河笑着点点头，肯定了，要不然我问你干吗？ 赵燕说，其实我们之间的交往很简单，根本没啥可说的，不过，既然你想听，那我说说也无妨。然后赵燕就像电影中的主人公一样，低下头开始回忆。 6 那时高一下学期文理科分班已经有几个星期了，同学们差不多都已经相互认识彼此熟悉了。课间休息的时候，大家再也不会像刚分班那样，死气沉沉地坐在位子上，望着天花板发呆，而是纷纷走出教室，然后三五成群地聚在一起，谈论各种各样的话题。以此放松心情。当然也有同学会安静地坐在教室里面，专心做自己的事情。比如，陆可凡。 那天应该的星期六吧。赵燕记得那天下午第二节课上完后，同学们都纷纷走出了教室。不过这个时候，大家谈论的内容，已经不再是天下新闻，或者娱乐八卦，而是明天的出行计划，以及活动安排。因为明天就是周日了。 可是赵燕和好友林依然还没有说完周日的计划安排，上课铃便响了。于是在回到座位的路上，赵燕边走边扭过头，继续和林依然商量。 忽然只听“咔嚓”一声，好像踩断了什么东西。 赵燕吓了一跳，连忙转过身低下头，只见脚边一支白色的圆珠笔已经碎成几片，眼看是不能用了。而此时的陆可凡，正弯下腰伸出手，准备去捡那支笔。 这到底怎么回事？ 原来第二节下课后，陆可凡坐在位子上，一边认真地复习刚才老师所讲的知识点，一边不停地转动手中白色的圆珠笔。上课铃响后，他开始准备第三节课要用的东西。结果不小心，把笔掉在了过道上。等一切准备就绪刚要去捡笔时，却没想到被赵燕踩成了碎片。于是一切就变成了现在这个样子。 赵燕还没有来得及向陆可凡道歉，老师就已经来了。赵燕只好慌忙地说声对不起，然后回到了自己的座位上。 陆可凡浑身上下只有这支白色的圆珠笔，没有备用的，可是现在却被赵燕踩碎了，无法抄写板书，急得手心直冒汗，本想张口跟同桌借支笔用，但是想到平日与同桌尴尬的关系，便放弃了这个念头，正在这时，肩膀忽然被人点了一下，惊得差点跳起来，于是趁老师转身写字的空当，回过头问后面那位同学为什么戳自己。那位同学什么也没说，只是拿起桌上一支粉红色的钢笔递给他。陆可凡接过笔，连忙道谢。不料那位同学却挥了一下手说，不用谢我，这支笔是赵燕的，我只是负责传递而已。 因为那个同学对陆可凡很有意见，总是经常在背后对人讲，他不就是学习好吗？这有什么了不起的？清高什么啊？所以刚才说那些话时，脸上的表情异常冷漠，而且说话的声音也像在冰箱中冻过一样，寒气逼人。陆可凡没有理他，转身开始抄写板书。 说起上课传递东西，真可谓历史悠久。至于久到什么年代，谁也说不清楚。因为各类文献上均没有记载。 陆可凡想，如果有人要考证这个东西的话，也不知道要追溯到多少年前。在陆可凡的记忆中，好像自从上学后，班上就有人开始趁老师不注意传递各种东西了。 至于传递的东西简直千奇百怪。比如，水果，零食，橡皮，衣服等等。不过传递的最多的却是小纸条。因为方便。而且隐蔽。不易被老师发现。所以很受同学欢迎。 至于传递的距离则有远有近。最远的便是对角线传递。而最近的则是同桌间的传递。并且传递的方式还多种多样。有从课桌上面递的。有从桌子下面传的。有从空中直接用手抛的。有从地面干脆用脚踢的。等等等等。想想真有意思。 直到老师将本节课的重点内容大声重复了一遍，陆可凡这才回过神来，发现自己思想开小差了，顿时懊恼不已。 陆可凡抄完板书，准备盖笔套的时候，才忽然发现笔上缠有一张小纸条。他把小纸条取下展开，只见上面写道： 陆可凡，上课前不小心把你的圆珠笔踩坏了，真是对不起啊，我不是故意的。那个……放学后请不要走好吗，我有件事想跟你说。 末尾署名是，踩坏你笔的那个人。 陆可凡想，不就是一支小小圆珠笔，用得着这样郑重其事吗？她说有事要跟我讲，到底什么事呢？算了，等放学后再说吧。 若在平时，以陆可凡那样的性格，早就拒绝了赵燕的请求。但是现在他却答应了。 因为赵燕的笔还在他手上。他应该把笔还给人家。再者他也有些好奇。赵燕到底会有什么事情要跟自己说呢？最主要的是，他觉得赵燕这个女生还不错，不像其他女生那样令他讨厌。所以顺理成章就答应了赵燕的请求。 7 下午放学后，等其他同学都走光了，赵燕这才走到陆可凡面前，抱歉地说，真是对不起啊，我不是故意要踩坏你的笔，我只是…… 陆可凡轻轻打断她的话，没关系，不就是一支笔嘛，踩坏后再去买就是了，你这样客气反倒让我觉得有些不好意思。那个，你有什么事要跟我说？ 赵燕微微一笑，为了表示歉意，明天中午，我想请你吃饭，怎么样？我已经和林依然约定好了。 陆可凡原本想说谢谢算了不用吧。但是看到赵燕脸上的笑容，有些不忍拒绝，于是犹豫了一下便答应了。 等赵燕转身已经走出很远了，陆可凡这才想起来笔还没有还给她，于是大声喊道，你的笔还在这里呢。 赵燕停住脚步站在窗户前笑着说，那支笔送给你好了，算是赔偿吧。说完就从窗户边消失不见了。 陆可凡看着手中粉红色的钢笔，轻轻摇摇头，径直走到赵燕的课桌前，把笔放进她的文具盒中，然后下楼走进商店买了一支白色的圆珠笔，这才满意地笑了。 第二天中午，陆可凡，赵燕，还有林依然，他们三个人是在校园外面一家名叫“三回头”的小餐馆里面吃的饭。 虽然这家餐馆名字起的俗不可耐，听着极不舒服，但是因为这里环境优美，饭菜可口，价格实惠，所以像生日聚会或者请客吃饭什么的，大家一般都会选择这家餐馆。有些人都不知道已经回过几次头了。 三人在吃饭的时候，陆可凡与赵燕一直不停地说话。而林依然则自始至终都沉默不语。就像绿叶一样，成为他们两个人的陪衬。 好像从那以后，陆可凡与赵燕就成为了很好的朋友。 8 赵燕讲完这些，看着袁河笑了，谁说陆可凡是一个清高孤傲而又狂妄自大的人？简直胡说八道。陆可凡根本就是以个很亲切，很随和，很容易接近的人。 袁河点点头表示同意。 赵燕忽然说，哎，有时候我发现，你与陆可凡还蛮像的。 袁河笑了笑，你终于看出来了，其实这正是我转班的原因。怎么样，觉得特不可思议吧。我跟你说啊，高一上学期刚开学的时候，就有人说我们长得像。那天我和一个同学在食堂吃饭，正吃到一半，同学突然用手推了我一下说，你有没有发现那个人和你长得很像啊。我说那个人，同学用手指了指不远处同样也在吃饭的陆可凡说，就是他，你看和你像不像。当然那时我并不认识他。我顺着同学指的方向看去，果然发现那个人和我长得很像，觉得这是缘分，于是就萌发了想转到他们班上的念头。后来我到处打听，才知道他就在我爸爸带的班上，于是便央求爸爸转班，可是我爸起初死活不答应，说在哪个班学习都一样，没必要转班，我说为了方便您监督和管教我的学习，就让我转到你的班上吧，我爸一想也对，于是就答应高二的时候让我转班。所以我就转到你们班上了。 袁河说到这里停顿了一下，然后说，你知道我当时最担心什么吗？赵燕问，你最担心什么啊。袁河回答说，我当时最担心的是，高一下学期分文理科后，陆可凡还在不在我爸的班上，要是不在的话，那我岂不是白转了。没想到他报的是理科，居然还在我爸的班上，你说这是不是缘分？ 赵燕说，嗯，看来你们真的很有缘。不过我的意思是，除了长得有些像外，在某些方面，你们也蛮像的。 袁河问，什么方面？性格吗？不会吧。我和他的性格可是相差几万光年呐，坐飞机都追不上的，像什么像啊？真佩服你的眼力。 赵燕反问道，谁说你们性格像了？甭说飞机了，就是坐火箭也不行呀！我是说，在某些方面，你听不懂啊？ 袁河搔了一下后脑勺儿，嗯，让我好好想想。 9 袁河想了半天，倒是想起了一些东西。他对这些东西慢慢回忆，细细品位，发现赵燕说的没错，在某些方面，他与陆可凡还确实蛮像的。 他记得有很多次，他们都不约而同地说出了同样的话语；有很多次，他们都心照不宣地写下了同样的文字；有很多次，他们都心有灵犀地做出了同样的动作；有很多次，他们都不由自主地选中了同样的东西…… 袁河还想起了很多与陆可凡做同桌时所发生的事情。 记得那时袁河有一个专门用来写字绘画的黑色笔记本。他们做同桌的时候，如果平时闲着无聊了，或者上课不想听讲了，就会在那个笔记本上信笔涂鸦，然后在下面标上日期，怡然自得。曾经有很多次，他们都画出了同样的图画。每当这时，两人就会相视一笑，然后把手紧紧地握在一起。虽然不说一句话，但是心里却已温暖如春。 现在回想起这些事情，心里忽然有种特别的感觉。到底是什么感觉呢？嗯，应该是那种很甜美很温馨的感觉，就像池塘中被风吹拂的莲花，微露出清淡的甜，散发出诱人的香，让人沉醉其中，让人回味无穷。 袁河觉得上高中能够和陆可凡成为朋友，是他今生最大的幸运，也是他今生最大的快乐。如果没有陆可凡的话，那么他的生活就不会像现在这样精彩，而他的记忆也不会像现在这样丰盈。 不知道为什么，袁河突然有种想哭的冲动。但是最终却没让眼泪掉下来。因为他是男子汉，不能流泪。 袁河朝赵燕看去，发现她正在做题，于是也拿出习题册做了起来。 10 因为袁河与赵燕是同桌关系。所以平时闲着没事了，或者题目全都解决了，两人就会坐在位子上聊天。海阔天空地闲聊。从古说到今。从天说到地。从西方说到中国。从现在说到将来。没完没了。无头无序。但是却很快乐。 不过通常情况下，都是赵燕在手舞足蹈不停地说话。因为袁河根本插不上嘴。所以只好专门负责倾听。袁河想，其实这样也挺好的，能够增长见识，可以开阔视野，嗯，不错！ 但是很多时候，赵燕说着说着就会突然把话题转移到自己身上来。弄得袁河莫名其妙猝不及防。其实说句心里话，与那些稀奇古怪乱七八糟的新闻相比，袁河更喜欢听她讲述自己。因为真实。 自从做同桌以来，赵燕向他说过很多自己初中美好的生活，对他讲过很多自己亲身经历的事情，跟他谈过很多自己内心真实的想法。袁河经常听的入神。 赵燕曾对他说，有很多东西，我从来都没有跟其他好朋友提起过。包括林依然。包括陆可凡。但是我却跟你说了，请你替我保守秘密，千万不要讲出去，好吗？袁河笑着点了点头。其实就算她不提醒，袁河也不会将这些告诉别人的。因为那份信任。赵燕每次讲述完毕都会说，我现在感觉轻松多了，如释重负。不过又浪费你时间了，真是对不起呀。袁河说，没关系啦。说完他们相视一笑，然后开始看书做题。彼此很有默契。 11 一般情况下，袁河与赵燕在一起聊天时，几乎没有人来打扰，所以他们通常都会聊得很完整，聊得很尽兴。可是有几次，两人刚聊到一半正高兴时，却被人硬生生给掐断了，简直非常郁闷，非常扫兴。而那人却偏偏正是赵燕的好朋友林依然。所以碍于情面，袁河只好忍住不发火。但是心里却非常的毛，无论做什么事情都不顺手，只有等情绪慢慢稳定后，一切才能恢复正常。 最初两次，袁河还能表示理解。毕竟林依然是赵燕的好朋友。但是后来就有些忍不住了。最后极力控制自己，才终于没有爆发。可心里却已经开始讨厌林依然，甚至都有些痛恨她了。我看这个女生真是一点涵养都没有。你为什么偏偏要在这个时候来找我的同桌啊？难道不能晚些吗？真是太扫兴了！事后想起刚才偏激的行为，袁河不禁暗骂自己心胸狭窄。因为这点小事，怎么可以如此讨厌和痛恨自己同桌的朋友呢？这样是不是太过分了？还好刚才没有把这些东西彻底表现出来，否则的话……不敢想象。 12 这天中午，袁河与赵燕把所有作业完成后，又闲着没事了。赵燕打了一个哈欠，转过头对袁河说，我有些困了，但却不想睡觉，你陪我聊聊天，行不行？ 袁河笑着说，当然行了，我们是同桌关系，用得着这样客气吗？说吧，想聊些什么？我奉陪到底。 赵燕说，那就聊聊周杰伦吧。 袁河惊道，可是我对他知道的并不多，我只是听过他几首歌而已。怎么聊啊？ 赵燕说，既然这样，那你就听我讲好了。 袁河耸耸肩，也只能这样。唉，看来我又要增长见识了。 两人刚聊到一半的时候，林依然走过来低声对赵燕说，我想跟你说件事，你可不可以出来一下？ 赵燕说，当然可以了，我们是朋友嘛。说完看了看袁河，不好意思，我出去一下，马上回来再接着聊吧。袁河点了点头。 赵燕从教室外面走进来的时候，见袁河正一动不动地低着头，便走上前问，怎么？又为林依然打断话题感到不高兴了？真小气！ 袁河抬起头说，我对此早已习惯了，哪有不高兴啊？我只是在思考一个问题而已。 赵燕眨了一下眼睛，思考什么问题呢？ 袁河说，我发现林依然的性格和陆可凡差不多，都害羞内向，都不爱说话，都不愿交往，总是一直保持沉默，总是一直埋头不语。课间休息的时候，除了偶尔和你出去说说话外，几乎一直都待在教室里面，做自己的事情，好与世隔绝了一样。我记得在你和陆可凡成为朋友之前，你们就已经是朋友了。所以我在想，你和她又是怎么成为朋友的？唉，真伤脑筋啊。 赵燕低头一笑，你不会又要问我和林依然的交往过程吧。 袁河说，聪明！但你不要告诉我，因为你们都是女生。 赵燕看着袁河，如果我说就是这个原因呢？ 袁河双手一摊，那就当我什么也没问好了。 赵燕做出一个“无法理解”的样子，你的好奇心为什么那么强啊？怎么什么都想知道？ 袁河说，没办法，这些事情都发生在你身上，实在太不可思议了。我只是想了解一下其中的内幕，看看到底怎么回事。 袁河停顿了一下，然后抬头望了一下天花板，以开玩笑的口吻说，或许将来，我可以根据这些材料，编写一本书，名字就叫《如何与性格内向的人成为朋友》。你说如何？ 赵燕白了他一眼，亏你想得出来。不过，你真想知道吗？ 袁河说，废话，要不然我问你干吗？ 赵燕笑了一下，其实我们之间的交往很简单，根本没啥可说的。不过既然你这么想知道，那我说说也无妨。 袁河抚摸了一下耳边的头发，自语道，奇怪，这样的对话为何如此耳熟？好像曾经在哪里出现过？ 赵燕说，就在上次你问我与陆可凡的交往过程中出现过。看你什么记性！ 袁河恍然大悟，哦，我想起来了，你现在开始讲吧。 13 记得高一刚开学那天，赵燕报完名，走进办公室一楼的大厅内，迅速浏览了一下张贴在墙壁上的教室分布图和寝室安排表，便开始根据学校发的地图，寻找商店和食堂。毕竟民以食为天，温饱最重要，先把这些问题解决了再说。至于自己在哪个班，通知书上早就写好了，到时只需对号入座即可。 赵燕找到商店和食堂后，看了一下环境和规模，感觉不错，心想高中就是不一样，简直比初中强多了。嗯，还算满意。 赵燕刚要离开，却忽然发现有个女生正坐在食堂的餐桌前，低着头伤心地哭泣。赵燕觉得非常奇怪，刚踏入新的学校，大家高兴还来不及，她怎么会坐在这里哭呢？是想家了吗？不会啊，今天才刚开学，哪有这么快就想家的道理？而且看样子也不像是在想家。那到底怎么回事？ 赵燕走上前轻声问她怎么了？可是那个女生却没有回答，只是一直哭。 赵燕连着问了几遍，这位同学，你怎么了？那个女生才抬起头来。虽然已经停止了哭泣，但还是什么也没有说。 赵燕换了一种方式，请问你是哪个班的？ 女生犹豫了一下，我是高一（4）班的。 赵燕激动地说，我也是那个班的。嗯，你住在几号寝室？ 女生回答说，寝室安排表上写的是2栋410寝室。 赵燕听后显得更加激动了，原来我们住在同一个寝室。啊，太好了。那么，可以告诉我你叫什么名字吗？ 女生说，我叫林依然。 赵燕把名字念了一遍，品味道，名字真好听。哎，对了，我叫赵燕。说完看着林依然，你刚才怎么了？为什么会坐在这里哭呢？是不是遇到什么麻烦了？ 林依然起初不愿讲。赵燕说，我们既待在同一个班级，又住在同一个寝室，难道还有什么不好意思讲的吗？说出来吧，或许我还能为你做点什么。林依然低下头沉默了一会儿，觉得赵燕说的没错，在她面前确实没有必要遮掩什么，于是便把事情的原委全部跟赵燕说了。 原来林依然报完名，看过教室分布图和寝室安排表后，怀着与赵燕同样的心理，来到了食堂。等她观看完毕坐下休息时，才猛然发现，这两个月装在口袋中的生活费丢了，顿时吓得六神无主，当即哭了起来，一直哭到刚才赵燕出现。 赵燕问她，那你现在身上还有没有钱？ 林依然回答说，一分也没有了，全部都掉光了。 赵燕问，那你为什么不跟家里说，而是坐在这里哭呢？ 林依然说，我不敢跟家里说。如果父母知道我把钱弄丢了，他们会凶狠地打我的。 赵燕没有再继续问下去。她看着眼前有些可怜的林依然，同情心油然而生，当即从身上掏出一百元递给林依然说，这些钱你先拿去用吧，不必急着还，如果不够的话，你再跟我说，我会想办法的。 这些钱对林依然来说，无疑是雪中送炭，因此双手接过钱后，感动的又哭了起来。 赵燕拿出纸巾替她把眼泪擦干，然后说，如果你不嫌弃的话，我们做朋友怎么样？ 林依然使劲地点了点头。大颗的眼泪又开始往下掉。 赵燕看见林依然哭泣的样子，突然有种想要拥抱她的感觉，于是张开了双臂。林依然见状也张开了双臂。然后两人紧紧地拥抱在了一起。很久很久都没有分开。 后来，她们就成为了最好的朋友。 14 袁河听完赵燕的讲述说，原来是这样啊。那她每次找你都是借钱用吗？ 赵燕说，差不多吧。其实她父母每个月给她的生活费都很少，根本不够用的。那几次我们聊天刚进行到一半的时候，她来找我借钱，只是碰巧而已。至于私下都不知道借过多少回了。直到现在她还欠我五十呢。可是我却不想问她要了。就当是我资助她吧。虽然杯水车薪，但也总是我的一点心意。 袁河轻轻叹了一口气，唉，没想到是这样啊。 赵燕说，我知道你对林依然有些反感。那几次她来找我借钱，我从你的反应就看出来了。不过我想你可能是误会她了。其实她人挺好的。我不骗你。 袁河搓了搓手，看来以前我对她的了解还是不够啊，听你这么说，我真想跟她交往一下。 赵燕说，我觉得有这个必要。说不定将来你们还可以成为朋友呢。 袁河刚要讲什么，这时林依然又走过来低声对赵燕说，你可不可以，出来一下？ 赵燕点点头便出去了。十分钟后才回来。眼睛红红的，好像哭过。 袁河问，她刚才不是已经找过你了吗？怎么又找啊？你眼睛怎么红了？你怎么了？ 赵燕说，她第一找我是向我借钱的，我借给她了五十。而她这次找我是还我钱的，她还给我了一百。 袁河问，她怎么还你一百啊？ 赵燕说，她之前还欠我五十呢。 袁河问，你刚才不是说不要那五十块钱了吗？ 赵燕说，是啊，我原本是不想要的，但是她却非要坚持还给我，最后实在推脱不下就接住了。 袁河点了点头表示理解，可马上又问，她刚才还跟你借钱，现在怎么会有钱还你呢？ 赵燕回答道，她说今天上午有个老乡来学校看望自己的孩子，于是她妈妈就让这个老乡顺便给她捎来了下个月一百五十块的生活费。她也是刚刚才收到的。然后就迫不及待地要还我钱。我说你先用吧，不用这么快还我。但是她却说，虽然我们是这么好的朋友，可我并不想无故接受你的馈赠，也不愿欠你任何东西，否则我会感到不安的，你还是收下吧，等这剩余的五十块用完了，我再向你借，好不好？说完用很纯真的眼神看着我。袁河你知道吗？我当时鼻尖一酸，差点就哭出来了。我接过钱说，那好吧，就这样，我先进去了。可是刚转过身，眼泪就拼命地往下掉。我是在外面等情绪稳定后才进来的。 赵燕说完从文具盒中拿出一块小镜子，开始看自己刚才哭红的眼睛。 就在赵燕拿镜子的时候，袁河看见在她文具盒中放有一支粉红色的钢笔，心想，那天赵燕把陆可凡的圆珠笔踩碎后，上课传递给陆可凡的应该就是这支笔吧。没想到这支笔竟使他们成为了朋友。真是不可思议。 赵燕对着镜子擦了一下眼睛，然后故作轻松地说，嗯，我好了，没事了。现在时间还这么早，我们再接着聊天。行不行？这次你来选话题。 袁河说，那就聊一下林依然吧。我现在对她非常好奇。 赵燕放下镜子，好呀。那我就跟你讲讲我们之间曾经发生的一些事情吧。 袁河做出一个“洗耳恭听”的动作，开始吧。 15 那天赵燕跟袁河讲了很多她与林依然之间曾经发生的事情。但是除了那两件事情，袁河现在基本上都已经想不起来了。到底是那两件事情让袁河记忆如此深刻难以忘怀？到底是那两件事情让他在很久之后回想起来都还觉得温暖？袁河低下头，嗯，让我好好想一下。于是他的思绪又回到了那天的谈话之中。 记得那天赵燕讲着讲着，忽然从课桌内拿出一双手套问袁河，你知道这双手套是谁送给我的吗？ 袁河摇了摇头，我不知道。 赵燕说，是林依然一个月前送给我的。然后沉默了一下，接着说道，其实有很多人都不知道，我从来没有戴手套的习惯。从小到大，每年冬天，我都不戴手套，而且我的手也从来没有被冻肿过。虽然说今年冬天来得稍微有些早，而且比以往更加寒冷，但是我完全可以忍受。根本没有必要戴手套的。可是当我打开课桌看到躺在里面的手套时，我感动得差点落泪。你说朋友是不是就是在你感到寒冷时，给你送去温暖的那个人？那双手套我只戴了一天就把它取下来重新放进了包装袋中。我会好好珍藏那双手套，直到永远。 赵燕讲完这件事，眼中早已含满泪花。但是她却并没有用纸巾去擦，而是继续说，还有一件事情更加让我感动，你想听吗？ 袁河点了点头表示想听。 赵燕这才拿出纸巾擦干眼泪，然后说，记得刚开学有段时间，我上火特别厉害，几乎每天早上洗脸都要流鼻血，吃完两盒三黄片竟然都不起效，林依然得知情况后，便步行走到县城的一家药店内给我买药。就是那种直接用开水冲服的中药。她听别人说喝生鸡蛋可以清火，便又到超市给我买了一斤生鸡蛋。你知道这些东西总共花了她多少钱吗？将近六十啊。可从我们学校到县城那么远的距离，她却舍不得花六块钱坐车，硬是步行来回。所以当她把这些东西放到我面前时，我当场感动得泪流满面一塌糊涂。我给她钱，可是她却不要。她说所有这一切都是她心甘情愿的，因为我是她最好的朋友，值得她这样为我做，让我不要再哭了。而且那几天，我水壶里面的水，也一直都是满的，都是林依然帮我打的。你说我能不哭吗？我觉得上高中能够和林依然成为朋友，是我今生最大的幸运和最大的快乐。希望我们之间的友谊能够一直延续到地老天荒。 不知道为什么，袁河听完最后这两句话，一下子就想到了陆可凡。他想自己跟陆可凡不也是这样的吗？ 但愿所有人之间的友谊，都能够海枯石烂，地久天长！ 16 一天下午放学后，赵燕从课桌内拿出一个天蓝色的笔记本，然后打开从里面取出一样东西让袁河看。袁河看后惊得差点跳起来。因为此刻赵燕手中拿的这样东西，居然就是那天自己坐在陆可凡的位子上，随手拿起一本书，刚准备翻阅，却忽然从里面掉下来的那个非常漂亮的蓝色纸飞机。 赵燕看着袁河脸上吃惊地表情问，你怎么了？ 袁河这才回过神来，没什么。这个纸飞机是陆可凡送给你的？ 赵燕扑哧一笑，亏你想的出来。现在哪有男生折纸飞机玩啊？告诉你吧。是林依然送给我的。 袁河感到莫名其妙，她为什么要送你纸飞机啊？ 赵燕说，因为我是她的朋友呗。 她见袁河脸上满是困惑的表情，便故作神秘地说，你不知道吧，像这样的纸飞机呢，她只送给三种人。第一种就是她的朋友，第二种就是关心她的人，至于这第三种嘛，就是她喜欢的人。不过到目前为止，除了我之外，她好像还没有把纸飞机送给第二个人。你看，她在纸飞机折叠起来的部分还写着几行字呢。 袁河仔细看了一下，发现确实如此，跟那天在陆可凡位子上看到的那个纸飞机差不多。 赵燕问，你想不想知道，她在这里面写的什么内容？ 袁河说，算了吧，这是你的隐私，我估计不方便知道。 赵燕说，我所有的隐私和秘密，你差不多全都知道了，难道还怕再多知道一点吗？ 袁河做了一个无辜的表情，那是你主动要跟我讲的，又不是我逼你说的。你…… 袁河还没说完，忽然发现赵燕正愤怒地看着自己，连忙投降说，我现在很想知道里面到底写的什么内容，你快讲吧。 赵燕这才露出笑容说，那我就告诉你吧。我刚才是假装生气的。 袁河发现自己上当了，不再理她，拿起饭盒，要去食堂吃饭。 赵燕说，现在食堂里面人很多，你去排不上队的。 袁河冷冷地看了她一眼，虽然排不上队，但总比在这儿上当受骗强吧。 赵燕说，我错了，好不好？我跟你说里面写的内容，好不好？你不要用那种眼神看着我，好不好？ 袁河说，这还差不多。然后放下饭盒冲赵燕一笑，我刚才也是假装生气的。 赵燕把纸飞机拆开，只见上面写的是几句歌词： 赵燕，别管以后将如何结束，至少我们曾经相聚过，人的一生有许多回忆，只愿你的记忆中有我。希望你能永远记住我这个朋友。 袁河问，她一共送给你了几个纸飞机？ 赵燕回答说，一共八个。 袁河问，那里面写的都是歌词吗？ 赵燕白了他一眼，你认为这可能吗？八个纸飞机，只有这个里面写的是歌词，其他都不是。我告诉你吧，她对不同的人，会写不同的话。即使对同一个人，她写的话也不同。很少重复。而且像这样的纸飞机，她也只送给那三种人。所以你就没有。 其实袁河对于自己没有纸飞机，并不感到奇怪。 因为首先，自己不是林依然的朋友，甚至都没有跟她交往过；其次，自己也从来没有关心过她，甚至曾经还有些讨厌她；最主要的一点，自己不可能是她所喜欢的人，这完全没道理嘛。所以自己理所当然没有纸飞机了。 但让袁河感到诧异的是，陆可凡为什么会有纸飞机呢？他和自己的情况差不多呀？这也完全没理由嘛。难道是赵燕送给他的？ 袁河本来想问赵燕陆可凡为什么会有纸飞机，是不是她送的。但是转念一想，这很正常啊，因为他们是朋友嘛，况且送个纸飞机又没有什么大不了的，所以最后就忍住没问。 赵燕把纸飞机折好，重新夹到那个天蓝色的笔记本中。然后问袁河，你知不知道这个笔记本是谁送给我的？ 袁河说，我哪里清楚啊？难道又是林依然送给你的？ 赵燕点点头说，嗯，是她送给我的。可你知道这个笔记本是用来干什么的吗？ 袁河说，我怎么知道呢？不会是用来夹纸飞机的吧。 赵燕没好气地说，当然不是了。这个笔记本啊，是用来化解我们之间矛盾的。 袁河惊道，化解什么矛盾？你们不是很好的朋友吗？ 赵燕说，你也许不知道吧，虽然我们之间的关系那么好，但有时也会闹些小矛盾的。每当这时，谁都不理谁。怎么办？那就在这个笔记本上写相互道歉的话，然后上课趁老师不注意传给对方，这样下课后，我们我们就又和好如初了。你说这个办法怎么样？ 袁河做了一个佩服的表情，真是绝妙啊！ 看着那个天蓝色的笔记本，袁河忽然想起了自己那个专门用来写字绘画的黑色笔记本。虽然里面记载的都是一些凌乱的文字和纷杂的图画，但却是两个人友情深厚的见证，是两个人最美好最珍贵的回忆。 袁河想，自己和陆可凡应该永远都不会忘记那个黑色的笔记本吧。而赵燕和林依然，则也会永远记住这个天蓝色的笔记本吧。 17 根据赵燕所讲的这些事情，基本上可以判定林依然是一个善良而又真诚的人。袁河想起以前自己对她的误解，以及对她的讨厌，不禁感到非常惭愧，不停地责怪自己实在太自私太过分了。 上次赵燕跟袁河讲完她与林依然之间的交往过程后，袁河就说过想要与林依然交往一下，但却一直没有机会。 后来当他听赵燕讲完更多与林依然有关的事情后，想要与之交往的念头便越来越强烈。强烈到让他无法控制的地步。但还是一直没有机会。没想到在星期二的那节体育课上，机会终于来了。他终于实现了这个一直都无法实现的愿望。 高一（4）班的课程表上写着，每个星期一的上午第四节，和星期二的下午第一节，是体育课。 虽然这个班每周都有两节体育课，但是通常情况下，大家上的只是星期二那节体育课。至于星期一那节课，则完全形同虚设。 因为周日的时候，大家完成自定的出行计划和活动安排后，都累得不行了，根本没有精力去上第二天的体育课。最主要的是，星期一那节体育课安排在上午第四节，同学们上完前三节课，就算已经放学了，谁还有心情去上什么体育课啊。所以星期一那节体育课就这样白费了。 有人抱怨说，到底谁安排的课程表啊？怎么如此没水平？还不如把体育课放在星期六的下午第三节算了，上完前两节就可以直接走人，这样多好啊，真是可惜了！ 因为报销了一节体育课，所以另外那节课就显得尤其珍贵。每个星期二中午督学时间过后，大家都会急不可耐地朝操场上奔去。提前来上体育课。这样也算是对昨天那节课的一种安慰和补偿吧。 就连平时非常安静的人都到操场上去了。比如林依然。比如陆可凡。等等。 一般上星期二那节体育课的时候，袁河都会找人打乒乓球，或者羽毛球。如果找不到人的话，就走进校园书店里面看书，或者坐在篮球场边的石椅上，安静地看陆可凡打篮球。好像大致就是这样。 记得那个星期二上体育课的时候，袁河没有找到想打乒乓球和羽毛球的人，于是走进校园书店里面看书。看了十分钟，觉得没意思，便又走出书店，坐在篮球场边的石椅上，安静地看陆可凡打篮球。 每次看陆可凡打篮球的时候，袁河都会感到有些不可思议。因为篮球场上的陆可凡表现非常积极，显得特别活跃，简直与平时判若两人。很多次陆可凡把抢在手中的篮球投入蓝筐中后，都会流露出难得的喜悦，绽放出少有的笑容。 这让袁河隐隐觉得，活跃才是潜藏在陆可凡身体中最真实的一面。他想总有一天，陆可凡会变成一个活泼而又开朗的人。而那时，自己又会变成什么样子呢？ 袁河正在思考自己将来会变成什么样子，这时肩膀忽然被人戳了一下，惊得差点从椅子上掉下来。抬头一看，只见赵燕正双手抱着一个篮球站在自己面前。 赵燕问，你在想什么呢？这么投入。 袁河往旁边挪了一下，拍拍椅子，示意赵燕坐下，没想什么。 赵燕说，我就不坐了。说着晃了晃手中的篮球，我看你也别坐了，起来活动活动，打打这个，怎么样？ 袁河惊道，什么？打篮球？我不会啊。再说，只有我们两个人，怎么打？ 赵燕反问道，谁说只有我们两个人了？说着指了一下站在远处的林依然，是三个人，还有她呢。嗯，她也不会打，可是，不会打可以学啊。如果实在不行的话，我来教你们，这样总可以了吧。 袁河更加吃惊地说，什么？你会打篮球？开玩笑吧。我怎么从来没有见你打过？真是太会吹牛了。我们班会打篮球的女生几乎没有。每次上体育课只会待在旁边踢毽跳绳聊八卦。你不也一样吗？ 赵燕郑重地说，告诉你吧，我初中是学校女子篮球队的队长，怎么可能不会打篮球呢？只是进入高中后，发现班上没有女生打篮球，这才委屈自己和她们一样做那些事情。 袁河做出一个“晕倒”的动作，真是没想到啊，你居然是我们班的花木兰。然后摆出古代书生遇见客人后的姿势，在下这厢有礼了。 赵燕举起手中的篮球像要砸他的样子，少废话，你到底陪我们打不打？嗯，同桌，你可要想清楚了，如果你不答应的话，我会很生气，后果很严重。知不知道？说完忍不住扑哧一笑，我是不是很有才啊？ 袁河点了点头，岂止很有才啊，简直相当有才。哎，那个，你会打篮球，怎么从来没有跟我提起过？ 赵燕挥了一下手，我说出来你信吗？看你刚才那副吃惊的表情，好像遇见外星人了一样。再说，我现在不是已经告诉你了吗？ 袁河看着赵燕手中的篮球说，既然以前你都忍住没打，怎么今天突然想打了呢？ 赵燕假装生气地说，我今天突发奇想心血来潮，这样行了吧。我让你陪我和林依然打一下篮球，你罗嗦这么多。怎么？看不起我是不是？ 袁河无辜地说，大姐啊，我怎么敢看不起你呢？万一出现严重的后果，那可怎么办啊？我陪你们打还不行吗？ 赵燕说，这还差不多。跟我走吧。说完刚转过身就忍不住开始笑。 袁河想，看来我今天又要开阔视野了。 18 赵燕不愧是初中女子篮球队的队长，果然出手不凡，上来就投进一个空心三分球，把袁河与林依然看得瞠目结舌，无言以对。 赵燕捡起篮球说，既然你们都不会打，那就从最基本的投篮开始练起吧。嗯，女生优先，林依然，你先来吧。说完把篮球递给了林依然。 林依然不好意思地接过篮球，犹豫半天，最后在赵燕的鼓励下，才终于把球投了出去。结果用劲过小，篮球在空中划出一道优美的弧线后，直接落在了地上，连篮板都没有碰到。 林依然窘得站在那里直搓双手，不知如何是好。 篮球落在地上起初只是蹦跳着前进，后来索性就地翻滚。最后干脆沿着篮球场边倾斜的草坪飞速直下。然后只听“咕咚”一声，掉进了草坪前面的排水沟中，激起无数水花。看得三人心惊肉跳目瞪口呆。 赵燕最先反应过来。她拍了一下袁河的肩膀说，不好意思，麻烦你下去把篮球捞上来吧。 袁河说，什么？你看那水脏得简直不像话，难闻死了，怎么捞啊？我不下去。 赵燕说，难道你还要让我们女生下去吗？你一个男子汉大丈夫，怎么…… 袁河不知道赵燕接下来要说什么，但肯定不会是什么好话，当即打断她说，我下去捞就是了，你不要再说了。 赵燕松了一口气，这还差不多。停顿了一下，还是把那句话说出来了，你一个男子汉大丈夫，怎么能那样没出息呢？ 袁河一听差点气疯了，马上转身要回教室。 赵燕连忙说，你别走啊，你走了我们怎么办？我收回刚才那句话还不行吗？我求你了，好不好？ 袁河这才没有离开。 袁河屏住呼吸走到排水沟边，只见整个篮球只有最上面巴掌大一块尚且干净，其他地方已经污秽不堪，并且还不停地上下浮动，这给他打捞工作造成了很大的困难。 袁河伸出两手的中指，慢慢从两边夹住篮球，轻轻向上提起，然后缓缓朝食堂旁边清洗餐具的水槽走去。 林依然跟在后边一直不停地抱歉，真是对不起啊，我不是故意的，请原谅我好吗？我真的不会打篮球，结果害得你…… 袁河笑着说，没关系，我也不会打篮球啊。如果是我先投篮的话，估计也是这种情况，所以你不必自责的。 林依然说，但却是我把篮球弄到排水沟中的，真是…… 袁河再次说，没关系了，无论是谁把篮球弄下去的，我都应该下去捡。因为我是男子汉大丈夫嘛。说完回过头，对着林依然灿烂一笑，这才发现赵燕没有跟上来。心想，等马上回到教室再找她算帐。我说过不会打篮球的，她却非要让我打，看把我害成什么样子了。哎呀，难闻死了…… 林依然见袁河正对着自己笑，也不禁害羞地笑了。 袁河洗完篮球。二人边走边聊，非常开心。 刚回到操场上，下课铃就响了。袁河把篮球递给体育委员，回过头看了一眼正坐在篮球架下面休息的赵燕，做出一个“你可把我害惨了”的表情，然后便向教室走去，以迎接第二节课的到来。 赵燕和林依然在操场上说了几句话，然后也一起向教室走去。 第二节下课后，赵燕并没有像往常一样走出教室和其他女生聊天，而是反问袁河，你知道刚才上体育可课，我为什么要让你陪我和林依然打篮球吗？ 袁河说，我还正想问你为什么呢？你不会就是想教我们打篮球吧。你闻一下，我现在身上都是排水沟的味道。你可真把我害惨了。你知道吗？ 赵燕说，我也没想到会这样啊。嗯，对此我向你表示深深地道歉，对不起，这该行了吧。不过，你真不知道我为什么要让你打篮球吗？ 袁河摇了摇头，我还真不知道。 赵燕说，我只是想通过这种方式，让你和林依然接触交往。你明白吗？ 袁河一时没有反应过来，你说什么？ 赵燕说，你以前不是说过想要和林依然交往吗？而我憋屈了那么久，实在很想打一下篮球。所以我就用这种自私的方法来帮你啊。否则你们这辈子都不会说一句话的。可你非但没有感激我，反而还那样责怪我。你真是太没有良心了。 袁河听后不禁意识到自己刚才有些过火了，连忙道歉，等赵燕情绪稳定后，这才激动地问道，你为什么要帮我啊？ 赵燕说，免得你一直讨厌林依然。稍微停顿了一下，然后郑重地说道，因为林依然是我最好的朋友，所以我不希望任何自己熟悉的人对她心存误解。特别是你。 袁河感到非常冤枉，自从你跟我讲完那些与她有关的事情后，我对她的误解就已经彻底消除了。你为什么要这样说我？ 赵燕看着袁河脸上郁闷的表情，觉得自己刚才有些言重了，忙后悔地说，对不起啊，我并不是对你有意见。而是因为太在乎林依然这个朋友了。所以才会这样说。因为以前你对林依然特别反感。我以为现在你对她还十分讨厌，所以……但我也是出于一片好心，因此…… 袁河看到赵燕自责的样子，心里有些过意不去，没关系，我可以理解你的心情。谢谢！ 19 自从上完那节体育课后，袁河与林依然之间的交往就越来越多。后来，他们就理所当然地成为了朋友。对于这一切，赵燕当然功不可没。 所以袁河为了感谢赵燕长久以来对自己无私的帮助，同时也为了庆祝自己和林依然能够成为朋友，便想请她们吃饭。 看到林依然后，袁河不禁想起了与之性格相似的陆可凡，印象中仿佛有很多天都没有跟他聚在一起了，于是叫上陆可凡。然后四个人就这么浩浩荡荡地出发了。 他们是在校园外面一家名叫“三回头”的小餐馆里面吃的饭。 在吃饭的过程中，陆可凡总是不停地和赵燕讲话。而林依然则一直沉默，不过目光却时不时会落在陆可凡身上。 但是袁河对此根本没有在意。 他只是感觉这里的饭菜确实不错，而且价格实惠，心想怪不得上次赵燕会请陆可凡在这里吃饭，原来如此啊。 20 通过这么长时间的交往，袁河发现林依然是个心地善良而又多愁善感的女生。一篇很平常的文章，一本很普通的小说，她都可以看的伤心欲绝；一件很细小的往事，一句很微妙的话语，她都可以想的泪流满面……就像林黛玉一样。 林依然表面上非常坚强，但是内心却比谁都脆弱。袁河知道像她这样的人，一般都特别容易受伤。可是她无论受到多么大的委屈，不管遭遇多么深的痛苦，全都自己担着，从来不对别人讲。袁河每次见她不开心走过去问她怎么了，她都低声说没事没事。她总是喜欢隐藏起自己一切的辛酸，掩饰住自己所有的悲伤，然后对每个人笑。笑容忧郁而又凄凉。 同赵燕一样，林依然特别喜欢与袁河坐在一起聊天。不过很多时候，都是林依然在不停地讲。袁河并非是因为插不上嘴，而是不忍心打断她的话。林依然跟袁河讲的最多的，就是自己悲惨的过去。 林依然说父母对她一直都不好，几乎从来都没有呵护过自己。她从小到大从来没有得到过父母的表扬。哪怕一次也没有。无论每次考试排名第几，父母都漠不关心。即便自己考试全班第一名，父母也只是沉着脸对她说不要骄傲。父母对她非常克扣，从来没有给过她任何零花钱。如果自己犯了错误，就会遭到父母凶狠地打骂。简直难以忍受。除了父母外，爷爷奶奶对她也非常苛求。总是看她不顺眼。稍有不对就厉声斥责。有时候，她觉得自己就像个丑小鸭一样，走到哪里都受人嘲笑欺侮。但是丑小鸭最后却变成了美丽的白天鹅。而自己将来会变成什么样子呢？ 林依然低声道，说不定我就这样窝囊地过完此生，然后死去。没有人会记得，曾经有个叫林依然的女孩，在这个世上卑微地生活过。没有人知道…… 每次讲到最后，林依然都会泪流满面。 袁河很想安慰她，可是却不知道应该怎么做，只能手足无措地站在旁边，任她哭泣。只有在事后才会说很多真心实意的话来关心她，做很多力所能及的事去帮助她。一直如此。 不知道为什么，只要看见林依然，袁河就会生出一种想要保护他的念头。 也许是因为她太弱小了吧，使自己忍不住想要赐予她力量，令她变得强大起来。真的。袁河想要保护林依然，让她从此以后再也不受任何伤害。他希望瞧见林依然快乐而又甜美的笑容，却不想看到她悲伤而又难过的眼泪。如果能让林依然每天都快乐无忧的话，他愿意去承担所有的痛苦和辛酸。 后来这样的念头越来越强烈。强烈到想要永远做她的守护神。一生一世都不离开。 袁河搞不清楚自己到底怎么回事，反正闲暇之余，脑海中全都是林依然孤单的身影，和忧伤的表情。怎么也挥之不去。都有点魂不守舍了。 袁河想，我以前从来不会这样的，我现在到底是怎么了？难道是喜欢上她了？一副困惑不解的样子。 21 自从那节体育课，赵燕曝光自己会打篮球的身份后，几乎每个星期二的体育课，她都要去打。 虽然无法和女生一起打篮球，但是可以和男生一起打啊。当然她不会主动加入其中的，否则就显得太粗野，没修养。毕竟自己是女生呐，要矜持一点，稳重一点，不能像男生那样，大大咧咧的。要不然影响多不好啊。 所以只有等男生过来邀请她后，才会去打一下篮球。 不知道为什么，差不多每次都是陆可凡去邀请她一起打篮球。真让人费解。 如果赵燕答应的话，那么陆可凡就会显得特别兴奋；如果赵燕拒绝的话，那么陆可凡就会感到非常失望。 除此以外，在比赛前，陆可凡总是要把自己和赵燕分在同组。如果没有的话，那么他就会请求调整队员，或者重新分组。别人都觉得陆可凡有些无理取闹，但是碍于情面，不好说什么，只能同意这么做。 而在比赛的过程中，如果赵燕表现良好的话，那么陆可凡就会露出赞赏的表情；若是赵燕发挥失误的话，那么陆可凡就会投出鼓励的目光。 袁河与林依然坐在篮球场边的石椅上，对此都感到有些诧异。特别是林依然，每当看到陆可凡那样做，都会脸红，并且迅速低下头，仿佛有些于心不忍的样子。 后来有一次，袁河见状问她怎么了。她低声说没事没事。可是眼泪却已经流了下来。袁河顿时手足无措，只能等她慢慢平静下来后，才开始安慰她。 22 这天下午上第三节课的时候，袁河正在抄写板书，手臂忽然被人点了一下，抬起头，只见赵燕已经把一个蓝色的纸飞机放到了自己的课桌上。 袁河问，这是林依然送给你的，你送给我干吗？ 赵燕调皮地说，才不是呢。这个纸飞机是林依然送给你的。我只是负责传递而已。 袁河疑惑地问，她送给我的？为什么啊？ 赵燕说，因为你现在是她的朋友嘛，她当然要送给你了。真是的，连这都不懂。 袁河拾起课桌上的纸飞机，左看右看爱不释手。 赵燕提醒说，你难道不想看看她在里面给你写的什么话吗？ 袁河恍然大悟似地点了点头，你不说我还差点忘了。 袁河小心翼翼地拆开纸飞机，只见上面写道： 谢谢你的帮助，谢谢你的关心，谢谢你的安慰，谢谢你的宽容。 上高中能够遇到像你这样待人真诚而又善于倾听的人，是我今生最大的幸运，也是我今生最大的快乐。自从我们交往以来，你总是那样默默地关心我。那样静静地照顾我。对此我真的很感动，也很幸福。谢谢！ 应该说我只是你人生中的一个过客，或者说我们彼此互为对方生命中的点缀。如果有一天我们分开了，请你一定要忘记我。 袁河看到前面那些话时，心里一阵温暖，可是看着看着脸色就有些变了。 他指着最后那两句话问赵燕是什么意思。赵燕摇摇头说不知道。 后来袁河又陆续收到了几个林依然送给他的纸飞机。里面写的内容各不相同，但是末尾却都是那两句话。从来没有变过。 袁河以为那是林依然的习惯，所以就不再胡思乱想了。只是每次把里面写的内容看完后，重新折好，然后夹进自己那个专门用来写字绘画的黑色笔记本中，以作收藏。 有时候，袁河觉得，林依然就像个飞在风里的纸飞机一样。那么柔弱，那么无助。没有依靠，没有归宿。一直飘曳，一直摇晃。仿佛随时都要掉下来的样子。 袁河可以感觉出来，她身上正背负着太多沉重的东西。那些东西压得她几乎虚脱，但是却不能停下来休息。因为一旦停下来的话，也许永远就无法再回到天空中了。 所以她必须要迎着风，一直艰难地飞行。一直飞行。一直。飞行。 袁河很想替她承受这一切，但是却无能为力。只好在心里默默地为她祈祷，深深地为她祝福，希望她能够健康快乐，一生平安！ 23 现在星期二上体育课的时候，袁河很少再找人打羽毛球或者乒乓球了。至于校园书店，他也已经很久没有进去看过书了。那他上体育课的时候都在干吗？他在陪林依然。 自从那次观看赵燕和陆可凡打篮球，林依然低头哭过后，他们就再也没有坐在石椅上观看过篮球比赛了。 林依然喜欢安静地坐在草坪上，认真盘算自己的心事，袁河就坐在旁边陪伴她。虽然草坪前面是排水沟，但是他们所坐的位置绝佳，根本闻不到任何刺鼻的气味，挺好的。 有一次上体育课，袁河正坐在草坪上思考一个问题。林依然突然问他，陆可凡这个人怎么样？ 袁河一时没听清楚，你说什么？ 林依然低下头有些不好意思地说，我问你……陆可凡这个人怎么样？ 袁河说，他人很好啊。要不然我们怎么会成为朋友呢？ 林依然说，可是我到现在还没有跟他说过话呢，所以对他一点都不了解。你……可不可以跟我讲讲他？ 袁河说，当然可以了。 直到快下课的时候，袁河才基本讲完。 林依然说，哦，原来是这样啊。我还以为他是一个清高而又孤傲的人呢。 袁河说，很多没有和他接触过的人都这样认为。但他不是的。 林依然点点头，嗯，我差不多有点了解他了。哎，我在问你话之前，你在想什么呢？那么专注，那么投入。 袁河说，我在想，上次观看赵燕和陆可凡打篮球，你为什么突然会哭？而且从那以后，我发现你和赵燕都很少交往了。能告诉我其中的原因吗？ 林依然低头不语。 袁河问，你们又闹矛盾了？为什么不在那个天蓝色的笔记本上面写相互道歉的话，来消除矛盾呢？ 林依然低声说，有些矛盾，并不是通过道歉，就能够化解消除的。 袁河问，那么我可以为你们做些什么吗？ 林依然说，不可以。 袁河问，为什么？ 林依然说，不为什么。 袁河问，你不信任我？ 林依然说，不是。 袁河问，那你可不可以告诉我，你们之间到底有什么矛盾？ 林依然说，不可以。 袁河问，为什么？ 林依然说，不为什么。 袁河急得都快要哭出来了。这时下课铃响了。林依然说，我先回教室了。说完起身走开。 袁河看着林依然的背影，脸上满是痛苦。 这到底是为什么啊？ 24 在后来的一节体育课上，赵燕因为腾空投篮的时候，被对方球员撞了一下，结果摔到地上，划破了手臂。 当时陆可凡都吓慌了，几秒钟后才反应过来，连忙上前扶起赵燕，朝医务室走去。 袁河见陆可凡眼中满是心疼，有些困惑，不就是划破了手臂，至于这样吗？太夸张了吧。谁没受过伤啊。回过头刚要跟林依然说这些，却见她早已泪流满面，更加诧异，虽说朋友受伤了，但不至于哭成这样吧。跟陆可凡一样。也太夸张了。 袁河对林依然说，看你哭成这样，是不是已经与赵燕私下和好了？嗯，这样才对嘛。走，让我们去医务室查访一下她的伤势情况，看看你到底有没有必要哭成这样。 林依然低声说，我不去。要去你去。我先回教室了。然后转身离开。 袁河感到非常不解，都是怎么搞的？想不通！ 赵燕在医务室通过简单包扎后，便要返回教室。 陆可凡关切地问，你伤成这样，要不要请假休息几天？ 赵燕笑着说，就这点小伤，还需要请假休息吗？没有必要吧。 陆可凡急道，谁说没有必要？万一伤口感染了怎么办？你放心，我会帮你补习的。 赵燕说，算了吧。我是不会请假的。哎，是不是快要上课了？走，一起回教室吧。 陆可凡还想说些什么，但是看到赵燕脸上坚定的表情便忍住了，只是附和道，好，走，回教室。 在赵燕伤口愈合的那些日子里，陆可凡三天两头跑过来嘘寒问暖的。但是林依然却没来看过赵燕一次。 这让袁河感到非常纳闷，同是赵燕的朋友，反差怎么这样大呢？林依然不是与赵燕已经私下和好了吗？怎么还那样陌生啊？难道又闹新矛盾了？而且看样子，这次关系好像更加恶化了。她们到底怎么回事呀？我想不明白，又没人跟我说，到底什么意思啊？真是…… 25 有一天上课的时候，袁河发现赵燕的脸色很难看，便问，怎么了？你生病了？ 赵燕说，没有。 袁河问，那你脸色为什么这样难看？ 赵燕低下头说，林依然再也不理我了，她再也不和我做朋友了，她再也……话没说完，已经泣不成声。 袁河顿时慌得手足无措，完全不知道应该怎么办，只是一直不停地跺脚。 对于多愁善感的林依然，遇到这种突发情况，袁河尚且不知如何去安慰人家。那么对于自己的同桌赵燕，那就更不知道应该如何去安慰了。 因为自从做同桌以来，赵燕一直没有哭过，每天都笑容满面的，也不知道从哪里来那么多开心的事情。陆可凡曾经对袁河说，要是我能像赵燕那样笑口常开的话，那我就是天下最快乐的人了。袁河浅笑一下，无论谁像她那样，都会感到快乐的。不是吗？陆可凡点了点头。 可就是这样一个活泼开朗每天都笑容满面的女生，现在却哭得那样伤心。简直前所未有。袁河看得整个人都傻掉了。 等赵燕好不容易止住哭泣，袁河才轻声问道，她为什么不再理你了？ 赵燕低声说，我不知道。反正自从我打篮球以后，她就再也没有跟我讲过话了。说完又开始哭了起来。 不知道为什么，只要看到有人流泪，袁河心里就会特别难受，几乎都要跟着一起哭了。所以现在袁河的脸色，甚至比赵燕还要难看。他只是轻轻地拍了一下赵燕的肩膀，以示安慰。然后转过头，也忍不住开始掉泪。 因为他们动作很轻，声音很小，课桌上面堆砌很高的书本挡住了别人的视线，而且他们一直都低着头。所以对于这里正在发生的一切，老师和同学们都没有发现。 后来上课的时候，赵燕总是会拿出林依然曾经送给她的那些蓝色纸飞机，和那个天蓝色的笔记本，一遍又一遍地看，一直看到泪流满面伤心欲绝为止。 袁河见同桌这个样子，简直心都碎了。不知道为什么，他忽然想起了很多关于赵燕平时的言行：她看完郭敬明的《梦里花落知多少》后一直自问，这个世上有没有像顾小北和陆叙那样好的人？我将来可要找一个像陆叙那样的伴侣；她做不到物理题时喜欢胡思乱想，如果我比爱因斯坦还要聪明的话，那就好了；她有时会对着镜子或者照片看半天，然后自恋地说，我长的也挺漂亮的呀；她特别崇拜周杰伦，不仅在课桌上贴满了他的图片，而且还到处宣扬以后要去看他开的演唱会；她在看书时碰到个别经典笑话会马上拿过来让袁河看，一边前俯后仰一边问，好笑吗？…… 袁河想得鼻子都发酸了。一切怎么会变成现在这个样子啊？以前那个活泼开朗的赵燕到哪里去了？以前那个笑口常开的赵燕到哪里去了？以前那个快乐无忧的赵燕到哪里去了？以前那个一上体育课就在篮球场上挥汗如雨的赵燕到哪里去了？以前那么多那么多阳光可爱的赵燕，她们都到哪里去了？谁能告诉我啊？想到这里，眼泪终于还是掉了下来。 26 那天中午吃完饭回到教室，袁河看见赵燕正趴在课桌上不停地抽噎，心一下子又开始疼了。回到座位上，袁河拍拍赵燕的肩膀，你又看林依然送给你的那些东西了？ 赵燕抬起头来，两只眼睛早已哭红了，没有。 袁河难过地问，那你为什么又哭得这样伤心？ 赵燕说，你知道吗？我和林依然曾经是那么好的朋友，但却没有想到，有一天，我们会形同陌路到擦肩而过都不看彼此一眼的地步。就在刚才，我和她在教室外面走廊上相遇的时候，她居然都没有看我一眼，而是直接把头扭到一边，然后侧身从我身边走过去了。对此，我真的感到非常寒心，所以……话没说完，又开始哭了起来，而且比刚才更加伤心。 袁河看到赵燕现在这个样子，心想，看来我无论如何都要找林依然好好谈一下，看看她们之间到底有什么样的矛盾和误会。虽然那次上体育课的时候，她始终不肯告诉我。但是这次，我必须要弄清这些问题。希望我可以化解她们之间的矛盾，消除她们之间的误会，让她们重新和好。也只有这样，我的心里才会好受一些。 袁河走到林依然的位子前，低声说，有些事，我想好好和你谈谈。可以出来一下吗？ 林依然见袁河走进教室与赵燕说了几句就来找自己谈话，便已猜到，他想和自己谈论的事情，就是那次体育课上，他问自己的那些问题。到底出不出去？虽然上次，自己始终没有给他答案。但是现在，好像不应该再向他隐瞒了。还是跟他说了吧。这样自己也许就彻底解脱了。这样自己也许就完全轻松了。这样自己也许就不会再承担那么大的痛苦了。这样自己也许就不会再承受那么大的煎熬了。 林依然稍微犹豫了一下，便点点头答应了，我们到哪里去谈呢？ 袁河说，就在篮球场边的草坪上，行不行？ 林依然说，好吧。 27 两人走到草坪上坐下后，袁河还没有来得及开口问林依然，她和赵燕之间到底有什么样的矛盾和误会。却被林依然反问道，说实话，你是不是喜欢我？ 袁河说天也没有想到林依然上来会问自己这个问题，一时不知如何才好，红着脸低下头，一直不停地搓手。过了很长时间，才抬起头轻声说，我确实有点喜欢你。说完不好意思地看向别处。 林依然说，可我并不喜欢你。我真正喜欢的人是陆可凡。我们只能做朋友。你明白吗？ 这句话对袁河来说，无疑是晴天霹雳。岂止啊。简直是五雷轰顶。袁河全身顿时凉透了。心里感到一阵酸楚。难受得要命。 袁河看过小说，看过电视，看过电影。他知道那里面的女主角，对于自己不喜欢的人，通常都会以委婉的话语，或体面的方式予以拒绝。那样自己不会太尴尬，对方也不会太难过。彼此都不会太痛苦。 但是他却没有想到，自己平生第一个喜欢的人，居然会这样直接地询问自己，然后再这样生硬地拒绝自己。真是太残忍了！林依然，你为什么要这样拒绝我？你为什么要这样伤害我？你为什么要这样打击我？袁河觉得自己都快要崩溃了。 袁河抬头望了一下天空，觉得太阳特别刺眼，泪水都快要流出来了，为什么？ 林依然说，因为我们不合适。记得在我们交往之前，你不是一直都非常讨厌我吗？有几次我去问赵燕借钱，无意中打断了你们的聊天，于是你脸上就满是怒气，好像很反感我的样子。你知道那时我心里有多难受吗？你不会知道的。也没有人会知道。真的。我平时一直沉默不语，一直忍气吞声，却没想到还是会招人反感，惹人讨厌。你说我活得是不是很失败啊？有时候，我简直想一死了之，但却做不到。你说我是不是很没出息啊？ 袁河听到这里已经彻底没有知觉了，脸上满是泪水，是我活得失败，是我没有出息…… 林依然像是没有听见袁河的话，继续道，后来赵燕告诉我，你想和我交往。你知道我当时听后是什么反应吗？ 袁河摇了摇头，不知道。 林依然说，我当时觉得你真虚伪。既然你那么讨厌我，为什么还想和我交往呢？所以我在心里特别抵触你。但是碍于情面，我还是答应了。你还记得那天，我们第一次打篮球吗？那是赵燕用心安排的，就为了消除以前你对我的误解。她希望我们可以成为朋友。我当时觉得完全没有必要这样做。我有赵燕这个朋友，就已经足够了，为什么还要千方百计和讨厌自己的人成为朋友呢？但是看到赵燕脸上期望的表情，我什么也没说就答应了。 林依然说到这里看了一眼袁河，继续道，可我真的不会打篮球，所以第一个就把篮球投进了前面这个排水沟中。当时赵燕让你下去捡，但是你却不愿意。最后在赵燕的哀求下，你才下去把篮球捡了上来。我们一起去清洗篮球的时候，你说“无论是谁把篮球弄下去的，我都应该下去捡。因为我是男子汉大丈夫嘛”。虽然表面上我一直都在和你说笑，但是心里却在想，你还是那么虚伪，这样的话你怎么说得出口。不过我什么都没有表现出来。因为我怕你会伤心。但是我去问赵燕借钱的时候，你为什么要把对我的讨厌表现得那么明显？你有没有想过我会不会伤心啊？ 袁河木然道，是，我虚伪，谢谢你的好意，我心领了。 林依然没有理会，接着说，我们洗完篮球就下课了。当时你直接就回教室去了。我和赵燕在操场上说了几句话，才向教室走去。你知道我们在一起说的什么吗？ 袁河低沉地说，不知道。 林依然说，我对赵燕讲，我不想再跟你交往了，因为我们根本不适合做朋友。她说，其实袁河这人挺好的，如果你们不能成为朋友的话，那就太可惜了。最后在赵燕的劝说下，我才没有和你绝交。没想到现在，我们还真的成为了朋友。 袁河黯然道，那你现在，是不是，特别后悔，和我成为朋友啊？ 林依然说，你还记得我在送给你的第一个纸飞机里面，写的什么吗？我写道，上高中能够遇到像你这样待人真诚而又善于倾听的人，是我今生最大的幸运，也是我今生最大的快乐。这句话说真的。自从和你成为朋友后，我才慢慢地发现，你这人确实挺不错的，待人真诚，善于倾听，一点都不虚伪。后来你一直那样默默地关心我，静静地照顾我。这让我特别感动。但是这并不能完全消除我们之间的隔膜。因为你曾经那样强烈地讨厌过我。当时你脸上那种愤怒的表情，我永远都忘不了。没办法。对于那些伤害我自尊的东西，我真的忘不了。但是同样的，我也会永远记住你对我的好。其实我早就知道你喜欢我。从你那关切的眼神，我就看出来了。但是……我们只能做朋友。因为我真正喜欢的人是陆可凡。 28 袁河悲伤地问，那你从什么时候起，开始喜欢陆可凡的？ 过了很久，林依然才回答道，赵燕曾对我说，她跟你讲过她和陆可凡之间的交往过程。那么你应该还记得，赵燕把陆可凡的圆珠笔踩碎后，为了表示歉意，第二天中午请陆可凡吃了一顿饭。当时我也在场。虽然那天中午吃饭的时候，我自始至终都没有说一句话，但是我却注意到了陆可凡。不知道为什么，看到他，我总是感觉特别亲切，就像见到了某个阔别已久的朋友一样。而且在他身上，我隐约可以看见自己的影子。你说，遇到一个和自己性格相似的人，这算不算缘分？ 袁河忽然想起刚开学的时候，有人曾说他与陆可凡长得有些像。 也许，这只是别人随口讲的一个笑话，但是，他却认为这是缘分，所以后来，他才会费尽心机，想要和陆可凡接触交往，直到最终成为朋友。 想到这里，袁河无力的点点头，应该算吧。 林依然说，嗯，我也是这样认为的。所以后来我就彻底喜欢上了他。我听别人说，他是一个清高孤傲而又狂妄自大的人。但是我却不信。所以在那节体育课上，我才会向你打听与陆可凡有关的事情。嗯，他果然不是那样的人。 袁河听到这里已经彻底死心了。原来她真正喜欢的人是陆可凡。原来从开始到现在，一直都是我自作多情。我真是太…… 袁河忽然想起那天坐在陆可凡的位子上看到的那个纸飞机，心想，我还一直以为那个纸飞机是赵燕送给他的，直到现在方才明白，原来是林依然送给他的。我真是太笨了。 29 提到赵燕，袁河忽然想起来，自己今天来找林依然，并不是为了听她说这些打击人的话，而是为了弄清她与赵燕之间到底有什么样的误会，是为了化解她们之间矛盾的。于是努力让自己镇静下来，不再去想那些令人伤心难过失魂落魄的东西。 等自己情绪彻底稳定后，袁河才问林依然，那么你和赵燕之间到底怎么回事？ 林依然反问道，你知道我为什么观看赵燕和陆可凡打篮球时会哭吗？你知道我为什么从此以后再也不看他们打篮球了吗？你知道上次赵燕受伤后，我为什么一直没有去看她吗？ 袁河说，不知道。 林依然说，因为我喜欢陆可凡。 袁河困惑地问，这与那些事情有什么关系吗? 林依然说，有关系。因为我喜欢陆可凡，所以我见不得他对别的女生好，同样的，我也见不得别的女生对他好。如果陆可凡对哪个女生好，那么，我就会讨厌那个女生，怨恨那个女生，并且从次以后，再也不去理睬那个女生。即便是自己最好的朋友，也不例外。因为我实在无法容忍自己的朋友对自己不忠。 袁河问，可是，你怎么能这样对待赵燕呢？你怎么能这样绝情呢？无论如何，她毕竟是你最好的朋友啊。 袁河刚说完这句话，林依然就哭了起来。哭得很悲痛。哭得很伤心。边哭边说，你以为我想这样吗？我不想的。可是，每当看见陆可凡与赵燕在自己面前那样亲密。我心里真的很难受。真的很难受。就像被人砍了几刀一样，痛彻心扉。所以观看他们打篮球时，我才会忍不住突然哭出来。那种撕心裂肺般的感觉，你是不会明白的。如果是别的什么东西，我会毫不犹豫地让给赵燕。但是惟独陆可凡不行。因为陆可凡是我从小到大，遇到的第一个真正喜欢的人。我真的非常在乎他，珍惜他。可是，他为什么要对赵燕那样好？他为什么要那样关心赵燕？害得我现在与朋友反目成仇形同陌路。我不想这样的，我不想的，我不…… 话还没有说完，早已哭得不成样子了。这是袁河到目前为止见过的，她哭得最厉害的一次。全身剧烈的抖动。仿佛这么多年来所有的积怨和委屈，全都在这一刻倾泻出来了。 袁河此时非常理解林依然的心情。对于之前她跟自己说的那些话，袁河早已抛于脑后了。他拍拍林依然的肩膀说，哭吧，哭出来吧。这样也许会好受些。说完用手揩干自己脸上的泪水，心里一阵难过。 30 后来有一次上体育课的时候，陆可凡与赵燕都没有去打篮球，而是并肩坐在草坪上聊天。 对于这种反常的举动。袁河百思不得其解。 他看到陆可凡的脸上，刚开始堆满了笑容和喜悦，但是后来却布满了痛苦和失望。 而赵燕则一直显得特别沉重。 好像从那以后，他们就再也没有聚在一起打过篮球了。 袁河当时见他们都不太高兴，所以也没好意思问他们怎么了。 后来，他就把这件事情给忘了。 31 距离高二上学期结束还有一个月的时候，学校组织放映了一场电影。赵燕想让袁河陪自己看电影，但是袁河却没有去。 因为首先天气比较寒冷。其次袁河并不喜欢人特别多的地方。最主要的是，那部电影他在很早之前就已经看过了，所以就坐在教室里面看书。赵燕感到无聊，只好也坐下来看书。 至于陆可凡和林依然，却不知去了哪里。 袁河看见他们是一起出去的。他们会去哪里呢？ 袁河想，他们肯定不会去看电影的。因为他们都是喜欢安静的人，怎么会去那样吵闹的地方呢？那么，他们到底会去哪里呢？算了，管他呢，还是看书吧。 32 不知过了多久，陆可凡从外面回到教室对袁河说，我们出去走走吧。 袁河见他愁绪萦怀的样子，便点点头答应了。 其实他们出去后并没有到处走动，而是直接走进教学楼左边那片小树林中，然后在一块平地上坐了下来。 陆可凡说，我到商店去买瓶啤酒吧。我现在特别想喝酒。 袁河说，你有没有搞错？这么冷的天你喝啤酒？但是看到他脸上忧伤的表情，便改口说，好吧，买两瓶，我陪你喝。 陆可凡一口气喝掉半瓶啤酒，然后打着嗝说，你知道林依然刚才找我干什么吗？你知道林依然刚才跟我说什么吗？ 袁河说，我哪里知道啊。 陆可凡冷笑了一下，她居然让我陪她去看电影。她居然跟我说她喜欢我，还问我喜欢不喜欢她？真是好笑啊。 陆可凡说着又冷笑了几声，我从来没见过，哪有女生会这样直接而生硬地问人家喜不喜欢她的？再说，我从来都没有跟她说过话，也从来没有跟她交往过，怎么会平白无故去喜欢她？你想想……怎么可能的事情？ 陆可凡喝了一口啤酒，接着说道，所以我就告诉她。我不想去看什么电影，我也不喜欢过你。可是我话还没有说完，她就开始哭，哭得那是惊天动地翻江倒海啊。我当时正感到莫名其妙，忽然走过来两个男生，指着我破口大骂，你一个男生，居然欺负女生，真是太不像话了。说完就要揍我。我吓得落荒而逃。我在教室外面越想越气闷，所以就来找你喝酒了。真没想到那么文静的一个女生，居然会与别人串通好来整我。你说，我到底哪里得罪她了？大家有话好好说嘛，用得着这样吗？你说，用得着吗？说完将剩余的啤酒一饮而尽。 袁河说，林依然不是那样的人。她是真心喜欢你的。也许，她今晚是想要跟你表白的。却没想到…… 陆可凡气愤地说，少来这套，你是她的朋友，当然会替她说话了。 袁河说，不是这样的。你听我讲啊。 然后便把那天林依然对自己说的话，全都讲给陆可凡听了。 陆可凡听后半信半疑，这是真的吗？真是这样的吗？你敢确定吗？不会骗我吧？有没有…… 袁河打断他的话，你怎么婆婆妈妈的，到底要怎样你才相信啊？我告诉你，林依然是个很好的女孩，她是真心喜欢你的。至于刚才发生的事情，我看完全是一场误会。你不要放在心上。她绝对不会请人那样做的。我觉得你应该接受她…… 袁河还没有说完，陆可凡就打断他说，就算那是一场误会。可是我对她一点感觉都没有，你让我怎么接受她啊？说的倒轻松。我也告诉你吧。我真正喜欢的人是赵燕。既然她跟你说过我们之间的交往过程，那么你就应该记得，其中有这样一个细节，就是，她将我的圆珠笔踩碎后，上课主动将她自己的钢笔传给我使用。可以说，就从那个时候起，我便彻底喜欢上了她。你知道为什么吗？ 袁河说，我怎么知道啊。 陆可凡说，因为我非常喜欢转笔，但是水平不高，所以经常会把笔转到地上，为此别人都不知道踩坏我多少笔了。但是却没有一个人像赵燕那样，上课主动把笔传给我用。所以当时我特别感动。没想到我们班上还有这样善良的女孩。因此对她特有好感。你知道，我从来不和女生说话，也从来不和女生交往，但是在她面前，我却破例了。你知道为什么吗？ 袁河又回答道，我怎么知道啊。 陆可凡说，因为我喜欢她。就这么简单。后来我收到了很多非常漂亮的蓝色纸飞机，每个纸飞机里面都写着几句话，写的都是喜欢我的话。而且末尾全都没有署名。开始我并不知道是谁送的。不过有一次，我给赵燕讲题的时候，无意中在她的课桌上，看到了两个这样的纸飞机，当时就想，原来那些纸飞机都是她送给我的呀。原来她也喜欢我啊。你知道我当时心里有多高兴吗？ 袁河摇了摇头。 陆可凡说，我当时就像在腾云驾雾一样，觉得特别舒服，都有些忘形了。后来当我得知她会打篮球后，便经常邀请她和我们一起打。那些日子，我总是感觉特别快乐，特别充实。活力四射。前所未有。 陆可凡讲到这里看了一眼袁河，继续说，在后来的一节体育课上，我觉得时机差不多已经成熟了，便约她到草坪上聊天。希望可以跟她表白。但是我将那些话讲出来后，她却沉默了。很久之后她才对我说，我知道你是一很优秀的男生，但是我……我……真正……喜欢的人是……袁河。从我们做同桌开始，我就喜欢上了她。我喜欢他的幽默风趣，我喜欢他的乐观开朗，我喜欢他一切的一切。他是我从小到大，遇到的第一个真正喜欢的人。在他面前，我可以坦诚到不保留任何秘密或隐私。你永远都不会明白我对他的那种感情。我看我们还是做朋友吧。 陆可凡凄然一笑，和林依然对你讲的差不多。我当时突然就像掉进了冰窖中一样，瞬间没有知觉了。没想到，我平生第一个喜欢的人，就这样轻易拒绝了自己。真是太……我实在找不出一个词语，来形容自己当时的感受。我只晓得过了好半天，自己才反应过来。然后眼泪就开始拼命地往下掉。你知道我从来不哭的，不管别人怎么说我清高狂妄目中无人，我都没有哭过。但是那天我却哭得很伤心，就像小孩子受到委屈了一样。最后她告诉我，那些纸飞机并不是她送给我的，但却一直不肯告诉我，到底是谁送的。所以直到现在，我还不知道是谁送的。真搞笑！ 陆可凡说完最后三个字，却开始哭了起来。 袁河听完心里七上八下的，赵燕说她喜欢自己，到底是不是真的？当他仔细回想了一遍赵燕曾经在自己面前的所有举止后，便完全确定，这是真的。但是……但是自己喜欢的人却是林依然。 33 袁河突然觉得这个世界真是太荒唐了。这样的事情怎么会发生在他们身上，而且还这样扑朔迷离，颠倒错乱。每个人都喜欢上了不喜欢自己的人，而且居然还奇迹般地围绕成了一个圆。真是太讽刺了。如果把这样的事情说出去，到底谁会相信？没有人会相信。就连他们自己，都不敢相信那是真的。这个圆真是太可笑了。它带给每个人的不是一种圆满，而是一段悲惨，甚至还有些荒诞。一切怎么会变成现在这个样子啊？ 袁河像陆可凡那样一口气喝掉半瓶啤酒，然后抬起头望着天空发笑，但是却笑得很凄凉。笑着笑着便开始哭。上高中以来，自己哭过多少次了？袁河使劲想，努力想，但却想不起来了。袁河没想到，平时如此坚强的他，如此开朗的他，有时也会这么脆弱，这么忧伤。我到底是怎么了？袁河想了很久，但却始终想不明白。难道这就是所谓的成长吗？真是太荒唐了。太荒唐了。 34 陆可凡不知什么时候已经没再流泪了。他转过头问袁河，你知不知道，那些纸飞机，到底是谁送给我的？ 袁河说，是林依然送给你的。那里面的话也是她写给你的。你现在应该明白了吧。 陆可凡说，我明白了。可是，我真的对她没有任何感觉。再说，她凭什么因为喜欢我，就和赵燕闹矛盾？我就没有因为喜欢赵燕，而和你闹矛盾。她这样做未免也太过分了吧。毕竟赵燕是她那么好的朋友。况且赵燕又没有做错什么。她为什么要那样对待赵燕？她的嫉妒心未免也太强了吧。我实在无法容忍她这样随便伤害自己的朋友。 袁河低声说，你不要这样想她，好不好？她不是那样的人。看来，你对她还是不了解。你不知道，她与赵燕闹矛盾后，一个人在背地里哭过多少回，流过多少泪。你也不知道，她有多么悲惨的过去。你更不知道，她是因为太在乎你，所以才会离开赵燕。 袁河停顿了一下，接着说，你没有意识到，你和赵燕在一起时，无形中给她施加了多么大的压力。你也没有意识到，你在无意中，给她强加了多么大的痛苦。而那些压力和痛苦，她是根本无法承受的。但是，她又不想连累自己的朋友，所以才会选择离开。你更没有意识到，所有这一切，都是你间接造成的。所以你不应该那样认为她，否则，就太对不起她寄托在你身上的那份感情了。 袁河说完，便给陆可凡讲了很多与林依然有关的事情。 陆可凡听完后，心里忽然感到特别不安，张了张口想要说什么。最终却没有说出来。 袁河看着陆可凡，你今天晚上对她讲的那些话，实在太伤她的心了。所以她才会忍不住当场哭出来。你难道不觉得应该为她做点什么吗？ 陆可凡说，如果我现在去跟她道歉的话，她肯定不会接受的。你说我该怎么办啊？ 袁河说，要不然这样吧，明天我去找她好好谈一下。把所有这些情况都跟她说清楚。她是一个明晓事理的人。我想她应该会原谅你的。说不定还会跟赵燕和好如初呢。 陆可凡说，如果是这样的话，那就太好了。明天我也会以小纸条的形式向她道歉，就说我不是故意的，因为最近一段时间，我心情不好，所以才会那样对她，希望她可以原谅我。如果以后她需要什么帮助的话，我会义不容辞尽力而为的。今后，我也会像对待你和赵燕那样跟她讲题，绝不敷衍。真的。 袁河说，好样的，这才是我的朋友陆可凡。 陆可凡忽然握住袁河的手说，谢谢你把林依然的这些情况都跟我讲了。否则，我也许会因为她伤害赵燕，而恨她一辈子，但是现在，我却不怪她了，我现在对她，甚至有些怜惜。以后，我会经常主动与她交往的，如果可能的话，我希望和像你一样，去关心他，去帮助她，去照顾她，去保护她。我没想到她对我的感情会那样浓烈，那样深厚。我确实不应该说那样的话来伤害她。我错了。错了。 袁河拍拍陆可凡的肩膀说，你明白就好。 陆可凡说，尽管赵燕真正喜欢的人是你。虽然后来我们再也没有聚在一起打过篮球。但是我对她却没有一点恨意。对你也没有。我和她，和你，都还是很好的朋友，对吧。 袁河说，对，我们都还是很好的朋友。嗯，很好的，朋友。 35 陆可凡忽然像记起什么东西似的说，那你和赵燕呢？她也是一个很好的女孩。她也是真心喜欢你的。你难道不觉得也应该为她做点什么吗？ 袁河说，其实我也挺喜欢她的。只是程度不及林依然罢了。因为她那么阳光，那么坚强，那么开朗，每天都过的很快乐，很充实，很幸福，根本不需要我去保护她。相反，林依然是那么娇小，那么柔弱，那么无助，让人见到她，都会不由自主生出一种强烈的想要保护她的念头。所以…… 陆可凡打断他说，不，你错了。其实赵燕更需要你去保护她。你知道那天在草坪上，她怎么跟我说吗？她说，我是那么喜欢袁河，我也是那么在乎林依然，所以为了消除他们之间的误会，我才会不惜一切，为他们做任何事情。但是我根本没有想到，自己付出了那么多，到头来却没有半点回报。我失去了袁河，我也失去了林依然。我一下子失去了生命中最重要的两个人。我现在变得一无所有。一无所有。你说，我是不是自作自受咎由自取啊？她说到这里早已泪流满面泣不成声。其实，她并没有你想象的那么坚强，那么乐观。有时候，她也很脆弱很忧伤很无助的。她经常也会遇到一些不开心的事情。但是在你面前，她却依然要保持乐观和坚强。你知道为什么吗？ 袁河摇了摇头说，不知道。 陆可凡看了一眼袁河，她那天对我说，曾经有几次，因为极度伤心，实在控制不住自己，就在你面前哭了起来。却没有想到你也跟着哭了起来。所以后来，在你面前，她就一直保持乐观，保持坚强，再也不哭了。因为她怕你跟着一起伤心，一起难过。因为她怕你看到她的另一面会瞧不起她。 袁河惊道，怎么会呢？我怎么会瞧不起她呢？这完全不可能事情。 陆可凡说，这说明，你对她还是不了解。所以你也应该好好和她谈一下。 袁河说，嗯，我知道应该怎么做了。说完将剩余半瓶酒一饮而尽，走吧，时间不早了，回寝室睡觉吧。一切都等明天再说。你看，下面都没人了。 陆可凡点点头，嗯，走吧。 36 后来一切果然就像那天晚上袁河与陆可凡说的那样。林依然原谅了陆可凡的错误，接受了他的道歉。没过多久，便成为了朋友。 袁河与赵燕还是同桌，但是关系明显加深了一层，原因不言而喻。 而赵燕与林依然，也已经和好如初了。 大家知道他们是怎样和好的吗？我想大家应该都还记得那个天蓝色的笔记本吧。就是通过它和好的。 那天袁河将所有事情告诉林依然后，轻声问她，你愿意与赵燕和好吗？ 林依然说，我当然愿意了。可是我那样对她，她肯定恨死我了。她还会和我做朋友吗？我现在知道错了。我不应该那样对她的。可是她会原谅我吗？ 后来袁河又问赵燕，林依然之前那样对你，你恨她吗？如果她向你道歉，你会原谅她吗？如果现在林依然说，让我们和好吧，你会同意吗？ 赵燕说，其实我一点都不恨她。如果她向我道歉的话，我会毫不犹豫就原谅她的。如果她对我那样说的话，我会不假思索就答应她的。毕竟我们曾经是那么好的朋友。 于是在袁河的劝说下，她们便通过那个天蓝色的笔记本向对方道歉。结果每人都写了两三页。看得两人都哭了。后来她们就冰释前嫌和好如初了。 袁河与林依然。陆可凡与赵燕。关系始终很好。 至于袁河与陆可凡，那就不用说了。依然是最好的朋友。 最让人欣喜的是，班上同学对陆可凡的态度和偏见，也都发生了改变。 因为林依然的缘故，陆可凡认识到，自己安静内向的性格，以及与世隔绝的做法，实在太不应该了。毕竟大家都是同学，能够聚在一起便是缘分，完全没有必要那么绝情，搞的别人误会，自己受气，何苦呢？ 从此以后，陆可凡开始经常主动与人交往。别人向他请教题目时，他再也不会把解题过程写在草稿纸上面递给人家，而是认真地讲解，直到别人听懂为止。课间休息的时候，他有时也会出去和别人聚在一起，谈论自己感兴趣的话题。于是慢慢地，别人对他的态度就发生了改变。 袁河说，我早就知道，总有一天，你会变成一个活泼开朗的人。我也早就知道，总有一天，别人会重新认识你的。怎么样？我没有猜错吧。 在后来的日子里，他们四个人会一起去食堂吃饭，一起在教室聊天，一起上街闲逛，一起跑去上网……有人看了说，要是我能像他们那样的话，那我就是天下最快乐的人了。另一人道，废话，无论谁像她那样，都会觉得快乐的。不是吗？ 37 高二下学期考试结束那天，袁河提议说，明天大家就要分开了，明年大家就要高三了，为了我们的友谊，为了将来的高考，我们今晚不如聚在一起吃顿饭吧，怎么样？同意的举手。说完四个人同时举起手来。然后大声笑着说，走，出发！ 不用说，他们又是在校园外面那家名叫“三回头”的小餐馆里面吃的饭。到目前为止，除了袁河外，其他三人都在这里吃过三次饭了。真是名副其实的三回头啊。有意思！至于后来，他们还要回几次头，那就说不到了。 在吃饭的时候，大家脸上全都洋溢着欢乐，根本没有半分将要分别的痛苦。 袁河不知干掉了多少啤酒，反正喝到最后，眼前的一切全都开始变得飘渺起来，周围的一切全都幻化成了无数含苞欲放的花朵。在每个花朵上面都写有两个汉字，有的上面写着“友情”，有的上面写着“爱情”。然后袁河看到所有的花朵全都慢慢开放了，那样壮观，那样美丽。就像仙境一样。袁河仿佛还听到了花开的声音。那样婉转，那样动听。就像神曲一样。 袁河突然说，你们看，花开了！ 三人听后面面相觑。陆可凡说，袁河，你是不是喝醉了。我们送你回寝室休息吧。 袁河想说，我没有醉，我还要喝！但是头昏昏沉沉的，话还没有说出口，就已经趴在桌子上睡着了。 后来袁河多次提到那天晚上，自己看到的情景。但是别人却都不相信。都说那是幻觉。都说他在做梦。 袁河自言自语说，难道那真是幻觉？难道我真在做梦？但是我分明看到了友情花和爱情花慢慢开放的情景。我确实真切地听到了那些花开的声音。 也许这不是幻觉，不是做梦，而是真的。 那时花开！","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"应用架构设计原则","slug":"Program/2017-12-07-architecture-design-rule","date":"2017-12-06T16:00:00.000Z","updated":"2018-11-09T14:27:04.088Z","comments":true,"path":"2017/12/07/Program/2017-12-07-architecture-design-rule/","link":"","permalink":"http://heartaway.cn/2017/12/07/Program/2017-12-07-architecture-design-rule/","excerpt":"","text":"软件系统架构设计原则就是把我们在各种场景下的架构设计进行抽选化提取公共特征形成过一定的方法论，这些方法论是经过严格推敲并具备移植性的，我们在设计系统时遵从这些设计规则可以为我们的体统提供更高的扩展性、稳定性。 抽象原则各平台(含基础设施、中间件技术服务、各层业务服务等)需要通过合理地抽象，将内部信息、处理与扩展能力聚合成标准的服务于扩展接口，并通过统一的形式提供给使用者，屏蔽内部的实现与运行细节。 以下是一些符合抽象原则的架构规范或模式：架构分层(layer)/级(tier)，层、级间提供标准服务与数据接口根据业务模型，统一服务标准与数据标准使用服务目录屏蔽服务位置等实现细节使用“逻辑库”屏蔽数据库物理细节通过SLA，标准化服务的质量水平提供标准插件架构支持扩展使用标准数据库特性，保持厂商无关性使用逻辑的网络与系统名称使用商品化硬件单元 共享原则最大化重用数据、计算资源、业务组件等资产，防止数据、逻辑与技术实现不一致性带来的管理复杂性，避免重复建设成本与管理成本，通过安全机制保证共享资产的合法使用，通过业务分级保障共享资源效益最大化。以下是一些符合共享原则的架构规范或模式： 同一业务服务有唯一提供者 同一技术服务有唯一提供者 同一数据有唯一可信源 控制技术多样性 (但需要同时防止厂商绑定) 服务具备互操作性 服务具备易用性 统一的身份、访问控制与加解密机制 为共享服务提供多租户能力 (Multi-tenancy) 提供访问计量与控制能力 提供业务分级能力，对不同级别的业务提供区分服务 自治原则每一个组件（计算资源、业务组件、信息实体等）具备最大可能的自我完备性，可独立运行、监控、部署、配置与禁用，具备确定的SLA，并与其它组件之间以松散耦合的方式进行协作。当依赖的组件不存在或者无法正常提供服务时，能够以良好的方式降级，且在故障解除后自动恢复。以下是一些符合自治原则的架构规范或模式： 基于开-闭原则(OCP)设计组件 应用无启动依赖 最小化运行依赖集 根据运行依赖关系合理安排组件物理colocation 能够隔离依赖组件的故障 异步调用 (提升异常流量的承载能力，简化故障隔离的实现) 具备自我健康检查能力 具备自我恢复能力 无状态设计 冗余原则各组件（计算资源、业务组件、数据等）都必须有充分、合理的冗余实例，保证单一组件实例失效不影响业务正常运行（多活/热备），或可以通过切换备份实例快速恢复（温备/冷备），不会丢失不可恢复的数据。针对不同类型的组件，需要明确定义冗余量与冗余类型。以下是一些符合冗余原则的架构规范或模式： 高可用水平扩展服务器集群（负载均衡、健康检查与自动切换） 无单点设计 (含逻辑单点) 采用“随机写”策略的数据库水平拆分 Failover数据库 N+1或N+x设计 “多活”数据中心 数据复制 灾难备份 分布原则整个系统拆分成职责清晰、粒度恰当、便于管理的组件，各组件（计算资源、业务组件、数据等）可分布部署运行。组件的拆分与分布可以采取复制、根据功能垂直拆分、或根据用户与访问模式水平拆分等形式。以下是一些符合分布原则的架构规范或模式： 读写分离设计 垂直分拆 水平分拆 柔性的分布事务 自动原则系统设计了具备自监控、自管理、自适应与自优化能力，可以随着业务量与访问模式的变化、以及其它内、外部因素的改变，自动地对资源进行调度、调整服务策略，保障自身的稳定与服务的质量。以下是一些符合自动原则的架构规范或模式： 监控每一个服务的质量与资源的状态与报警 从客户视角监控最终服务的质量 统一、自动的错误报告、管理与响应 提供完备的配置能力 自动化系统安装 自动化应用部署 自动化资源分配 可以mark up/mark down服务 支持优雅降级 自动拒绝超出SLA之外异常流量","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"如何进行高效学习","slug":"Think/2017-11-24-how-to-study","date":"2017-11-23T16:00:00.000Z","updated":"2018-11-09T14:29:08.549Z","comments":true,"path":"2017/11/24/Think/2017-11-24-how-to-study/","link":"","permalink":"http://heartaway.cn/2017/11/24/Think/2017-11-24-how-to-study/","excerpt":"","text":"","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"消息收发中的中文乱码","slug":"Java/2017-10-20-message-string-byte","date":"2017-10-19T16:00:00.000Z","updated":"2018-11-09T14:24:06.308Z","comments":true,"path":"2017/10/20/Java/2017-10-20-message-string-byte/","link":"","permalink":"http://heartaway.cn/2017/10/20/Java/2017-10-20-message-string-byte/","excerpt":"","text":"背景：A发消息给B系统，A、B应用的编码均为UTF-8，但是B收到的消息出现中文乱码。 A发送消息的方式： 1new Message(TOPIC, TAG, null, (messageContent.toString()).getBytes()) 这里消息接受二进制byte数据，我们把消息string转换为byte的时候，默认使用了getBytes()，未指定编码方式，getBytes()方法的注释如下： Encodes this {@code String} into a sequence of bytes using the platform’s default charset, storing the result into a new byte array. 也就是会使用平台默认编码，查看StringCoding.encode方法中的Charset.defaultCharset().name()方法： 12345678910111213141516171819202122232425/** * Returns the default charset of this Java virtual machine. * * &lt;p&gt; The default charset is determined during virtual-machine startup and * typically depends upon the locale and charset of the underlying * operating system. * * @return A charset object for the default charset * * @since 1.5 */ public static Charset defaultCharset() &#123; if (defaultCharset == null) &#123; synchronized (Charset.class) &#123; String csn = AccessController.doPrivileged( new GetPropertyAction(\"file.encoding\")); Charset cs = lookup(csn); if (cs != null) defaultCharset = cs; else defaultCharset = forName(\"UTF-8\"); &#125; &#125; return defaultCharset; &#125; 注释的很清楚了，返回JVM默认的字符编码，如果在jvm启动参数中指定了-Dfile.encoding 编码，则优先使用此编码，如果未指定，则使用UTF-8编码； 登录服务器查看启动参数，发现A应用进程中指定了-Dfile.encoding=GB18030 示意图如下： 总结：在进行string与byte转换的时候，最好使用getBytes(String charsetName)方法，明确指定字符编码方式，最好编写一个编码转换的工具类，统一类型转换时的编码方式。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Linux phantomJs install course","slug":"Java/2017-09-21-phantomjs-install","date":"2017-09-20T16:00:00.000Z","updated":"2018-11-09T14:23:59.579Z","comments":true,"path":"2017/09/21/Java/2017-09-21-phantomjs-install/","link":"","permalink":"http://heartaway.cn/2017/09/21/Java/2017-09-21-phantomjs-install/","excerpt":"","text":"背景：我们在进行系统报告研发时，需要对报告结果进行定时邮件，所以需要把HTML内容自动转换为邮件内容，通常我们在发送邮件内容的时候内容是模板化的，模板基本不怎么改变，然而我们的报告却是由无数个子模块组成，这些子模块可以只有组合成为任意报告，每一个模块中的内容均为用户自定义，如果我们要实现通用化报告邮件化，那就需要把渲染后的报告转换为图片或者HTML格式，headless方案中常用的有phantomJS和Headless Chrome，phantomJS提供了截图等功能，所以称为我们的首选。 遇到的问题：我们生产环境大部分机器操作系统为5u，默认的glibc版本最高到2.5。然而 PhantomJS官网中明确指出Linux 64-bit操作系统下，需要依赖GLIBCXX_3.4.9 和 GLIBC_2.7/GLIBC_2.9/GLIBC_2.10。 但是在我们生产环境中： 12strings /lib64/libc.so.6 |grep GLIBCstrings /usr/lib64/libstdc++.so.6 |grep GLIBCXX 所以需要安装：GLIBCXX_3.4.9 GLIBC_2.7 一、安装phantoomjs1. 安装node：1234567891011sudo wget http://xxxxx/node-v6.11.2-linux-x64.tar.xzsudo xz -d node-v6.11.2-linux-x64.tar.xzsudo tar xvf node-v6.11.2-linux-x64.tarsudo ln -s /home/admin/phantomjs/node-v6.11.2-linux-x64/bin/node /usr/local/bin/nodesudo ln -s /home/admin/phantomjs/node-v6.11.2-linux-x64/bin/npm /usr/local/bin/npmsudo vi /etc/profilePATH=$PATH:/home/admin/phantomjs/node-v6.11.2-linux-x64/binnode -v 2. 安装npm：1curl -vvvL https://npmjs.com/install.sh &gt;/dev/null 3. 安装phantomJS：12345sudo wget http://xxxx/phantomjs-2.1.1-linux-x86_64.tar.bz2sudo tar -jxvf phantomjs-2.1.1-linux-x86_64.tar.bz2sudo ln -s /home/admin/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin/phantomjsphantomjs --version 我们的系统中没有这些动态库，有联两种办法，第一自己安装这些版本，第二升级操作系统到7u，我们先尝试使用第一种方法。 二、安装GCC因为部分版本的Glibc的安装需要高版本的GCC，默认的GCC版本为4.1.2，导致不能编译glibc的2.10以上版本，所以必须升级，gcc&gt;=4.3.3。 1234cd /home/admin/gcc/gcc-buildsudo yum install libstdc++-devel.i686sudo yum install libstdc++-devel.x86_64sudo ../gcc-4.8.2/configure --prefix=/usr/local/gcc-4.8.2 --with-gmp=/usr/local/gmp-6.0.0 --with-mpfr=/usr/local/mpfr-3.1.2 --with-mpc=/usr/local/mpc-1.0.1 --with-java-home=/opt/taobao/java --disable-multilib --disable-shared --enable-threads=posix --disable-checking --enable-languages=all --enable-static --enable-shared=libstdc++,libgcc_eh 或者： 123456789101112sudo ../gcc-4.8.2/configure --prefix=/usr/local/gcc-4.8.2 --enable-threads=posix --with-gmp=/usr/local/gmp-6.0.0 --with-mpfr=/usr/local/mpfr-3.1.2 --with-mpc=/usr/local/mpc-1.0.1 --mandir=/usr/share/man --infodir=/usr/share/info --enable-shared --disable-multilib --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-libgcj-multifile --enable-languages=c,c++,objc,obj-c++,java --disable-dssi --disable-plugin --with-java-home=/opt/taobao/java/jre --with-cpu=genericsudo makesudo make install #配置环境变量：sudo vi /etc/profileexport PATH=$PATH:/usr/local/gcc-4.8.2source /etc/profilesudo rm /usr/bin/gcc //删除旧的软连接 sudo ln -s /usr/local/gcc-4.8.2/bin/gcc /usr/bin/gcc //使新版本建立软连接 安装完毕后，查看GCC版本：12345678$gcc -vUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/local/gcc-4.8.2/libexec/gcc/x86_64-unknown-linux-gnu/4.8.2/lto-wrapperTarget: x86_64-unknown-linux-gnuConfigured with: ../gcc-4.8.2/configure --prefix=/usr/local/gcc-4.8.2 --with-gmp=/usr/local/gmp-6.0.0 --with-mpfr=/usr/local/mpfr-3.1.2 --with-mpc=/usr/local/mpc-1.0.1 --with-java-home=/opt/taobao/java --disable-multilib --disable-shared --enable-threads=posix --disable-checking --enable-static --enable-shared=libstdc++Thread model: posixgcc version 4.8.2 (GCC) 出现错误1：1configure: error: cannot compute suffix of object files: cannot compile See `config.log' for more details 查看config.log，发现错误： 1/home/admin/gcc/gcc-build/./gcc/cc1: error while loading shared libraries: libmpc.so.3: cannot open shared object file: No such file or directory 说明是环境变量设置未生效，检查环境变量&amp;ldconfig相关设置。 出现错误2：12/usr/local/include/gnu/stubs.h:7:27: fatal error: gnu/stubs-32.h: No such file or directorycompilation terminated. 安装：查看可用的版本：yum list available glibc-develsudo yum install glibc-develsudo yum install libstdc++-devel.i686 出现错误3：123/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/iosfwd:44:28: error: bits/c++config.h: No such file or directory/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/iosfwd:45:29: error: bits/c++locale.h: No such file or directory/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/iosfwd:46:25: error: bits/c++io.h: No such file or directory 解决方案： 1sudo yum install libstdc++-devel.x86_64 出现错误4：12lib/libgmp.so: could not read symbols: File in wrong format collect2: error: ld returned 1 exit status/home/admin/gcc/gcc-build/x86_64-unknown-linux-gnu/32/libjava/classpath/native/jni/java-math' 解决方案： 1sudo ../gcc-4.8.2/configure --prefix=/usr/local/gcc-4.8.2 --enable-threads=posix --disable-checking --with-gmp=/usr/local/gmp-6.0.0 --with-mpfr=/usr/local/mpfr-3.1.2 --with-mpc=/usr/local/mpc-1.0.1 --enable-shared --enable-languages=all --enable-libgomp --enable-lto --enable-tls --with-fpmath=sse --disable-multilib --build=x86_64-redhat-linux --with-java-home=/opt/taobao/java 出现错误5：1Error: unrecognized symbol type \"gnu_unique_object\" 解决方案：移除 configure参数中的 gnu_unique_object 配置； 出现错误6：1configure: error: libXtst not found, required by java.awt.Robot 解决方案：移除 configure参数中的 java.awt 配置； 出现错误7：libtool: compile: not configured to build any kind of library解决方案：sudo ../gcc-4.8.2/configure –prefix=/usr/local/gcc-4.8.2 –with-gmp=/usr/local/gmp-6.0.0 –with-mpfr=/usr/local/mpfr-3.1.2 –with-mpc=/usr/local/mpc-1.0.1 –with-java-home=/opt/taobao/java –disable-multilib –disable-shared –enable-threads=posix –disable-checking –enable-languages=all –enable-static –enable-shared=libstdc++,libgcc_eh 出现错误8：cc1plus: error: unrecognized command line option “-Wno-narrowing”解决方案：目前没有查询到好的解决方案； 出现错误9：/usr/include/string.h:550:18: error: unknown type name ‘__locale_t’解决方案：暂无 出现错误10：/usr/lib64/libstdc++.so.6: undefined symbol: _ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2idE, version GLIBCXX_3.4 三、安装GlibC查看当前系统Glibc的版本： 1strings /lib64/libc.so.6 |grep GLIBC 编译glibc： 1234567891011121314151617181920sudo mkdir gliccd glicsudo wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.7.tar.gzsudo wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.9.tar.gz//sudo wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.10.1.tar.gzsudo wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.14.tar.gzsudo tar zxvf glibc-2.7.tar.gzsudo tar zxvf glibc-2.9.tar.gzsudo tar zxvf glibc-2.10.1.tar.gzsudo tar zxvf glibc-2.14.tar.gzsudo mkdir glibc-build-2.7sudo mkdir glibc-build-2.9sudo mkdir glibc-build-2.10.1sudo mkdir glibc-build-2.14cd glibc-build-2.7sudo ../glibc-2.7/configure 遇到错误：configure: error: no acceptable C compiler found in $PATH安装gcc套件(rpm -qa |grep gcc 可以看到目前的版本时4.1.2，注意此版本太老，导致不能编译glibc的2.10以上版本，所以必须升级，gcc&gt;=4.3.3)： 遇到错误： 123*** On GNU/Linux systems the GNU C Library should not be installed into*** /usr/local since this might make your system totally unusable.*** We strongly advise to use a different prefix. For details read the FAQ. INSTALL文件摘录如下： configure&#39; takes many options, but the only one that is usually mandatory is–prefix’. This option tells configure&#39; where you want glibc installed. This defaults to/usr/local’, but the normal settingto install as the standard system library is --prefix=/usr&#39; for GNU/linux systems and–prefix=’ (an empty prefix) for GNU/Hurdsystems. 关于安装目录的选择: 1--prefix=PREFIX 安装目录，默认为 /usr/localLinux文件系统标准要求基本库必须位于 /lib 目录并且必须与根目录在同一个分区上，但是 /usr 可以在其他分区甚至是其他磁盘上。因此，如果指定 –prefix=/usr ，那么基本库部分将自动安装到 /lib 目录下，而非基本库部分则会自动安装到 /usr/lib 目录中。但是如果保持默认值或指定其他目录，那么所有组件都间被安装到PREFIX目录下。 123sudo ../glibc-2.7/configure --prefix=/usr --disable-multi-archsudo ../glibc-2.9/configure --prefix=/usr --disable-multi-archsudo ../glibc-2.14/configure --prefix=/usr --disable-multi-arch 在每个build目录下，执行glibc的配置： 123sudo ../glibc-2.7/configure --prefix=/usr --disable-multi-archsudo ../glibc-2.9/configure --prefix=/usr --disable-multi-archsudo ../glibc-2.10.1/configure --prefix=/usr --disable-multi-arch 分别进入每个build目录，执行命令(在 glibc-build-xx 目录下)： 1sudo make all &amp;&amp; make install 如果直接执行（sudo make install）出现错误提示： 12345make[2]: *** No rule to make target `/home/admin/glibc-build/dlfcn/libdl.so.2', needed by `/home/admin/glibc-build/elf/sprof'. Stop.make[2]: Leaving directory `/home/admin/glibc-2.7/elf'make[1]: *** [elf/subdir_install] Error 2make[1]: Leaving directory `/home/admin/glibc-2.7'make: *** [install] Error 2 解决方案(先执行make all， 再执行 make install); 安装完毕后，出现提示： 12Your new glibc installation seems to be ok.make[1]: Leaving directory `/home/admin/glibc-2.7' 常见错误信息1：12/lib/modules/2.6.32-220.23.2.ali927.el5.x86_64/build/include/linux/swab.h:6:22: fatal error: asm/swab.h: No such file or directory #include &lt;asm/swab.h&gt; 解决办法： 1sudo touch /lib/modules/2.6.32-220.23.2.ali927.el5.x86_64/build/include/asm-x86/swab.h 参考：https://bbs.archlinux.org/viewtopic.php?id=70488 常见错误信息2：configure: error: assembler too old, .cfi_personality support missing解决办法：google说gcc版本太老。 常见错误信息3：1/usr/bin/ld: cannot find -lgcc_eh 原因是： glibc在安装的时候，需要使用gcc_eh（–enable-shared），但是我们在安装gcc时，添加了–disable-shared，禁用了shared功能，所以导致此库找不到；测试gcc_eh是否安装：sudo gcc -lgcc_eh –verbose 解决办法： 12sudo find / -name libgcc.asudo cp libgcc.a libgcc_eh.a 参考：http://www.linuxfromscratch.org/clfs/view/clfs-2.0/arm/cross-tools/glibc.htmlhttps://gcc.gnu.org/ml/gcc-patches/2005-02/msg00532.htmlhttp://lists.linuxfromscratch.org/pipermail/lfs-support/2012-December/044174.html 常见错误信息4：1Can't open configuration file /usr/etc/ld.so.conf: No such file or directory 参考：http://www.math.ias.edu/~tarzadon/pages/posts/install-opam-on-springdalerhelcentossl-5.x-111.php 常见错误信息5：1/build/include/linux/capability.h:73: error: expected specifier-qualifier-list before ‘__le32’ 解决方案：参考：https://github.com/spotify/linux/blob/master/include/linux/capability.hsudo yum install openssl-devel gnutls-devel libcap-devel查看版本：strings /lib64/libc.so.6 |grep GLIBC 四、安装GLIBCXX查看版本：strings /usr/lib64/libstdc++.so.6 |grep GLIBCXX查看：ls -l /usr/lib64/libstdc++.so.6lrwxrwxrwx 1 root root 18 Aug 14 2015 /usr/lib64/libstdc++.so.6 -&gt; libstdc++.so.6.0.8 自己编译gcc的过程太繁琐，需要依赖非常多的文件，直接下载高版本下的文件进行替换： 123456789sudo wget http://xxx/libstdc%2B%2B.so.6.0.13sudo cp libstdc++.so.6.0.13 /usr/libsudo cp libstdc++.so.6.0.13 /usr/lib64cd /usr/libsudo ln -sf libstdc++.so.6.0.13 libstdc++.so.6cd /usr/lib64sudo ln -sf libstdc++.so.6.0.13 libstdc++.so.6 再次执行 1strings /usr/lib64/libstdc++.so.6 |grep GLIBCXX 发现需要的安装包已经安装完毕； 五、MAC下安装phantomJS：下载文件到本地目录；添加环境变量： 123vi .bash_profileexport PATH=$PATH:/Users/xinyuan/soft/phantomjs-2.5.0-beta-macos/binsource .bash_profile 安装webp： 12ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" &lt; /dev/null 2&gt; /dev/nullbrew install webp 建立软连： 1ln -s /usr/local/opt/webp/lib/libwebp.7.dylib /usr/local/opt/webp/lib/libwebp.6.dylib 查看版本： 12phantomjs -v2.5.0-development 六、总结：整个OS的环境安装由于对linux底层不熟悉，参数配置也没有详细查看文档，导致安装过程出现了非常多的意外，之前使用的操作系统是5u，gcc版本为4.1.2，依赖的glibc、glibxx、gmp、mpfr、mpc库版本都比较低，但是phantomjs（JS截图）需要依赖其高版本库，为了升级响应的库，通过下载源码，make、install ，出现了不下于30个错误，每次解决一个错误后续流程中又出现了新的错误，费劲周折把所有依赖的库都装好后，运行phantomjs还是出错，怀疑是缺少了一些动态库； 后来还是通过升级操作系统，解决了此问题，升级操作系统完成docker化文件配置，总共才花费了不到一天时间。反思：遇到问题，首选需要评估一下解决此问题的最有效手段，而不是闷头上去搞，要看我们从中能得到什么，在linux操作系统上安装一坨软件并不能证明我们有什么能力，所以这件事情就不应该自己去尝试做，投入产出比是做事情非常重要的一个衡量手段。 七、参考链接：http://blog.csdn.net/tsaiyong_ahnselina/article/details/21552485http://siliconcali.com/2012/10/glibcxx_3-4-9-not-found-in-red-hatfedoracentos-linux/http://blog.csdn.net/tengdazhang770960436/article/details/41348035http://www.cnblogs.com/LitLeo/p/3534196.htmlhttp://blog.csdn.net/wtfmonking/article/details/17577925http://www.cnblogs.com/coolulu/p/4124803.html","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"成长集：在阿里的做事方式","slug":"Think/2017-09-12-person-grouth","date":"2017-09-11T16:00:00.000Z","updated":"2018-11-09T14:29:22.528Z","comments":true,"path":"2017/09/12/Think/2017-09-12-person-grouth/","link":"","permalink":"http://heartaway.cn/2017/09/12/Think/2017-09-12-person-grouth/","excerpt":"","text":"对自己要求很高、产品的商业价值、爽的地方和不爽的地方 能力全面，有擅长的东西 应对变化，技能没有竞争力，什么都能干 平台的放大器效应 规定时间拿到结果 新业务的短平快 技术创建不一样的东西 自主发起尝试新东西 工作干到9点且技术探索在干2小时 评论需要真知灼见否则不要评论，会显得肤浅 做过业务才能理解价值 所有的技术要懂，有些必须精通，比别人要懂 共赢和合作，技术不一定是自己做的，可以使用官方的东西 我们必须要结果不管谁做 方法论 双十一驱动 赚钱 向上管理、水平管理 标杆、机会成本（超出期望是所有人认为不可能） 借假修真、自己的身价、 效率学习方向结果、方向比努力重要 创新者的窘境、团队的健康、兼容限制创新、平台能力、平台化、创新型产品、技术超越业务、创新是一个伪需求。 不要拘泥于眼前的事情，看到未来，把事情干出来 做多快好省的事情、不同事情做不同事情、形式逼人强、为离开阿里准备能力，选择相信的东西去坚持、自我驱动、学习不能放松、控多大场、眼界、难中易抢活。 谁都可以做的事情没什么竞争价值、在自己擅长的领域跟别人打，开源并不一定是好事情，关键是看你的商业逻辑，比如google和dubbo的案例。 总结： 不断学习，什么都学，有所专长（终身学习）； 要结果，不管过程，老板交代的事情，必须提前完成，并能主动向上沟通； 相信安排给你做的事情； 需要停下来思考： 让自己成长； 把事情做好； 拿到一个确定性（可衡量）的结果； 做双十一，我们的成长在哪里？ 稳定性体系； 技术创新在双十一进行验证； 作为技术人员，需要主动去寻找机会； 今年与去年的不同，变化； 那些东西做的不好，我们能做什么，最好提前一年去思考和建设； 看业界有什么，我们处于什么位置，我们可以模仿，更重要的是结合自身业务； 把当前产品做出新花样，新高度； 提出视野，需要跟各个专业的人达成沟通； 技术人，走出去； 坐在家里永远找不到机会； 关系网络； 主动找机会，主动承担责任； 做双十一，如果不能做好，就可能导致混不下去，因为自己的名誉坏掉了。 需要做创新，无论新老系统； 系统化： 找到方法把自己做的事情做没；能够更大体系进行协同； 人的事情，渐渐的交给机器去做； 智能决策； 把我的作用变大，并把它自动化； 不断证明自己，并拿到结果； 这个事情非你莫属；形成个人的品牌、口碑； 主动性和责任心，不要等待领导去问； 能不能做，给出理由； 找到一个点，做事情能带来成就感； 如果事情没有贡献，可有可无，就需要反思； 现在做的事情如果跟三年前一样，自己就得不到成长； 信任很重要； 双十一的体系化； 把各个独立的模块串起来，减少成本； 双十一很多变量，很多东西都在人的脑子里，需要固化下来； 系统化，把人的能力撤出来，体系化； 产品化； 更高效、更快速的大促； 山不过来，我过去； 做一个产品，每人会告诉你改怎么发展，你的老板都没有你专业； 如果我们的产品在进行review的时候，发现没有大的发展，那一定是我们自己的问题； 主要是自己能把事情想清楚； 做事情，推不动，想一想是不是执行路径不对； 应该考虑如何把事情做成，而不是看到很多困难认为事情做不成； 先成长，再去做更难的事情。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Mysql时间精度丢失，导致秒被四舍五入","slug":"Mysql/2017-09-02-mysql-datetime-fsp","date":"2017-09-01T16:00:00.000Z","updated":"2018-11-09T14:25:48.572Z","comments":true,"path":"2017/09/02/Mysql/2017-09-02-mysql-datetime-fsp/","link":"","permalink":"http://heartaway.cn/2017/09/02/Mysql/2017-09-02-mysql-datetime-fsp/","excerpt":"","text":"问题描述：Mysql中一张表时间类型采用的是dateTime格式，当后端通过Mybatis将new Date() 传递给数据库进行存储是，发现存入时间是2016-12-23 16:41:55，但是数据库中插入的时间却是*2016-12-23 16:41:5_6_,导致采用同样的时间进行数据查询，却查不到数据。 问题排查： 进行codeReview，未发现bug； 本地将Mybatis的DEBUG日志打开，进行单步调试 日志输出如下： 122016-12-23 16:43:26.960 [DEBUG]xxx.update [debug:145] ==&gt; Preparing: update xxx SET gmt_modified = now(), status = ?, collect_time = ? where id = ? 2016-12-23 16:43:26.964 [DEBUG][debug:145] ==&gt; Parameters: SLEEPING(String), 2016-12-23 16:41:55.972(Timestamp), 9(Long) 发现传入mybatis的date参数为携带毫秒数的时间，到服务端之后多了一秒，但是有时候又是相等的，初步怀疑是毫秒数会被四舍五入了，多次执行后，正式了这个观点；这也能解释为什么我们再以同样的Date参数为什么偶尔查不到数据的问题了。 根因定位： 确认Mysql Server的版本信息： 确认Datetime的格式信息： JDBC（JDBC版本5.1.26）中判断是否MysqlServer（Server版本5.6.4）的版本是否支持毫秒：com.mysql.jdbc.PreparedStatement#detectFractionalSecondsSupport:923L JDBC（JDBC版本5.1.26）中设置毫秒数函数：com.mysql.jdbc.PreparedStatement#setTimestampInternal首先会判断是否设置了useLegacyDatetimeCode=false，如果设置了，那么会走新方法newSetTimestampInternal：可以看到，新方法中会不管mysql服务端的版本信息是什么，默认都会把毫秒数携带上发送给服务端，让服务端来判断毫秒数怎么处理。当我们代码中把这部分携带了毫秒的时间发送给服务端时，由于服务端版本为5.6.16，所以不支持毫秒数，所以就被四舍五入进行存储到秒了。 在看看如果设置了useLegacyDatetimeCode=true的逻辑：那useLegacyDatetimeCode到底是什么？ Note that to get this scenario to work with MySQL (since it doesn’t support per-value timezones), you need to configure your server (or session) to be in UTC, and tell the driver not to use the legacy date/time code by setting useLegacyDatetimeCode to “false”. This will cause the driver to always convert to/from the server and client timezone consistently. 精度问题：Mysql中 DATE, DATETIME, and TIMESTAMP 三种类型的区别，可以参考：http://dev.mysql.com/doc/refman/5.6/en/datetime.html。 需要纠正一个错误的观点，那就是有同学认为DATETIME比TIMESTAMP精度低，这个是错误的，他们两个能达到的精度是一致的，只不过，他们可表示的时间范围不同而已；测试Mysql5.7.14版本下，三种时间类型的数据插入：对于一个立志存活102年的企业来说，选择DATETIME比TIMSTAMP是一个更明智的选择，可以表示的范围更大，而且不受系统时区的影响； 总结：至此，我们知道了三种时间类型在不同Mysql版本不同的所展示的不同的特点，以及不同Mysql版本对毫秒的支持情况；目前我们服务端由于采用的mysql版本是5.6.16(低于5.6.4)，所以还不支持毫秒数的存储，当客户端提交过来的小数部分超长时（客户端默认配置了useLegacyDatetimeCode=false），server会默认做四舍五入，不会出现任何的警告或异常。那么在这种情况下，问题如何解决呢？①客户端在进行时间存储的时候，主动通过一次SimpleDateFormat函数format和parse将毫秒数过滤掉，相当于重置为0；②升级Mysql Server版本到5.6.4及以上； 扩展：Java中的Date类型：java.util.Date 与 java.sql.Date 的关系？java.util.Date 就是在除了SQL语句的情况下面使用；java.sql.Date 继承自 java.util.Datejava.sql.Date 是针对SQL语句使用的，它只包含日期而没有时间部分；","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://heartaway.cn/categories/Mysql/"}],"tags":[]},{"title":"How to select text data type for mysql","slug":"Mysql/2017-09-01-mysql-text-field","date":"2017-08-31T16:00:00.000Z","updated":"2018-11-09T14:25:42.579Z","comments":true,"path":"2017/09/01/Mysql/2017-09-01-mysql-text-field/","link":"","permalink":"http://heartaway.cn/2017/09/01/Mysql/2017-09-01-mysql-text-field/","excerpt":"","text":"在进行后台页面模块配置化时，需要把前段页面的部分代码保存到db中，之前mysql的数据类型使用的是text，并没有考虑到text的长度限制，认为一般不会超过此限制，但是在运行中发现其中一个复杂的页面模块在保存时报错； 1Caused by: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column 'xxx' at row 1 此时发现 xxx 字段的长度为text类型，需要保存的文本长度为 65581，mysql提供了四种类型的text类型，如下： Type Maximum length TINYTEXT 255 (2 8−1) bytes TEXT 65,535 (216−1) bytes = 64 KiB MEDIUMTEXT 16,777,215 (224−1) bytes = 16 MiB LONGTEXT 4,294,967,295 (232−1) bytes = 4 GiB 我们存储的数据超过了text的存储长度（65535），所以修改数据类型为MEDIUMTEXT。 Mysql 中char、varchar、和text定义的空间大小和实际占用的关系又是怎么样的呢？ 基本知识： char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。 同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1&lt;=n。 超过char和varchar的n设置后，字符串会被截断。 char的上限为255字节，varchar的上限65535字节，text的上限为65535。 char在存储的时候会截断尾部的空格，varchar和text不会。 varchar会使用1-3个字节来存储长度，text不会。 Value CHAR(4) Storage Required VARCHAR(4) Storage Required ‘’ ‘ ‘ 4 bytes ‘’ 1 bytes ‘ab’ ‘ab ‘ 4 bytes ‘ab’ 3 bytes ‘abcd’ ‘abcd’ 4 bytes ‘abcd’ 5 bytes ‘abcdefgh’ ‘abcd’ 4 bytes ‘abcd’ 5 bytes 总体来说： char，存定长，速度快，存在空间浪费的可能，会处理尾部空格，上限255。 varchar，存变长，速度慢，不存在空间浪费，不处理尾部空格，上限65535，但是有存储长度实际65532最大可用。 text，存变长大数据，速度慢，不存在空间浪费，不处理尾部空格，上限65535，会用额外空间存放数据长度，顾可以全部使用65535。 当字符长度超过255的长度之后，使用varchar和text没有本质区别，只需要考虑一下两个类型的特性即可。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://heartaway.cn/categories/Mysql/"}],"tags":[]},{"title":"Distributed System Id Gen","slug":"Java/2017-07-31-distrubute-id-gen","date":"2017-07-30T16:00:00.000Z","updated":"2018-11-09T14:23:52.599Z","comments":true,"path":"2017/07/31/Java/2017-07-31-distrubute-id-gen/","link":"","permalink":"http://heartaway.cn/2017/07/31/Java/2017-07-31-distrubute-id-gen/","excerpt":"","text":"分布式系统高效唯一ID生成方案 背景：在分布式系统中，对于订单ID如何保证全局唯一地高效的生成，并对性能影响不大的情况下，利于建立索引和业务使用？ 方案一：使用数据库主键ID优势：实现简单；弊端：使用数据库增加写库的压力，生成订单的上限受限于数据库的写性能上限；扩展性差； 方案二：使用数据库的列+1主键采用业务编码，普通列current_value标识id当前值，通过数据库的行锁来保障唯一的；优势：一张表可以存储不同业务类型的生成规则，没必要每一个id规则都新建一张附表；劣势：涉及行锁，性能不高； 需要注意使用此方式生成数字序列事务隔离级别需要是RR。 方案三：单点批量生成订单号的服务优势：批量降低了数据库的读写压力弊端：服务单点风险； 方案四：使用UUID优势：本地生成ID，不进行远程调用，延迟低；弊端：无法保证趋势增长；uuid过长且建立索引效率低下；64位太长； 方案五：使用毫秒数优势：本地生成ID，不进行远程调用，延迟低；ID为整数利于建立索引；弊端：并发超过1000，可能会重复；优化方案：使用LRU Cache存储最近生成的100Key，去除后先判断是否重复；进一步降低重复的可能性；但是无法根本上解决高并发下的重复； 方案六：订单号分段表示具体含义方案描述：使用39bit表示毫秒数、4bit表示业务线、7bit表示机器等优势：实现简单，且重复可能性很低；弊端：订单长度过长，不利于业务使用； 方案七：使用Redis服务+毫秒数双重方案优势：使用redis的自增序列特性，每次获取一定数量的数据（1000个），降低了每次调用Redis的开销；当Redis挂了，使用基于毫秒数的本地生成ID优化方案；弊端：redis挂了后，订单号的重复性不可避免； 使用redis需要配置主备，避免在极端情况下redis节点down机， 导致丢失序列或序列重复。 总结：我们在设计分布式全局唯一单号的时候，不仅需要考虑生成单号的是否重复性，还要考虑生成时的性能开销、是否有容灾方案、是否便于建立索引、是否利于业务使用等。基于这些点的考虑，我们采用了方案六作为线上的唯一生成方案，并把此方案作为一个业务隔离的二方库，可以提供给不同业务方式用； 参考：高可用高性能可扩展的单号生成方案&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=Q2dSEf7cwUT%2FHuuZ1wpxUh3%2Fd9hovwWFg9YsoOzUMokJ2WygwbBZxUPkJXDCEA09)","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Springmvc  File Download","slug":"Java/2017-07-29-springmvc-file-download","date":"2017-07-28T16:00:00.000Z","updated":"2018-11-09T14:23:45.135Z","comments":true,"path":"2017/07/29/Java/2017-07-29-springmvc-file-download/","link":"","permalink":"http://heartaway.cn/2017/07/29/Java/2017-07-29-springmvc-file-download/","excerpt":"","text":"背景：对于后端程序员来说，经常会遇到使用POI对excel进行上传与下载的需求，掌握一套高效的文件下载核心库和核心方法，会让我们日常编码效率变得更高。本文针对几种常见的的文件下载场景进行阐述如何高效实现文件下载。 一、了解HttpServletResponse：不了解servlet及其工作原理的，建议先学习许令波写的Servlet 工作原理解析。 当服务端返回到数据给浏览器时，浏览器怎么知道是按照文本解析呢还是以附件的形式保存文件？这就涉及到了请求响应体（HttpServletResponse）中的两个重要参数：contentType、Content-Disposition； HttpServletResponse 继承了ServletResponse接口，增加了http特性相关的一系列方法。 HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 1.1、负责向客户端(浏览器)发送数据的相关方法这两个方法继承自ServletResponse接口，分为二进制输出（一般用于文件下载）、字符输出； 1.2、负责向客户端(浏览器)发送响应头的相关方法 1.3、负责向客户端(浏览器)发送重定向的相关方法 1.4、负责向客户端(浏览器)发送错误信息的相关方法 图中的四种处理响应的方式，都是通过HttpServletResponse对象来完成的： 二、静态资源下载：静态资源包括web服务器上或者云存储上的静态资源下载，这部分只需要我们配置化一定的请求过滤器即可实现下载，这里不做过多阐述；一般情况下，提供资源下载的服务会使用类似于Nginx的Http Server，提高响应效率，tomcat更多的使用在动态http资源请求处理上； 三、动态资源下载：有些场景下，我们需要下载的文件并不存在，而是实时根据查询条件生成的文件，比如写在的报表数据通过excel合适输出。 最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。 MIME意为多功能Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 3.1 设置contentType和Content-Disposition：123httpServletResponse.setContentType(\"application/octet-stream\");httpServletResponse.addHeader(\"Content-Disposition\", \"attachment;filename=\" + new String(fileName.getBytes(\"UTF-8\"), \"iso8859-1\")); application/octet-stream：这是应用程序文件的默认值。意思是 未知的应用程序文件 ，浏览器一般不会自动执行或询问执行。浏览器会像对待 设置了 HTTP头Content-Disposition 值为“附件”的文件一样来对待这类文件。 Content-Disposition：它是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。 文件名中文被过滤问题：当我们使用new String(fileName,”UTF-8”)时，文件名称中的中文被自动过滤掉了，原因是header中只支持ASCII。解决办法有三个： 使用iso8859-1字符编码；此解决方案在IE浏览器下，下载的文件名称如果包含中文还是会出现乱码； 使用URLEncoder.encode(fileName,”UTF-8”)进行转换； 注意这里文件名称字符如果使用urlencoder转换只支持UTF-8，不支持GBK； 使用filename*=charset’lang’valuecharset则是给浏览器指明以什么编码方式来还原中文文件名；比如： 1headers.add(\"Content-Disposition\",\"attachment;filename*=UTF-8''\"+URLEncoder.encode(fileName,\"UTF-8\")+\".xls\"); 3.2 输出二进制流：定义BufferedOutputStream 向httpServletResponse.getOutputStream()写入二进制文件： 123456789101112131415161718192021222324252627282930313233343536FileWriterWithEncoding fwwe = new FileWriterWithEncoding(file, \"gb18030\");BufferedWriter bw = new BufferedWriter(fwwe);bw.write(\"待写入内容\");fwwe.close();bw.close();BufferedInputStream bis = null;BufferedOutputStream out = null;try &#123; bis = new BufferedInputStream(new FileInputStream(file)); out = new BufferedOutputStream(httpServletResponse.getOutputStream()); byte[] buff = new byte[2048]; while (true) &#123; int bytesRead; if (-1 == (bytesRead = bis.read(buff, 0, buff.length))) &#123; break; &#125; out.write(buff, 0, bytesRead); &#125; file.deleteOnExit();&#125; catch (IOException e) &#123; throw e;&#125; finally &#123; try &#123; if (bis != null) &#123; bis.close(); &#125; if (out != null) &#123; out.flush(); out.close(); &#125; &#125; catch (IOException e) &#123; throw e; &#125;&#125; 如果我们使用了easyExcel二方库，输出excel变得更加简单： 1234ExcelWriter writer = new ExcelWriter(httpServletResponse.getOutputStream(), ExcelTypeEnum.XLS, true);Sheet sheet = new Sheet(1, 1);writer.write0(datas, sheet);writer.finish(); 写入数据过程中，注意中文乱码。data.getBytes()是一个将字符转换成字节数组的过程，这个过程中一定会去查码表，如果是中文的操作系统环境，默认就是查找查GB18030的码表，将字符转换成字节数组的过程就是将中文字符转换成GB18030的码表上对应的数字，所以我们在带有中文的文件输出到中文环境时，尽可能使用GB18030编码； GB2312是过时标准、GBK是微软标准、GB18030是国家标准； 关于中文字符编码： GB2312：1980年，一共收录了7445个字符，包括6763个汉字和682个其它符号。 GBK：是微软对GB2312的扩展，向下兼容GB2312编码，出现于Windows 95简体中文版中，微软标准但不是国家标准。 GB18030：2000年，取代了GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了一些少数民族文字。 GB13000：GB13000等同于国际标准的《通用多八位编码字符集 (UCS)》 ISO10646.1，就是等同于Unicode的标准，代码页等等的都使用UTF的一套标准。 四、大文件下载对于大文件的下载，建议服务端先将文件在本地生成后，上传到文件存储服务中心，用户再从存储中心下载，当然，我们也可以针对大文件实现多线程并发断点下载，提高下载速度；","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Mysql MAX/MIN vs ORDER BY and LIMIT","slug":"Java/2017-07-04-mysql-max-orderby-limit","date":"2017-07-03T16:00:00.000Z","updated":"2018-11-09T14:23:40.519Z","comments":true,"path":"2017/07/04/Java/2017-07-04-mysql-max-orderby-limit/","link":"","permalink":"http://heartaway.cn/2017/07/04/Java/2017-07-04-mysql-max-orderby-limit/","excerpt":"","text":"我们在进行数据库的TOP N 操作时，又两种选择，一种使用内置的函数MAX/MIN，另外一种是采用 ORDER BY 和 LIMIT的组合，那么在什么情况下使用那种策略呢，哪种效率会更高一些呢？ 在最坏的情况下，如果你正在寻找在一个无索引的字段，使用min()需要全表扫描。使用order by + limit 要求一个排序后的文件。如果碰到一个大表，性能差异会非常大。在我本机上测试了一个106000行的随机数据表，min()带消耗了0.36s,而order by + limit消耗了0.84s。如果对于一个索引列，两者的差别并不是太大。 总的来说：似乎min()性能更高，它在最坏的情况下的速度更快，在最好的情况下，没有什么区别； 通过“show status like ‘last_query_cost’” 查看执行成本；分别测试了在无索引列下使用max 和 order by limit 两种查询条件下的cbo，分别为 228322 和 67359，结果展示使用max的成本要比order by更高,这点还需要进一步探究； 参考：https://stackoverflow.com/questions/426731/min-max-vs-order-by-and-limit","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java split 引发的坑","slug":"Java/2017-07-03-string-split","date":"2017-07-02T16:00:00.000Z","updated":"2018-11-09T14:23:35.439Z","comments":true,"path":"2017/07/03/Java/2017-07-03-string-split/","link":"","permalink":"http://heartaway.cn/2017/07/03/Java/2017-07-03-string-split/","excerpt":"","text":"我们在代码编写中会进程需要使用数据截断处理，比如 30.23 我们期望获取整数部分，按照“.”进行分割； 可能的代码示例： 1\"30.23\".split(\".\")[0] 如果我们这么写，那结果一定不是我们期望的，查看string 类中的split方法： 我们看到，它接收的参数 正则表达式，恰好点是正则表达式的特殊字符，命中 1&quot;.$|()[&#123;^?*+\\\\&quot;.indexOf(ch = regex.charAt(0)) 条件，所以执行的实际逻辑为： 1Pattern.compile(regex).split(this, limit) “.” 表示匹配任何字符，那么按照任何字符进行分割，将得到””空字符串数组，Pattern.split在构造结果时，由于limit=0，会把结尾的空字符串丢弃，结果就返回了一个长度为0的String对象数组 new String[0] ,此时我们使用[0]获取数据中第一个元素时，会抛出数组越界的异常： 1Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0 如果我们期望使用string.split(regex)方法，对于特殊字符，需要进行转义处理，比如： 1\"30.23\".split(\"\\\\.\")[0] 常用的字符拆分方案有以下几种： 方法二： org.apache.commons.lang.StringUtils.split此方法使用完整的字符串作为参数，而不是regex。底层调用splitWorker方法； 12345String number = \"30.23\";String[] split = StringUtils.split(number, \".\");for (String s : split) &#123; System.out.println(s);&#125; 输出结果： 123023 方法三：com.google.common.base.Splitter使用Google Guava包中提供的分割器splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等； 12345String number = \"30.23\";Iterable&lt;String&gt; split = Splitter.on('.').trimResults().omitEmptyStrings().split(number);for (String s : split) &#123; System.out.println(s);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"(转)史上最全的架构师图谱","slug":"Java/2017-06-30-study-road-line","date":"2017-06-29T16:00:00.000Z","updated":"2018-11-09T14:23:27.256Z","comments":true,"path":"2017/06/30/Java/2017-06-30-study-road-line/","link":"","permalink":"http://heartaway.cn/2017/06/30/Java/2017-06-30-study-road-line/","excerpt":"","text":"本文是笔者多年来积累和收集的知识技能图谱，有的是笔者原创总结的最佳实践，有的是小伙伴们的分享，其中每个秘籍图谱里面的内容都是互联网高并发架构师应该了解和掌握的知识，笔者索性把这些图谱收集在一起，并且归类便于查找和学习，希望能够帮助到每一位想成为架构师或者已经是架构师的小伙伴，这里我们的标题“史上最全的架构师图谱”是本文的目标，作者计划把这篇文章作为一个开放性的文章，如果读者发现更多的图谱，请联系作者本人，我们把更多的图谱、思维导图汇集在其一起，最终一定能成为互联网上“史上最全的架构师图谱”。 架构师系列 架构师图谱Java架构师图谱微服务架构秘籍一致性图谱互联网大流量的方法安全秘籍阿里巴巴常用小框架架构方法论图谱设计模式秘籍图谱 Java系列 JVM垃圾回图谱Java并发图谱Java集合图谱Java集合类图Java List类图Java Map类图Java Set类图 大数据系列 Hadoop技能图谱大数据技能图谱 云计算系列 云计算图谱云计算技能图谱 其他 IOS技能图谱OpenResty技能图谱前端技能图谱容器技能图谱嵌入式开发技能图谱开发语言宝典移动端测试图谱运维技能图谱","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java Load CPU MEM 飙高的一次排查","slug":"Java/2017-06-15-while-died","date":"2017-06-14T16:00:00.000Z","updated":"2018-11-09T14:23:20.504Z","comments":true,"path":"2017/06/15/Java/2017-06-15-while-died/","link":"","permalink":"http://heartaway.cn/2017/06/15/Java/2017-06-15-while-died/","excerpt":"","text":"问题发现：收到报警提醒： 问题排查：登录机器查看： CPU 持续高于 80%，8G内存几乎被占满； 异常报警项为 一个每隔5min执行一次的定时任务每次运行时间超过10分钟；初步判断为任务累加导致系统负载越来越重。 那为什么定时任务在5min内执行未完成呢？看看线程到底在做什么。 查看进程中线程的占用CPU时长：1top -Hp pid 可以看到有不少进程占用CPU总计时间超过100分钟，最大的进程257484为564分钟32.32秒； 查询其它的几个占用时间比较高的进程：发现都是ChangeFree的进程导致，查看相应代码后，发现最近的一次变更导致了程序在一些场景下出现了死循环：从代码可以看出，在while循环中的累加程序放在了最后，这是一种极危险的操作，应该讲累加条件放在程序进入的第一行，保证不受后续代码逻辑的影响； 问题解决后，通过系统监控发现系统负载恢复正常：","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Github Pages Build Blog","slug":"Tool/2017-05-18-github-io-blog","date":"2017-05-17T16:00:00.000Z","updated":"2018-11-09T14:31:44.151Z","comments":true,"path":"2017/05/18/Tool/2017-05-18-github-io-blog/","link":"","permalink":"http://heartaway.cn/2017/05/18/Tool/2017-05-18-github-io-blog/","excerpt":"","text":"在github上新建一个项目，项目名称为““projectName.github.io”” ,其中projectName需要替换为你在github上的账号名称。 本地环境搭建：切换ruby空间： 1gem sources --remove https://ruby.taobao.org/ 更新gem: 1sudo gem update --system 安装ruby 2.0 以上版本，查看ruby版本方式： 1ruby -v ruby 的管理工具： rvm安装2.1.4版本： 1rvm install 2.0.0 设置ruby 2.0.0 版本为默认版本： 1rvm use 2.0.0 --default 删除ruby1.9.x版本： 1rvm remove 1.9.x 删除本地用户目录下的ruby 运行方式一：直接使用jekyll：安装server： 1gem install -n /usr/local/bin/ jekyll 运行 jekyll : 1jekyll serve --safe --watch 运行方式二：使用bundle来运行jekyll：安装bundle： 1gem install -n /usr/local/bin/ bundle 在根目录下新建名为：Gemfile 的文件，内容为： 1source 'https://rubygems.org'gem 'github-pages' , group::jekyll_plugins 然后执行： 12bundle installbundle update 运行 jekyll : 1bundle exec jekyll serve 运行时出现端口异常： 1jekyll 3.4.3 | Error: Address already in use - bind(2) 解决方式： 1sudo lsof -wni tcp:4000 | awk '&#123;print $2&#125;'|xargs kill -9 模板选择：模板访问地址： http://jekyllthemes.org/， 选择合适的模板，Clone下来后，直接把模板中的内容拷贝到项目工程根目录中即可。 通过修改_config.yml 来配置博客内容； 域名绑定： 在工程根目录中新建文件CNAME，内容为新域名地址； 在github项目工程的setting中，找到Github Pages ,有一个Custom domain，填入你的域名； 或者通过你的域名管理，直接设置CNAME，指向 xxx.github.io; 运行时异常：一段时间后，出现一下错误： 1GitHub Metadata: No GitHub API authentication could be found 这是因为无法获取到Github的API授权信息，我们可以到https://github.com/settings/profile 中找到 Person access tokens , 生成一个public_repo权限的token。然后在个人本地的~.bash_profile中加入以下代码： 1export JEKYLL_GITHUB_TOKEN='xxxxx' 然后在你的启动脚本中加入（start.sh）： 123source ~/.bash_profileexport JEKYLL_GITHUB_TOKEN=$JEKYLL_GITHUB_TOKENnohup bundle exec jekyll serve &gt; nohup.out 2&gt;&amp;1 &amp; 注意：在运行了阿里郎的网络加速后，本地环境localhost:4000无法访问，必须关闭阿里郎网络加速； 参考：https://help.github.com/articles/setting-up-your-github-pages-site-locally-with-jekyll/","categories":[{"name":"Tool","slug":"Tool","permalink":"http://heartaway.cn/categories/Tool/"}],"tags":[]},{"title":"KeyCenter的作用与设计","slug":"Program/2017-03-16-keycenter","date":"2017-03-15T16:00:00.000Z","updated":"2018-11-09T14:27:10.313Z","comments":true,"path":"2017/03/16/Program/2017-03-16-keycenter/","link":"","permalink":"http://heartaway.cn/2017/03/16/Program/2017-03-16-keycenter/","excerpt":"","text":"在我们一般的系统交互中，对数据加密传输的场景必不可少，如果我们简单的把秘钥硬编码在代码中、放在配置文件中或者统一配置中心中，都不安全，很容易导致秘钥的泄露；那么有没有一个像保险柜一样的安全设备来帮我们出秘钥，并且提供明文加密和密文解密的功能呢？KenCenter应用而生。 KeyCenter中的运行方式：设计的领域模型：应用、秘钥、服务；（1）创建应用；用于空间隔离。（2）在应用下创建秘钥；算法支持对称加密（加密解密）、非对称加密（签名验签或RSA的加解密）、哈希类型（签名验签），我们在创建秘钥的时候，需要给这个秘钥起一个应用下唯一的别名，这个别名用于与秘钥进行关联，别名泄露并不会给系统带来风险；（3）我们可以使用KeyCenter提供的服务接口，对明文进行加密，或者对密文进行解密。 对称加密实例： 12String ciphertext/**密文**/ = cryptograph.encrypt(\"待加密的明文\", \"密钥别名\");String decryptedStr/**解密的明文**/ = cryptograph.decrypt(\"待解密的密文\", \"密钥别名\"); 加解密的过程就想到于我们把信息送到了一个不为外认知的情报局，这个情报局根据我指定的秘钥别名，进行数据加解密操作，具体的操作对外部完全是黑盒，没有外人能进入到者情报局，情报局里面的机密数据也是不允许从情报局中携带出来。 疑问：（1）我设置的秘钥，在KeyCenter中是如何存储的？如果是明文存储，那么能看到KeyCenter数据库的人就能获取到我们的秘钥信息了，KeyCenter的解决方案是先对密钥进行多重加密，然后存在数据库里；我们即使能看到数据库里的内容，看到的也只是加密后的秘钥，然后问题来了，在对密钥进行加密时，又需要另外的密钥。即使是多重加密，最终肯定还会存在一个根密钥（root key）。（2）根密钥怎么安全存放呢？有人拿到根密钥，不就可以将所有密钥解密出来吗？解决方案：加密机（或称为密码机），提供硬件级别的密钥管理和加密计算。 KeyCenter部署方式：目前面向业务系统的KeyCenter应用，采用的是中心化部署方式，没有进行单元化部署，原因是不希望密钥大规模同步到另外一个机房，增加安全风险，另外，keycenter之上还有一层物理加密机，这个只能中心部署。中心化部署的KeyCenter具有单点风险，其他单元访问KeyCenter这是跨单元访问，如果KeyCenter挂了怎么办？目前采用的容灾策略是，牺牲掉一定的安全性，把密钥缓存在业务系统内存中，只要业务系统不重启，密钥就不会丢失；这也给KeyCenter赢得了一定的故障恢复时间。 利用SSL-KeyCenter存储https的私钥信息明文在网络中裸奔的年代在组件过去，越来越多的企业接入HTTPS，让数据传输变得更安全。在HTTPS进行SSL的过程中，我们首先会使用非对称加密来传输客户端中的random随机数用于生成会话秘钥的一部分，服务端会保存私钥信息，如果私钥信息泄露，会给通信安全带来很大的威胁，所以很有必要保障私钥的安全；其次，如果一个集团中存在很多应用上了HTTPS，那么可信证书的私钥也就需要一个系统来进行统一管理，使用KeyCenter再合适不过了，但是在阿里内部，存储证书私钥的系统叫做SSL-KeyCenter，与解决业务密钥的KeyCenter是两个系统，我们很容易弄混淆。 测试发现，HTTPS的握手性能，很大程度消耗是在私钥使用的方面。具体的消耗，需要看加密套件的配置，对AES256-SHA256，这个比例在80%以上，而对ECDHE-AES256-SHA256，这个比例大约是40%。所以将其独立出来以后，单独在keycenter上使用SSL加速卡，大大提升了SSL加速卡的利用率，同时也大大提升了系统整体服务能力。 为了让证书的私钥等统一管理到SSL-KeyCenter中，并且提供证书整个生命周期的管理，我们还需要另外一个系统Subway来做这些事情。 subway的工作职责： 证书管理：证书的申请、有效期管理、配置、签发、证书私钥自动推送KeyCenter集群,部分证书可供下载、证书过期可自动触发替换； KeyCenter集群的管控； 对统一接入层的集群管控(如果存在)； 异地多活，SSL-KeyCenter部署策略由于KeyCenter中保存了证书的私钥、系统应用的密钥，如果KeyCenter挂了，那么首先通过HTTPS访问来的请求就无法正常解密客户端发来的密文，势必会带来网站的不可用，所以保证KeyCenter的高可用就变的至关重要。 在一些大型公司中，为了提高容灾能力，同城容灾，异地容灾，异地多活已经成为标配，那么KeyCenter会在各个单元机房中进行集群部署。 Keycenter容灾策略主要有以下两个点： 对外部请求而言，可以把Keycenter自身使用域名在ADNS上执行流量调度切换； 对生产网而言，只允许访问同一IDC内Keycenter集群的内部VIP，不产生跨机房调用，如果某一个IDC出现故障，只需要切走Aserver流量即可。 SSL-KeyCenter在阿里的单个IDC中的部署结构： SSL-KeyCenter在多机房下的部署：IDC1中访问KeyCenter目前只能在机房内访问，不能跨机房调用，当IDC1中的KeyCenter全部挂了，则直接从统一接入层中切走整个机房的流量。疑问：那为什么KeyCenter为什么不能像一般App那样，单机房内服务不可用时，允许跨机房调用呢？原因：没时间实现，后续会通过VIPServer来动态获取服务机器列表，这样如果单元内服务不可用，就可以允许跨单元调用了。 备注：文章中部分内容非原创，整理资源来源于ATA。","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"制作符合Mail格式的HTML","slug":"Basic/2017-03-14-mail-html","date":"2017-03-13T16:00:00.000Z","updated":"2018-11-09T14:17:04.719Z","comments":true,"path":"2017/03/14/Basic/2017-03-14-mail-html/","link":"","permalink":"http://heartaway.cn/2017/03/14/Basic/2017-03-14-mail-html/","excerpt":"","text":"我们在做报表类方案的时，我们通过web页面进行了数据展示，此时期望能够把这个网页通过邮件客户端发送到用户邮箱中，如果我们为了保持页面和邮件内的样式的统一，就很期望做到页面内容的复用，不再为邮件内容单独制定一套模板，当用户的内容样式谁内容而不同时，无法通过单一的模板来解决，是否可以通过复用页面的html内容来达到目的呢？ 比如我们的页面结构是模块化的，每一个模块内的内容可能都随着模块的不同而呈现出不同的样式，如下图：http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/85c79200d05ddb180dbb9c9e13d4faa7.png 如果我们让用户一键拷贝内容，在一键发送邮件，既可以做到页面内容的复用，也可以简化用户复制粘贴以及启动邮件客户端的繁琐任务。 问题来了，在我们实践过程中，为了支持足够美观的模块，使用了CSS3、HTML5等一些新特性，但是在内容复制到邮件客户端进行发送后，收到的邮件随着客户端的不同而呈现出不同的样式（当然，是样式错乱），这里面发生了什么呢？ 经过查询一番资料，发现，不同的邮件客户端有不同的HTML过滤规则，我们需要遵循HTML Email规范。 html email基本原则： 只能从外部引用图片，没有外部样式表，字体，视频（html5开始改变这一点）等。 在电子邮件客户端（电子邮件客户端=为Outlook，Gmail，Hotmail，Yahoo等）中对CSS元素的支持有限。 您可以查看一个对比表格，什么客户端支持什么的样式功能。 表格最常用于布局html电子邮件。 测试，你需要测试你的邮件在不同的电子邮件客户端下。 html email 文档类型申明：目前，兼容性最好的Doctype是XHTML 1.0 Strict，事实上Gmail和Hotmail会删掉你的Doctype，换上这个Doctype。 12345678&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;title&gt;HTML Email编写指南&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt; &lt;/head&gt;&lt;/html&gt; 使用table代替css布局由于电子邮件无法支持标准，是不可使用div、section或article——替代的是使用table。此外，你需要使用大量的表格嵌套，因为HTML电子邮件既不支持colspan和rowspan属性。 这是多个table容器，并且使用嵌套table格式。我们一般会在最外面设置一个table（#backgroundTable），充当排序的容器 ，它指定了电子邮件客户端中的可见空间的宽度。因为一些客户端任意地限制区域呈现 ，不设置可能导致奇怪对齐的内容。然后我们再在内部设置一个table，用来作为真正内容的容器，第二个table最好设置一定的宽度，防止超过客户端的显示宽度。 123456789&lt;table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"margin:0; padding:0; width:100% !important; line-height: 100% !important;\"&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;table align=\"center\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\" width=\"600\" style=\"border-collapse: collapse;\"&gt; &lt;tr&gt;&lt;td&gt;邮件内容&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;td&gt; &lt;/tr&gt;&lt;/table&gt; 第一个table设置的样式表有助于重置某些电子邮件客户端特定的格式。 table自适应？table 在 bootstrap panel中无法宽度自适应，解决办法是使用固定表格：table-layout:fixed; Max-Width都支持？并不是所有邮箱客户端都支持max-width。为了让邮件兼容Outlook和Lotus Notes 8 &amp; 8.5，我们要把每个table放在条件语句里，这样就会有一个固定宽度table。这种方法针对IE（Lotus Notes使用IE内核）和Microsoft Outlook。 1234567891011121314151617&lt;!--[if (gte mso 9)|(IE)]&gt;&lt;table width=\"600\" align=\"center\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr&gt; &lt;td&gt; &lt;![endif]--&gt; &lt;table class=\"content\" align=\"center\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr&gt; &lt;td&gt; Hello! &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!--[if (gte mso 9)|(IE)]&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;![endif]--&gt; 奇怪的是，苹果邮箱客户端（通常非常先进）也不支持max-width属性。但它支持media queries，所以只要viewport是600px宽的屏幕，我们可以在’content’样式里添加固定宽度。 12345&lt;style type=\"text/css\"&gt;@media only screen and (min-device-width: 601px) &#123;.content &#123;width: 600px !important;&#125;&#125;&lt;/style&gt; 多列布局：我们在进行多列布局的时候，不能把列宽度给占满了，需要预留一定的空间，比较好的实践是：预留25px的空间来防止Outlook堆叠你的table。因为Outlook会在边框宽度上占用一定的宽度。如何达到预留空间的方式呢？通过使用table的align属性实现。 使用表格代替段落同样，由于缺乏对标准的支持，使用标准的标签，如h1,h2,h3或p并不是一个好主意。我发现这些渲染在电子邮件客户端存在相当大的麻烦。你最好选择将每一块文本放在息的单元格中，并且将行内样式应用于这个单元格。 CSS行内样式代替样式表所有的CSS规则，最好都采用行内样式。因为放置在网页头部的样式，很可能会被客户端删除。客户端对CSS规则的支持情况，请看这里，可以看到很多css的伪标签都是不被支持的。不要忘记：你不能将多个类应用于HTML电子邮件，因为它不支持的这些。每个元素最多可以有一个类。 也不要忘记：你不能用简短的样式缩写如font-size（例如：style=”font:8px/14px Arial,sans-serif”），因为HTML电子邮件不支持它，你需要展开单独写，margin也不例外。 简化开发框架：我们可以参考 https://github.com/seanpowell/Email-Boilerplate 这里的要求，然后填充我们自由的邮件。https://webdesign.tutsplus.com/articles/build-an-html-email-template-from-scratch--webdesign-12770 这里给出了我们如何使用table一步一步创建出期望的HTML Email，以供参考。 参考：http://www.ruanyifeng.com/blog/2013/06/html_email.htmlhttp://www.campaignmonitor.com/blog/post/3317/correct-doctype-to-use-in-html-email/http://articles.sitepoint.com/article/code-html-email-newslettershttp://dennisdeacon.wordpress.com/2008/06/09/top-10-email-best-practices/http://www.catswhocode.com/blog/best-practices-for-coding-html-emailshttps://webdesign.tutsplus.com/zh-hans/articles/creating-a-simple-responsive-html-email--webdesign-12978https://webdesign.tutsplus.com/articles/build-an-html-email-template-from-scratch--webdesign-12770","categories":[{"name":"Basic","slug":"Basic","permalink":"http://heartaway.cn/categories/Basic/"}],"tags":[]},{"title":"GIT本地仓库与远程仓库","slug":"Tool/2017-02-27-git-repo","date":"2017-02-26T16:00:00.000Z","updated":"2018-11-09T14:31:13.361Z","comments":true,"path":"2017/02/27/Tool/2017-02-27-git-repo/","link":"","permalink":"http://heartaway.cn/2017/02/27/Tool/2017-02-27-git-repo/","excerpt":"","text":"很多初学GIT的同学对GIT的本地仓库和远程仓库无法做到很好的区分，我就画了一张图，来阐明他们之间的关系： Git stash 的使用：我们在多分支操作时，暂存工作区中未提交的代码的功能非常有用。一般我们要求commit的代码都是功能完善的，可测试的，但是很多时候，我们的代码片段还未写完，需要临时切出一个分支来解决线上问题，此时就应该使用git stash功能； git stash 是全局储藏区，不同的分支下的stash操作都会到同一个储藏区。 默认名称储藏工作区：1git stash 按照指定储藏名称储藏工作区：1git stash save \"commit info\" 查看历史储藏区列表：1git stash list 恢复储藏区的某操作到当前分支： 方式一： 1git stash pop 此方式直接从储藏区堆栈中的栈顶弹出最近的一次stash操作的内容，并删除堆栈中的当前stash操作记录； 方式二： 1git stash apply stash@&#123;0&#125; 通过指定使用储藏区记录的名称来恢复stash的内容，stash@{n} 具体值可以从git stash list中查看，当然，直接使用git stash apply ，默认指向栈顶记录（stash@{0}永远指向栈顶）。 apply只是应用储藏区的一个记录到当前工作区，并不会删除储藏区的记录。 删除储藏区某一记录：1git stash drop stash@&#123;0&#125; git stash drop默认的也是从栈顶开始删除，通过drop 后加名称可以指定删除的储藏记录。 从stash中创建分支：1git stash branch branch-name","categories":[{"name":"Tool","slug":"Tool","permalink":"http://heartaway.cn/categories/Tool/"}],"tags":[]},{"title":"看见自己的成长","slug":"Think/2017-02-27-see-your-grow-up","date":"2017-02-26T16:00:00.000Z","updated":"2018-11-09T14:29:29.036Z","comments":true,"path":"2017/02/27/Think/2017-02-27-see-your-grow-up/","link":"","permalink":"http://heartaway.cn/2017/02/27/Think/2017-02-27-see-your-grow-up/","excerpt":"","text":"时光飞逝，光阴荏苒，似水流年的岁月一去不复返，工作四年多的时光犹如白驹过隙。回顾这四年的路程，有过为焦虑而做的职业改变，有过为梦想的拼搏，也有经历暴风雨后的顿悟和反思。经过四年时间的磨砺，我变得成熟、自知，习惯性的自省和逐渐培养的自律，让我从随波逐流的少年成长为了拥有个体思想的青年。 这些年来，自己一直期望能够快速成长，这个速度能与时代的发展速度相差不大，让自己跟得上时代，不被时代说抛弃，但是我们正处于一个超乎想象速度发展的世界，我们有些赶不上了，反思后发现亚马逊创始人贝索斯说的“我们必须把自己的精力，投入在那些长期不变的东西上面。”才是真理。在很长一段时间，我过度为沉没的两年创业时光而焦虑，在外界认为，这两年，我的技术水准没有得到质的变化，只是从一个新手成为了熟练工，而同期优秀的同学已经成长为了领域专家，伴随着年龄的上涨，个人竞争力在逐年下降；后来，我想通了，一个人的任何以认真态度度过的时间都不存在浪费，谁又知道这些积累会不会在以后的工作生活中发挥一定的作用呢，认清自己的短板，知道自己为了应对中年危机需要做什么，放弃什么才是关键。所谓成长，不一定要与那些牛人相比，而是今天的自己比强，找到一条适合自己的道路，一步一个台阶，向上走，努力的人运气总不会太差。 寻求改变2011年9月，能进入阿里作为实习生，一直是我的骄傲；我自知不是一个聪明的人，个人专业积累有限，学校二流，能有这样的机会我倍加珍惜，面对惨烈的实习生转正压力，我凭借自己的努力和勤奋通过了转正面试，虽然只是作为测试，但是心满意足。 在测试岗位上，我学会了CI和CD，并在团队中分别基于自建环境和TOAST环境进行CI的实践；除此之外，我也开始培养自己对产品的关注，如何设计一个用户体验优良的产品，为TAE的工作台提出了不少易用性的改进点。在测试岗位上我还有一个习惯，就是每天会去阅读国内外一些测试网站的信息，随着信息面的扩大，越来越为个人的职业前途担忧，测试岗会不会被替代掉，会不会走到职业瓶颈，这些问题成为我下定决心进行技术积累，为日后转岗研发做准备。所以，在测试岗的一年半时间里面，我再让自己首先成为优秀的测试的同时，注重基础知识的学习，在TAE团队里面，我基本承担起了所有的质量把控工作，并能为研发的提效进行一系列的工具研发支撑。 2014年4月，我通过了内部转岗面试，正式成为了一名研发人员，凭借在测试岗上学习的移动端研发技术和Java知识，我开始在团队里面负责移动端的产品研发和TAE测试平台的研发工作，这段工作虽然时间不是太长，但是我收获了作为研发的正规军该如何正确的做项目。 为梦起航2014年9月，我遇到了一次艰难的抉择，是继续留在阿里呢还是离职创业，在经历了无数次思考后，我听从了内心的声音，选择去创业。虽然放弃阿里稳定的工作，很多人认为，低风险的事情才是稳定的，但讽刺的是，在瞬息万变的当今社会，寻求稳定反倒是有可能是最大的冒险。 王安石说：世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。所以要去加倍努力，不是为了换取成功，不是为了去超越别人，而是一种想去体验更大世界的欲望。本着这样的想法，我离开了阿里，背井离乡，去了上海；在2014年，伴随着国内万众创业、人口红利、消费升级等诸多利好因素，‘跨境电商’可以说是风口上的猪，顺丰集团天使投资6000W的‘顺丰海淘’就这样在我们这样一群年轻人的努力下上线了。可谁知道，我们十几个人在短短3个月的时间内，不断试错，不断推翻，做了三个大版本出来呢，从C2C做到买手制平台模式，再到B2C与商家代发结合的混合平台模式。 在海淘初期，我们的技术架构就已经参考淘宝做了业务和存储的垂直划分，一下子每个人要负责好几个系统，这也给了我很好的练手机会，我基于阿里云OpenSearch构建了第一代商品搜索系统，做了订单的核心研发，知道了分布式事务的重要性，做商品系统，知道了商品库、类目体系构建、页面静态化、数据的多级缓存，做了SCM后台，创新的使用了Groovy+裸SQL模式10分钟内上线一个后台增删改查功能，也知道了日志的分类处理和操作日志的审计功能；供应链作为海淘最重要的基础体系，我们从零来时搭建，从不知道什么叫供应链做到研发的供应链金融平台可以对外服务。这段长达一年多的时间，高强度的工作让我成为了一名程序熟练工。 在顺丰海淘的2年时间，如果说只专注在技术领域，那就太浪费资源了，能经历一个公司从0到1的过程很难得，我需要学习一个公司是如何定战略目标，如何进行市场精品分析，如何进行市场定位，如何进行商业决策，如何构建企业文化，如何进行人才梯队培养。为此，我们还组织了每周一次研发周会与CEO面对面交流企业面对市场的一些列问题，每次我提出的一系列问题都会为大家揭开一个有一个疑问，面对商业之美，我们显得如此无知。正是这种面对巨大无知引发的好奇心，让一个程序员，不仅只会编码，尝试去学习什么是商业的本质。 对于一个技术人员来说，前几年最重要的是让自己成为一个专业的人，正如大前研一先生的《专业主义》一书中观点：保持好奇心，不断学习，让自己成为一个专业的人。不禁，我开始反问自己，我是否是一个合格的程序员，自己的短板是什么，要让自己成为一个专业的人，我需要怎么努力。所以，我开始尝试跳出之前的舒适区，开始尝试不同业务带来的挑战，不幸的是，我的动作还是太慢。我发现期望在创业公司一线进行技术磨练变得不靠谱，做不完的业务会让你无暇顾及技术深度的积累。不幸的是企业发展过程中，因为过度依赖补贴来获取用户已达到用户规模，最终导致资金链几乎断裂，整个研发团队瓦解。我开始重新面对市场竞争，重新衡量个人价值，发现自己陷入了以己之短参与竞争的困境，如果在这样下去两年，可能会毁了自己的职业生涯，这种危机感时时刻刻提醒着我需要静下心来，找到一个比我优秀的环境，放下浮躁，沉到土里，去做真正对企业和个人有价值的事情。自己有什么，要什么，放弃什么，我认为我想清楚了，需要做的就是实践。 脚踏实地选择重新回到阿里，其实原因很简单，阿里的舞台和技术氛围正是我目前最需要的，不为别的，只为让自己成为一个专业的程序员。就像叔同说的，我有短板，别人也在进步，我必须比别人付出的更多才可以赶上别人；不要在该努力的时候为了一些短期利益而忽视了自我的成长，此时我自己的成长才是最重要的，别的都是其次，最好的投资是投资自己的大脑。 在回到阿里的这几个月，我主要是在看和学习，这期间老板给了我很多指导，让我受益匪浅。我知道了不要过早的否定自己，很多事情，不是不可能，而是因为我们认为不可能而失去了可能的因素，只有自己尝试了，努力了，再去下结论；我知道了什么是全局思维，怎么去培养自己的全局思维，这里的全局包括技术、团队、业务等等，不要把自己只是局限在TITLE上的工作范畴，跳出来，我们可以看到更大的一个世界；我知道了如何让自己能够有独立的思考能力，任何事情只有自己思考过了才是自己的，不人云亦云，不盲目迷信权威；我知道了如何培养自己做事的方式，建立自己的方法论；我知道了该如何逐步弥补技术债，技术的积累没有捷径，各个击破，多思考，多沉淀，多总结；当然，整个技术团队值得我学习的人和事还很多，保持空杯心态，不骄不躁，脚踏实地，一步一个脚印向目标并进。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"ThreadLocal 原理探究","slug":"Java/2017-02-16-threadlocal","date":"2017-02-15T16:00:00.000Z","updated":"2018-11-09T14:23:10.183Z","comments":true,"path":"2017/02/16/Java/2017-02-16-threadlocal/","link":"","permalink":"http://heartaway.cn/2017/02/16/Java/2017-02-16-threadlocal/","excerpt":"","text":"ThreadLocal 的作用：This class provides thread-local variables. 提供了线程级别的本地变量。 ThreadLocal的原理： 每一个线程Thread内部维护了两个package private级别的变量： ThreadLocal.ThreadLocalMap threadLocals ThreadLocal.ThreadLocalMap inheritableThreadLocals 每一个 ThreadLocal 对象有一个创建时生成唯一的 Id称为：threadLocalHashCode，访问一个 ThreadLocal 变量的值，就是用threadLocalHashCode去 本线程 的 ThreadLocalMap 中查找对应的值。 123456789private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; ThreadLocalMap 为一个静态内部类，包含了一个Entity数组（Entry[] table）来保持ThreadLocal的线程变量； ThreadLocalMap的原理 ThreadLocalMap是一个Hash Map，采用的是开放地址法而不是链表的方式解决冲突。 Entry 是 WeakReference 的子类，这样不再被使用的 ThreadLocal 可以被检查出来并清除掉。 线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。 123456ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 神奇的 0x61c88647待补充； 使用陷阱： ThreadLocal和线程池同时使用出现变量污染； 在使用线程池的过程中，由于线程是不断的回收和利用故ThreadLocal在服务器中也是被反复利用的，在使用中如果不进行清查操作，很容易导致变量污染。 问题：疑惑1：既然ThreadLocal只维护一个值，每一个Thread中都存储的是一个副本，为什么ThreadLocalMap需要时一个数组而不是object呢？ 原因： 如果我们期望在一个Thread中存储多个ThreadLocal变量怎么办呢？不可能改造Thread，新增一个Object对象吧，所以为了更方便的在同一个Thread中加入多个ThreadLocal变量，才引入了数组结构，不同的ThreadLocal对象作为不同键，所以在线程的ThreadLocalMap对象中设置不同的值。 疑惑2：ThreadLocalMap为什么采用开放地址的方法，而不采用链表来防止hash冲突？ 答：待补充 扩张阅读：http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"MapStruct 代替BeanUtil 和ModelMapper","slug":"Java/2017-02-15-object-mapping","date":"2017-02-14T16:00:00.000Z","updated":"2018-11-09T14:23:04.697Z","comments":true,"path":"2017/02/15/Java/2017-02-15-object-mapping/","link":"","permalink":"http://heartaway.cn/2017/02/15/Java/2017-02-15-object-mapping/","excerpt":"","text":"Object mapping 的技术分类： 运行期 反射调用set/get 或者是直接对成员变量赋值 。 该方式通过invoke执行赋值，实现时一般会采用beanutil, Javassist等开源库。这类的代表：Dozer,ModelMaper 编译期 动态生成set/get代码的class文件 ，在运行时直接调用该class文件。该方式实际上扔会存在set/get代码，只是不需要自己写了。 这类的代表：MapStruct,Selma,Orika主要框架性能对比：每秒钟执行的object mapping越多越好。明显可以看出通过在运行期进行反射的方式执行，性能远不如编译器生成class的方式； MapStruct 与 Selma的对比：https://java.libhunt.com/project/mapstruct/vs/selmaMapStruct 与 ModelMapper的对比：https://java.libhunt.com/project/mapstruct/vs/modelmapper 综合比较性能、问题排查、文档、成熟度、扩展性等因素来考虑，MapStruct 是一个不错的选择； Maven依赖：1234&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;org.mapstruct.version&gt;1.1.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;java.encoding&#125;&lt;/encoding&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/plugin&gt; MapStruct的基本使用：1234567@Mapper(componentModel = \"spring\")public interface MonitorAppGroupIdcDTOMapper &#123; MonitorAppGroupIdcDTOMapper MAPPER = Mappers.getMapper(MonitorAppGroupIdcDTOMapper.class); void mapping(MonitorAppGroupIdcDTO source, @MappingTarget MonitorAppGroupIdcDTO dest);&#125; 编译后生成的部分代码结构： 12345678910111213 @Componentpublic class MonitorAppGroupIdcDTOMapperImpl implements MonitorAppGroupIdcDTOMapper &#123; public MonitorAppGroupIdcDTOMapperImpl() &#123; &#125; public void mapping(MonitorAppGroupIdcDTO source, MonitorAppGroupIdcDTO dest) &#123; if(source != null) &#123; dest.setId(source.getId()); dest.setGmtCreate(source.getGmtCreate()); ... &#125; &#125;&#125; 可以看出MapStruct还需要依赖对象的get/set方法，有时候编写一堆的get/set方法看上去很不美观，期望能通过自动生成的方式插入get/set方法，其解决方案是使用lombok。mapstrcut官网也有二者结合的例子：https://github.com/mapstruct/mapstruct/issues/510。Lombok 带来的问题是，如果我们期望通过公有的get/set方法范围私有属性时，IDE会提示方法不存在，这个时候我们可以下载安装Intellij Idea中的”Lombok plugin”来解决，但是这种方案带来了一定的繁琐性。比较好的方式是，对于DO或者DTO中的属性，如果属性为私有属性，需要通过get/set方法来访问的，那么就手工生成get/set方法，如果属性本身为共有属性的，那么就可以借助Lombok来自动生成get/set方法了。 MapStruct的属性与方法：1. @Mapper注解的componentModel属性componentModel属性用于指定自动生成的接口实现类的组件类型。这个属性支持四个值： default: 这是默认的情况，mapstruct不使用任何组件类型, 可以通过Mappers.getMapper(Class)方式获取自动生成的实例对象。 cdi: the generated mapper is an application-scoped CDI bean and can be retrieved via @Inject spring: 生成的实现类上面会自动添加一个@Component注解，可以通过Spring的 @Autowired方式进行注入 jsr330: 生成的实现类上会添加@javax.inject.Named 和@Singleton注解，可以通过 @Inject注解获取。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"我对负载均衡演变过程的理解","slug":"Middleware/2017-02-10-lsv-change-road","date":"2017-02-09T16:00:00.000Z","updated":"2018-11-09T14:24:54.677Z","comments":true,"path":"2017/02/10/Middleware/2017-02-10-lsv-change-road/","link":"","permalink":"http://heartaway.cn/2017/02/10/Middleware/2017-02-10-lsv-change-road/","excerpt":"","text":"之前看到SLB、VIP、LVS、VIPServer这些很相近的名词总不能很好的进行区分，不知道这些在负载均衡领域具体的使用场景，我期望通过这篇文章，帮大家梳理一下这些名词的区别。我们从一个域名的访问开始，挖掘一下我们的访问链路上到底出现了什么，如果业务更复杂，我们的系统改怎么演变。 域名解析：我们在命令行模式下ping一个域名：popcorn.alibaba-inc.com 返回的IP是140.205.247.101，在PSP上查询此IP，得到： 可以看到，我们拿到的是LVS的机器，也就是说，域名绑定的机器IP是我们应用专属的LVS的IP地址（DNS域名解析服务）。 对这部分不理解的，可以去尝试使用阿里云服务中的域名服务，申请一个域名，然后进行域名解析服务： 负载均衡演化DNS负载均衡一个域名，我们可以添加多个A记录，绑定后端多台服务器（如果没有SLB的话），这样我们可以利用DNS的负载均衡帮我们实现服务器断的负载均衡。在无负载均衡的权威 DNS 中，Local DNS 访问权威 DNS，权威 DNS 会将这 绑定的多个解析记录全部返回给 Local DNS， Local DNS 会将所有的 IP 地址返回给网站访问者，网站访问者的浏览器会随机访问其中一个 IP。而在有负载均衡的权威 DNS 中，网站访问者的请求到来时，权威 DNS 会根据解析记录的权重轮询 全部 A 记录(默认权重 1:1:1)，依次返回 3 个 IP 地址，每次返回一个IP地址；当然用户可以在这里修改A记录的权重值。我们的网站架构可能是这个样子： 使用DNS负载均衡的问题是一般DNS解析都会有TTL(TTL指各地DNS缓存您域名记录信息的时间),当后端某个服务器挂掉的时候，由于TTL的缓存得不到及时清除，所以会让部分流量进入到已经宕掉的机器上，造成一定的损失。所以，这个时候，我们最好引入相比于后端应用更加稳定、相比于DNS负载均衡更加灵活的负载均衡器，前置在我们的链路中，比如LVS、F5或者Nginx。 引入官方LVS负载均衡引入官方LVS负载均衡后，我们的应用架构可能是这样子的： 我们采用官方的LVS作为软负载，并通过主备的方式达到LVS的容灾策略，LVS与Real Server之间通过heartbeat方式进行健康检查，LVS主备间通过KeepAlived进行状态检测；通过LVS，当我们Real Server 集群有机器上下线时，就不需要与DNS打交道了，只需要与LVS交互，并且LVS本身可具备对RealServer的健康检查，让我们的服务上下线变得更加容易和简单，并且我们可以在LVS中自定义相比于DNS更丰富的负载均衡策略；这种架构中，同一时刻只有一台LVS对外提供服务，另外一台一直处于stand by 状态，直到提供服务LVS的挂了。在LVS中配置了Real Server的真实IP地址，用于健康检查和负载均衡，在Real Server中配置了Virtual IP地址，用于组件Virtual Server环境（LVS + Real Server统称为Virtual Server）。我们可以看到Virtual IP 并不像内网或者外网IP那样绑定上去后就固定唯一了，Virtual IP 我们是可以绑定到多台机器上。即使我们LVS采用了主备模式，单点提供服务的LVS还是可能会成为性能瓶颈，无法进行横向扩张，其次，官方LVS缺乏攻击防御功能，在转发模式上，只支持NAT/DR/TUNNEL 三种，在多VLAN 网络环境下部署成本极高。那么如何解决这些问题呢？阿里的负载均衡设备在官方 LVS 基础上进行了定制化和优化，比如LVS采用集群方式部署，增加攻击防御模块，新增转发模式 FULLNAT，实现 LVS-RealServer 间跨 VLAN 通讯等；Ali-LVS 的开源地址： https://github.com/alibaba/LVS虚拟IP和IP漂移：http://xiaobaoqiu.github.io/blog/2015/04/02/xu-ni-iphe-ippiao-yi/ 引入Ali-LVS改进版负载均衡当引入了Ali-LVS后，我们的架构变成了如下结构：我们的LVS变成了集群模式，那么就需要我们感知LVS集群中的机器服务状态并能自动进行健康检查，LVS本身也需要负载均衡；这个时候就需要引入另外一个硬件设备了-交换机，LVS和交换机间运行OSPF心跳，1个VIP（Virtual IP）配置在集群的所有LVS上，ECMP负责将数据流分发给LVS集群，当一台LVS宕机后，交换机会自动发现并将其从ECMP等价路由中剔除。外部流量到了交换机后下一步具体走哪条路径是在交换机上配置不同的hash策略控制的，一般是源IP+源端口。 从4层负载到7层负载当然，这种架构已经能解决我们大部分问题了，但是LVS是在四层协议上实现的负载均衡，我们有一些业务需要SLB实例服务端口使用的是7层HTTP协议，怎么办呢？我们可以引入Tengine，Tengine是当前最流行的7层负载均衡开源软件之一，且已经开源，那么我们的架构可能会演变成以下这个样子：客户端访问SLB实例VIP时，相关请求由SLB实例对应的LVS集群处理，如果相应的SLB实例服务端口使用的是4层协议（TCP或UDP），那么LVS集群内每个节点都会根据SLB实例负载均衡策略，将其承载的服务请求按策略直接分发到后端Real Server服务器，并同时维护会话保持等特性；如果相应的SLB实例服务端口使用的是7层HTTP协议，那么LVS集群内每个节点会先将其承载的服务请求均分到Tengine集群；而后，Tengine集群内的每个节点再根据SLB实例负载均衡策略，将服务请求按策略最终分发到后端Real Server服务器，并同时维护会话保持等特性。 针对LVS的工作原理可以参考：LVS基础 、LVS及相关网络概念 或 负载均衡（SLB）技术原理浅析 从公网访问负载到内部访问负载我们通过LVS集群和Tengine集群解决了公网到阿里内部应用的负载均衡，随着阿里内部很多应用的集群逐渐扩大，这些应用在被访问的时候也是需要被进行负载均衡（我们默认已包含状态检查模块）的，那么我们把应用访问方式大致分为两类，一类是基于HSF的RPC远程服务调用，另外一种是基于HTTP的服务调用；基于HSF的服务调用的负载均衡是由ConfigServer完成，这部分可以参考ConfigServer的实现；基于HTTP的负载均衡是VIPServer，通过VIPServer，我们内部应用通过域名范围内部应用时，就没有必要重新走一遍公网的DNS解析，链路顶端的各种负载均衡了，通过VIPServer，我们可以与内部应用进行直连，相当于对我们的访问链路进行了优化和加速，当然，VIPServer在对HTTP的内部调用上除了可以做负载均衡、健康检查外，还做了异地容灾的调用实现、流量的控制、环境管理、灰度的发布等，有关VIPServer的功能可以参考VIPServer的功能介绍。那么，在引入这两个设备后，我们的应用架构可能会演变成这个样子： 参考： https://xue.alibaba-inc.com/trs/doc/learningDocDetail.htm?spm=a1z2e.8101737.list.8.aRav7f&amp;docUid=770f4104-0d89-4a5f-8237-f112c61fb006http://www.atatech.org/articles/50329","categories":[{"name":"Middleware","slug":"Middleware","permalink":"http://heartaway.cn/categories/Middleware/"}],"tags":[]},{"title":"追求精致生活","slug":"Think/2017-01-02-good-life","date":"2017-01-01T16:00:00.000Z","updated":"2018-11-09T14:29:35.443Z","comments":true,"path":"2017/01/02/Think/2017-01-02-good-life/","link":"","permalink":"http://heartaway.cn/2017/01/02/Think/2017-01-02-good-life/","excerpt":"","text":"精致生活与金钱无关，避免懒惰，加强自律，拜托穷人思维，提升品质，体面生活。 我想每个人都期望自己的生活变得越来越美好，没人喜欢脏乱差，但是在追求美好的实物上，我们是否花心思像经营爱情那样经营生活和家庭了呢？精致生活并不是花钱买来的，而是用心经营出来的。在追求精致生活的方向上有一些思维误区和方法，分享给大家，同样也告诫自己。 精致生活与财富关系不大。富有的人也存在每天蓬头垢面的生活，贫穷的人也有花园般的世界。就像罗胖在2016年的跨年演讲中提到的，他有幸去参观了一二十家千万富翁的家，发现这些有钱人，很多都不懂精致生活，快中午了，都还各个蓬头垢面，室内乱乱糟糟，这些场景让他感触很大，他认为那些人是因为对生活的懒惰导致了生活的低质。想过的更好，跟外界一点关系都没有。 吴晓波出过一本书叫做《把生命浪费在美好的事物上》，值得大家一看。期望追求精致的生活，首先需要我们是一个不懒惰而又自律的人，你能像罗胖那样坚持每天六点二十发一段语音吗？至少我是做不到的。怎么让自己的生活变得紧致？有很多办法，且不需要怎么花钱，比如保持规律的饮食起居，每天洗澡，勤换衣服，保持居室整洁干净，种植花草，使用艺术品替换掉结婚照，购买具有一定设计感且价格合理的商品。 定期丢掉不需要且落时东西，可以提高我们的生活品质。 在我的家庭中，想做到这一点比较困难，我现在还能从我家里找到我和我姐姐一岁到二十几岁的衣物和鞋子，我以前认为父母之所有还把这些不再需要的东西留着，是为了怀念，或者是想给下一代人继续使用，但是现在明白了，有些东西他们也知道不会再使用了，但是就是舍不得扔掉，因为他们是从哪个物质多么匮乏的年代走过来的，他们不舍得。其实，在他们的影响下，我也是这样的一个人，在杭州和上海的几次搬家中，卡车都是拉的满满的，每次走，都把房间里的东西收拾的干干净净，什么都不舍得扔；有时候，在外面捡到一些小螺钉、绳子或者觉得可能用得着的东西都会捡回来当宝一样藏在家中，为此，媳妇说了我多次，说我是个“破烂君”。 今天虽然是周末，我比平时上班起来的都早，洗漱后，开始打扫整理房间，丢掉了不少以前不舍得丢又用不着的东西，然后收拾自己的行头，看到整洁的家和还不错的自己，顿时感觉生活变得美好了一些。 精神作了乞丐，有金钱也只能乞讨。 有人有钱了，却永远过的是穷日子。 我小时候，家里比较穷，不仅自己穷，连一圈的亲戚都穷，穷到买一包盐都要借钱，没错，很多人觉得不可思议，但是这真真实实的发生在我舅舅家庭中。我上小学和初中，不知道什么叫零花钱，炎炎夏日，看到别人每天能花一毛钱买一个冰袋吃，自己就跟着别人屁股后面，想办法套近乎称哥们，好让人家分我一块冰，有时候也会偷偷的从家里偷出一毛钱，像大款一般买一个冰袋，幸福的吮吸起来，有时候看到快没了的时候，还会去接一点自来水灌进去继续吸，喝完了，从咬开的小口处吹气进去，然后旋转拧好开口，放在地上，一脚下去，“啪”的一声，甭提多开心。当时的梦想就是以后每天有一个冰袋吃，就这么简单。 虽然后来日子越来越好，因贫穷而需要的节省就像肿瘤一样，在身体里面根深蒂固，因为那样的环境，让我们脆弱的神经实时陷在一种恐惧中：怕没钱，更怕回到以前的生活。包括我参加工作后的这几年，一旦手上没钱，就感觉生活没有了保障，那种不安全感有时候压的人喘不过气。不过在我媳妇的多次教导下，我逐渐在改变自己的思维，改变对钱的态度。今年为了买车，做了贷款，每个月的工资80%都会用来还贷款，如果还是以前的我，这点完全是不能接受的，怎么可以每个月没有结余呢，生活怎么过。在这里我需要感谢我媳妇，如果我找一个跟我一样用钱观的人共度一生，可能就会失去生活中一些更加美好的东西了；她帮助我看到了，除了钱，生活还可以更好，更精致。有钱不难，难的是拆掉思维禁锢的墙。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"创业，离别","slug":"Think/2016-08-19-leave-entrepreneurship","date":"2016-08-18T16:00:00.000Z","updated":"2018-11-09T14:29:42.900Z","comments":true,"path":"2016/08/19/Think/2016-08-19-leave-entrepreneurship/","link":"","permalink":"http://heartaway.cn/2016/08/19/Think/2016-08-19-leave-entrepreneurship/","excerpt":"","text":"今天2016年8月19号，我结束了为期657天的上海创业旅程，但今后无论在什么环境从事什么岗位，我的创业心态不会变。这次的离别没有来时的兴奋与激动，也没有不解和埋怨，一切都显得那么平静，宛如无风的湖面。也许是我该反思的都反思过了，也许是经过了阅历而让自己有所成长。依稀记得上一次因离职的呈现出悲情满面的场景，凄凄地写下了离别书以慰藉我视如珍贵的友情，现在看来当初略显稚嫩，但一切都是真实情感的表露，也许是我因为多情，有道是“多情自古伤离别”；而如今，没有了这种眷恋之意，经历了创业的风风雨雨，让我的生活变得略显粗糙和沧桑，不过能遇到一对不多的朋友，为真正梦想无私付出的人，还是挺值得敬佩的。 如果说上一次的选择创业是主动选择，听从内心的声音，而这次选择夹杂着些许被动与无奈，当然也有理智思考后的坚定抉择，经过了长达一个多月的思考之后，我越发的明白了自己是一个什么样的人，当前应该干什么事情。原来没有我想想那么不可或缺，在别人眼中只是一个工具，但是这个工具又不是那么好使，时常还容易夹手；做一个工具没问题，但是首先要让自己成为一个好用安全的工具，其次，让自己成为一个智能工具，这才是正确的道路，而不是不断的把这个工具换到不同的新地方，让没见过这个工具的人觉得，哇哦，还有这么好用的工具。其实这个世界上很多事情你都是无法左右的，我们唯有改变我们自己，自主的寻求方向尽可能的让自己少走弯路，而不是依赖别人给你指明方向；太依赖别人的承诺就像把自己的性命托付给屠夫一样愚蠢，别人哪会关你的前途与生死，也许在他们看来，决定今天吃什么的苦恼比你的事情更让他们惦记于心。 值得庆幸的是，我在相对年轻的时候经历了创业公司的浮浮沉沉，让我体会到了在上一家公司看不到的事情，以前以为的理所当然变成需要你付出极大成本去获取，以前以为的唯一原来还处在那么多的不一样，视野开阔了，思路拓宽了，也许这就是成长，有着就值了。生命中没有如果..就…, 有的是对过去错误的反思和对今后正确方向的把握。我庆幸的是能在还算可以接受的成本下进行了试错，往往很多人一次的试错可能需要N多年的补偿。 看了阮一峰老师写的“你的命运不是一头骡子”，觉得套在自己过去的一年工作生活中显得“格外合适”，原来，我是一个类似于驼灯柱上山的骡子。 选择离别 ，为不做骡子一样的工具而奋斗。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Task混用ThreadPool导致无限等待","slug":"Java/2016-08-17-task-threadpool","date":"2016-08-16T16:00:00.000Z","updated":"2018-11-09T14:22:55.346Z","comments":true,"path":"2016/08/17/Java/2016-08-17-task-threadpool/","link":"","permalink":"http://heartaway.cn/2016/08/17/Java/2016-08-17-task-threadpool/","excerpt":"","text":"现象：生产环境商品打标异步任务提交任务后，任务没有被执行；查看日志，没有异常日志抛出。 初步猜测：可能是队列出现了饱和或者死锁，但是如果出现了饱和，我们设置的线程池设置的饱和策略是通过主线程去执行，为什么主线程也没有执行呢？ 具体分析：我定义了一个线程池Pool-Z，core_size=5,max_size=20,queue_size=1000，第一个任务A提交后，占用一个线程，那么这个任务A又会被分解成多个异步任务去执行，比如分解为A1、A2、A3（这些子任务为耗时任务），这些异步任务使用了同一个线程池Pool-Z提供线程，但是任务A内部做了一个事情，通过CountDownLatch.await实现了当所有A的子任务都执行完毕后，才执行后续的一个扫尾工作，也就是说线程A会等待同一个线程池中的A1、A2、A3执行完毕后才能释放出线程A的资源；如果没有其它的主任务B或者C加进来，这些任务总会被执行完毕；但是如果主任务提交非常频繁，比如连续提交了几个包含非常多子任务的B、C、D进来，此时这样的不敢具体子任务只是等待子任务完成的主任务就占用了4个主要线程，只有一个子任务在执行工作，由于不会分配新的线程来处理子任务，所以B、C、D的子任务都会被扔到队列里面，知道队列满掉，当队列慢了后，会开辟新的线程来处理任务，但是我们知道由于很多主任务提交进来都处于等待子任务释放而处于等待状态，如果当某一刻20个核心线程都成为了主任务且都在等子任务执行完毕的时候，子任务就得不到线程，锁等待就可能发生了，因为当时配置的任务队列比较大，为3000，所以当时加入的任务都被加入到了队列中，由于总数没有达到3000个，所以没有触发线程池的饱和策略。 解决方案： 方案一是去掉锁的使用，且需要保证相同业务含义；实现较困难； 方案二把两个线程池拆开，不共用队列，避免了相互等待而产生死循环；总结： 尽量避免线程之间的依赖；处理“当子任务都完成后再执行主任务”的场景最容易产生这样的线程依赖问题； 尽量避免使用wait、lock等操作；如果必须使用也切记加入超时时间； 对线程池的使用时最好自定义线程池的名称，方便拍错和定位问题； 如果需要使用内部类且内部类不需要应用外部类的属性，尽可能把内部类设置为static形态； 实践：自定义线程工厂实现给线程重命名的实践：123456789101112131415161718192021222324252627282930313233343536373839404142public class NamedThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; private final boolean threadDeamon; NamedThreadFactory(String name) &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); String newname = name != null ? name + \"-thread\" : \"thread\"; namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-\" + newname + \"-\"; threadDeamon = false; &#125; NamedThreadFactory(String name, boolean deamon) &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); String newname = name != null ? name : \"thread\"; namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-\" + newname + \"-\"; threadDeamon = deamon; &#125; @Override public Thread newThread(Runnable runnable) &#123; Thread thread = new Thread(group, runnable, namePrefix + threadNumber.getAndIncrement(), 0); thread.setDaemon(threadDeamon); if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; thread.setPriority(Thread.NORM_PRIORITY); &#125; thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread thread, Throwable ex) &#123; LOGGER.error(\"tagTask.\", thread.getName() + \" thrown an exception : \", ex); &#125; &#125;); return thread; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"属于我们的时代？","slug":"Think/2016-08-14-our-generation-time","date":"2016-08-13T16:00:00.000Z","updated":"2018-11-09T14:29:49.163Z","comments":true,"path":"2016/08/14/Think/2016-08-14-our-generation-time/","link":"","permalink":"http://heartaway.cn/2016/08/14/Think/2016-08-14-our-generation-time/","excerpt":"","text":"很多人说改革开放30年中，70年代的人在2000年左右赶上了互联网的浪潮，纵观如今国内BAT等各大互联网厂商无不出身在那个年代；80年代的人，赶上了低物价和房价的时代，一大部分人通过房地产赚的盆满钵盈；然后经历了2008年的全球金融危机后，国内物价、房价疯涨，那90年代的人，他们需要面对高房价、高物价的时代，在类似北上广的这种地方，买房比登天还难，所以很多人选择在远离市区甚至外省交接的地方购买房产，90年代的人是被房地产绑架的一拨人，一旦被房产绑架，给他们创新、创业的机会就少了。 中国目前还处于以金钱来衡量一个人成功与否的时期，而且这个时期将持续非常长的时间，所以每个人都梦想着采用各种方法发家致富，当李总理号召万众创业、万众创新的时候，一大批人下海投入了创业，2013-2014年那个时候，好不夸张的说只要你的一个PPT写的不错，拿到几百万天使投资不是难事，然后资本也是咨询市场规律的，当2年前那些拿到钱的公司因为2年的运营而陆续倒闭的时候（有统计数据称，美国新创公司第一年以后40%破产，5年内80%破产，活下来的20%在第二个5年中又有90%破产），资本市场一定会出现收缩，因为投资人的钱不是西北风，他们也要考虑投资收益率；再加上很多人太渴望财富了，所以不择手段，从一开始拿钱就没想着正而八经的做企业而是如何从投资人手中把钱捞出来，当有人成功了，很多人开始效仿，联合起来玩这种把戏，最大的莫过于e租宝，涉嫌集资500多亿。所以，这是最好的时代，也是最坏的时代，有些人通过创业投机获得了财务自由，有些人却因为创业而葬送了自己的职业生涯。其实，一个创业企业的失败，那些真正的高层是不会损失太多的，他们位高权重，大不了挪一个窝，继续当高管去了，有一些说不定早就捞到了一笔，Cash Out早在计划之中；然后最惨的是那些还比较年轻，相信创业可以改变他们人生轨迹而放弃一切All in的创业实干者，对于他们来说，试错成本是及其昂贵的，一旦创业失败，你很可能跟之前同等水平的人拉开3~5的差距，然后就是这么不公，经历过伤害才会让他们痛彻心扉。2016年的资本寒冬，会让不少2~3年前参与创业的人更加寒冷。 回过头来想一想，我们身处的社会阶层，谁不想努力向上爬一爬呢，随着社会的发展，社会阶层会逐渐固化，留给那些想提升社会阶层的人的机会也就越来约窄；然后，我认为这厉害还是存在一些更快捷的方式来让你想上挤，比如中考、高考，从一个好的大学出来的人，成功概率要比没有上过大学的人大的多，这个方式也是目前最直接的方式；其次，伴随着工作阅历逐年增长，如果你想通过“改变世界”的想法来让自己富有，基本不可能了，不过一些投机的方式一直会存在，就看你是否准备好了。所以，对于像我这样89年左右出身的人来说，要么深耕自己的专业技能让自己成为行业里的佼佼者，要么深谙市场运行规律，紧握时代脉搏，抓准机会，投机一把，找到自己的拐点，实现弯道超车，比如13年跟BUAN提及的一元夺宝项目，现在成为了各大厂商吸金利器。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"商品打标签设计踩过的坑","slug":"Program/2016-08-07-product-puttag-error","date":"2016-08-06T16:00:00.000Z","updated":"2018-11-09T14:27:23.289Z","comments":true,"path":"2016/08/07/Program/2016-08-07-product-puttag-error/","link":"","permalink":"http://heartaway.cn/2016/08/07/Program/2016-08-07-product-puttag-error/","excerpt":"","text":"问题一：同步操作，导致批量处理过慢，锁超时现象：在批量打标过程中，由于之前设计的是同步操作，一次打标的商品数过多时，导致执行时间较长，运营以为操作失败，多次重新导入和点击，导致系统出现不可预知情况。 原因：之前为了数据的一致性，对打标过程使用了事务处理，所以当批量打标的时候，相当于对这批数据都进行了行锁，其它操作这些数据的请求都会等待事务的提交，当等待超时，就报错了，“Lock wait timeout exceeded; try restarting transaction”（排查过程）。 代码： 解决方案：分析业务非强一致性，允许出错，故将事务去掉，将任务修改为异步任务，引入了自动重试机制，并将出错的任务加入到异常队列，用户可以看到那些是失败的任务，并主动进行重试（一般失败原因为商品主图太大，比如20~30M，导致打标失败）。 总结： 系统设计前缺乏整体性思考，明知道同步操作会导致业务处理缓慢，但未进行主动改进。 对项目编写完整的技术方案还是有必要的，有助于梳理现有业务的特性，并为之提供特定的解决方案。 问题二：异步操作，线程池滥用现象：运营在一次批量打标3000+商品后，前端用户进行商详查询页面缓慢或超时。 原因：由于之前紧急将同步操作修改为异步操作时，线程池使用了公用的线程池，此线程池还用于获取其他商品信息，当打标一次占用了太多的线程的任务时，其他请求就必须排队，由于打标是一个非常耗时的操作（每一个大约200~500ms不等），所以导致队列外的大量请求因为获取不到请求线程处于等待状态。 代码： 解决方案：定义标签管理自己的线程池。 总结： 深入了解线程池的使用方法，对系统中的线程池提前做好统一规划。 一定程度上限制线程池的使用，防止线程池滥用或者过度使用。 熟悉系统当前可能最大的线程数，系统支持的最大线程数，防止线程数超过外部限制。问题三：业务范围把握不清，多系统间数据处理遗漏现象：最开始标签只考虑了详情页和搜索列表页，忽略了订单列表页、CMS关联的活动列表页，导致用户在活动列表页、订单列表页中看不到商品标签。原因：缓存清理部分未对CMS活动列表页、订单列表页中商品数据进行更新导致数据不一致。究其原因，我们在对一个已经存在的功能进行业务重构时，必须首先完全掌握之前的业务处理流程，把各个与之相关的点都梳理出来，弄清楚业务边界，如果能拿到之前的文档最好，其次最好与之前的作者做好信息沟通，单纯的通过阅读代码很容易遗漏一些细节点。总结： 对老功能重构，首先必须通过一些手段完全掌握业务的边界和技术的实现手段。 我们在设计代码时，尽量做好抽象和代码的内聚性，减少代码的扩散和功能性逸出。 方法标签上必要的业务注释可以帮我们更好的理解代码。 当一个功能设计N个系统操作时，我们需要认真对待功能的设计，考虑数据的实时性、一致性。问题四：事务操作中存在消息、Redis等不支持回滚的操作现象：去标时，详情页的标去掉了，但是通过发消息进行的搜索结果中标未去掉，导致数据不一致。原因：事务处理过程中，先进行了数据删除，然后通过消息通知搜索进行商品索引重构并进行了缓存清理，此时为了防止缓存被击穿，对数据进行了加载，所有完成后才会进行数据提交，这导致了，数据提交前，搜索已经收到了消息并进行了搜索重构，搜索拿到的是事务未提交前的数据，所以导致数据未更新。代码：解决方案：取消事务的限制，在这样的一个处理链路中由于存在无法回滚的操作，所以嵌套事务是没有必要的，其次，嵌套事务还可能会带来更大的问题。总结： 不是任何操作都是可以事务操作的，不要滥用事务处理机制。 在进行功能设计的时候，全局考虑数据一致性方案，强一致性、弱一致性、最终一致性。 在事务里面操作外部系统数据，一定要小心，需要考虑分布式事务的处理，否则请放弃使用事务。问题五：测试不充分，导致低级bug产生现象：CMS活动页面过期标签未失效，搜索、详情页、订单列表页均已失效。原因：搜索、详情页、订单列表页中标签失效的原因是虽然标签数据未被清理，但是通过时间戳判断做了失效，但是CMS只能通过新图覆盖的方式进行数据更新，所以如果去标的定时任务未执行时一定会导致数据未更新。代码：在进行结束时间移除标签的SQL中，由于通过代码拷贝，字段未修改，导致业务逻辑异常，查询出来的数据为空，故去标任务等价于未执行。解决方案：将第二个SQL中的start_time全部替换为end_time总结： 没有经过验证的点，均有可能存在问题，不要抱侥幸心理。 项目上线没有经过codeReview，且上线后没有做全功能的验证。 任何反馈出来的问题，都可能是隐藏的bug，及时排查问题，防止问题进一步扩大。 复制代码非常容易出错，必须格外小心，如果存在相同结构的代码，尽量通过抽象完成结构统一。","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"图解《Java并发编程实战》","slug":"Java/2016-07-25-picture-java-concurrent","date":"2016-07-24T16:00:00.000Z","updated":"2018-11-09T14:22:48.896Z","comments":true,"path":"2016/07/25/Java/2016-07-25-picture-java-concurrent/","link":"","permalink":"http://heartaway.cn/2016/07/25/Java/2016-07-25-picture-java-concurrent/","excerpt":"","text":"基本概念： 同步容器： 线程框架： 死锁：","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Lock wait timeout exceeded; try restarting transaction","slug":"Mysql/2016-07-16-mysql-lock-wait","date":"2016-07-15T16:00:00.000Z","updated":"2018-11-09T14:25:36.291Z","comments":true,"path":"2016/07/16/Mysql/2016-07-16-mysql-lock-wait/","link":"","permalink":"http://heartaway.cn/2016/07/16/Mysql/2016-07-16-mysql-lock-wait/","excerpt":"","text":"排查过程：查看数据库 INNODB_LOCKS，未发现有死锁的记录。查看 SHOW PROCESSLIST; 也未见异常进程；通过Mysql的控制台，查询慢日志，也未找到有关此表的Mysql慢日志信息。查询Mysql默认的所等待超时时间：show variables like ‘innodb_lock_wait_timeout’;Variable_name Valueinnodb_lock_wait_timeout 50那Spring事务默认的事务超时时间是-1，表示事务超时将依赖于数据库的事务超时时间，当前为50秒，也就是存在事务等待锁超过50秒还未拿到锁导致事务超时了。 业务重现：后来我到业务控制台上进行业务重现（批量商品打标），在查看 INNODB_LOCKS：product-put-tag-tx-lock发现后台针对同一条数据存在两个事务，推测是第一个事务当前还在执行（可能比较慢），第二个是个事务又提交上来了（操作重复），所以对同一条数据尝试加X锁，发现已经有锁了，所以第二个事务会处于锁等待，由于我们Spring事务未配置超时时间，所以当前的事务超时时间为50秒，等待50秒之后就会出现超时，此时Mysql会抛出“Lock wait timeout exceeded; try restarting transaction”异常；除此之外，我们还需要考虑接口调用超时时间给业务带来的影响。 解决方案：考虑到批量打标可以允许部分失败的场景，所以取出事务，捕获异常并进入异常队列；由于单个打标非常耗时，批量更会增加执行时间，所以修改同步操作为异步操作；把预先批量处理的业务拆分到单个业务处理逻辑中，减少预处理成功后续失败的场景；由于打标可能出现网络超时，所以添加自动重试机制，减少错误概率； 批处理优化建议：减少批处理的最小化单元，尽量减小锁的范围；修改同步执行时间为异步执行，并且捕获异常；一些异常场景不影响事务整体提交，允许部分场景下的异常；设置合理的超时时间；设置合理的执行数量限制； 其它思考：假设一：我们的打标任务被一个要求拥有事务保证的接口调用的时候，怎么保证整体的事务性？ 答：这个属于分布式事务的范畴，可以参考分布式事务环节。 假设二：我们的批量操作为内部接口，需要保证内部的事务性，比如我们通过购物车进行下单，为了提高系统的性能，需要一次对多个SKU进行扣库存逻辑，如果存在一个SKU的库存不够扣时，就需要整体回滚，在高并发场景下，扣库存就成为了耗时操作，这种场景下我们怎么处理呢 ？ 答：在高并发场景下，如果我们只是采用原生Mysql的事务操作来做批量库存更新的话，会导致大量请求处于锁等待场景，为了加快处理，我们的做法是将库存数据放到redis中，把数据库操作转化为redis操作，如果使用单机版的redis，虽然redis提供事务功能，但是事务并不具备完整性，因为不支持回滚操作，其次一般公司随着业务的发展，单机不能满足性能要求，会搭建Redis-Cluster集群，Redis-Cluster不支持事务操作，multi-key操作也必须在同一个节点中才能使用，虽然我们库存操作的是Redis读操作，但是写的时候还是用的Mysql的悲观锁，也未能解决这个写入的性能问题。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://heartaway.cn/categories/Mysql/"}],"tags":[]},{"title":"你的工作离赚钱近吗？","slug":"Think/2016-07-09-think-you-work","date":"2016-07-08T16:00:00.000Z","updated":"2018-11-09T14:29:55.587Z","comments":true,"path":"2016/07/09/Think/2016-07-09-think-you-work/","link":"","permalink":"http://heartaway.cn/2016/07/09/Think/2016-07-09-think-you-work/","excerpt":"","text":"互联网行业有一个规律，当你所做的事情离钱越近的时候，越会受到公司重视，这种重视会是资源的倾斜、价值的回报、能力的认可。所以当你选择工作的岗位的时候，想一想，你离核心业务是否够近，比如电商行业，商品的零售带来的利润就是公司非常重要的盈利手段，那么在这条链路上，你所处哪一环节，是成交转化还是仓储配送疑惑售后客服？要抓住整个链条的七寸，方能给自己争取更大的发展空间，否则你可能会成为可有可无的螺丝钉，在企业经济效应不景气需要裁员的时候，请不要说我的能力如何，我为公司付出了多少，因为你所作的事情已经决定了你在整个企业盈利体系中的价值。理解商业的本质，你就会理解职业的本质，无论当下是创业还是打工，在你当前的工作中什么对你是最有价值的，你就应该努力让自己到达那里，这其中需要自知、自省、自制，不自知的努力是妄想，不自省的奋斗容易膨胀，不自制的前行可能让你迷失方向。在自身能力匹配的情况下，如果可以选择，一定要让自己更多的向产生利润的岗位靠近，这样做是什么好处呢？ 第一、你的努力更容易拿到结果。没有结果的努力，可能会成为徒劳，这里面不排除一些为后续更大结果做了铺路石只是当下没有结果的事情。有好结果的事情，无论对企业还是个人都是非常大的肯定，你做的事情越多的受到肯定，大家对你会越信任，越多更具有挑战的事情会让你去承担。在阿里的文化中，结果导向是非常重要的一个做事方式，即使你做的事情后来发现可能没有预先想象的那么有趣，但是最好还是寻求一个结果，有时候这个结果可能与利益无关。 第二、你的价值会被逐步放大。在企业中最怕那种工作越做越来默默无闻，时间长了，你就没有了存在感，你也就成了可有可无的摆设了，在这种职业路线中，你其实是在走下坡路，此时你就应该反省了，是个人的问题还是业务被边缘化，此时你需要的是变化，主动去改变这种格局。人都是渴望被认可、被信任、被认为重要，如果你工作中感受不到这点，说明你需要静下来，思考，找到适合自己的路，来让自己的价值曲线向上。 第三、你的发展空间会更大。如果你做的是边缘业务或者是企业为了试错的业务，那么你需要做好业务被砍的心理准备，因为你所作的事情并不在当前企业核心价值体系之中，当企业考虑成本与利润的时候，这种业务被砍也是情理之中的事情。有人会说，被砍了可以去做其他的事情呀，这话没错，但是，这点违背了第一条，寻求结果，当业务被砍的时候，你可能无法拿到结果，这标识你过去付出的一切可能都会付诸东流，如果你去其他业务部分，也许他们也在进行人员精简，找到一个合适的位置会变得很难。我所经历的试错业务团队被砍后，带来的代价是，整个团队离职，真的很可惜，团队中有很多优秀的人未能留下来。对公司和他们个人都是一个损失。如果你的业务是核心业务，那么代表着，你不需要为业务被砍而过早担心，你做的事情会相对稳定很多，稳定带来的好处是你可以有更长的时间在这个领域里面深耕和沉淀，你积累的多了，以后的发展空间也会越大。 那么对一个目前还是普通程序员来说，如何调整自己的方向呢，我认为首先需要分析自己当前在做的事情是否为业务的核心，还以电商为例，如果你做的是ERP系统、客服系统、工单系统、OA系统，如果你是刚毕业一两年的小青年，做做没什么不可，如果你是工作了四五年的程序员，那么你可以考虑换换了，我不是说这些不重要，而是这些已经不再适合你了，做这些非核心业务，那些刚毕业一两年的人的性价比比你高，企业如果可以使用更低的成本达到同样的效果为什么还要花更大的成本呢。如果你的技术水平未能匹配你的工作年限，那么你当前最重要的事情是想尽一切办法沉淀自己，让自己变得更加专业，不要眼红别人的高工资，你只需要做的是提高自身的能力。当能力与工作年限匹配的时候，你就可以选择那些离钱更近、更有发展空间的岗位了。对于一个普通程序员来说，哪些岗位可能会离钱更近呢？我认为在电商企业中有以下研发岗：导购、支付、订单、搜索、推荐、增长。BI为什么不在里面呢，虽然BI非常重要，但是你没有使用数据的决定权，至多是一个数据源。我罗列的这几个岗位中内部也是会区分重要性的，你是决策者还是执行者，如果从执行者成长为决策者，是你需要思考的问题。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"CAS 操作的实现原理","slug":"Java/2016-07-07-cas-work","date":"2016-07-06T16:00:00.000Z","updated":"2018-11-09T14:22:44.057Z","comments":true,"path":"2016/07/07/Java/2016-07-07-cas-work/","link":"","permalink":"http://heartaway.cn/2016/07/07/Java/2016-07-07-cas-work/","excerpt":"","text":"CAS原子操作原理：1. 在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段（多处理器）CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。12345678910inline bool CAS2(pointer_t *addr, pointer_t &amp;old_value, pointer_t &amp;new_value)&#123;bool ret;__asm__ __volatile__(\"lock cmpxchg16b %1;n\"\"sete %0;n\":\"=m\"(ret),\"+m\" (*(volatile pointer_t *) (addr)):\"a\" (old_value.ptr), \"d\" (old_value.tag), \"b\" (new_value.ptr), \"c\" (new_value.tag));return ret;&#125; 解锁来保证原子性只是保证原子性的其中一种手段而已，X86CPU保证原子性的手段有以下三种：① 处理器自动保证基本内存操作的原子性。一些基本的内存读写操作是本身已经被硬件提供了原子性保证（例如读写单个字节的操作）； ②使用总线锁保证原子性。一些需要保证原子性但是没有被第①条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性。 ③使用缓存锁保证原子性。 总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。因为很多内存数据是已经存放在L1/L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效.但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。 那么哪些操作是非原子的呢？ ACCESSES TO CACHEABLE MEMORY THAT ARE SPLIT ACROSS BUS WIDTHS, CACHE LINES, AND PAGE BOUNDARIES ARE NOT GUARANTEED TO BE ATOMIC BY THE INTEL CORE 2 DUO, INTEL® ATOM™, INTEL CORE DUO, PENTIUM M, PENTIUM 4, INTEL XEON, P6 FAMILY, PENTIUM, AND INTEL486 PROCESSORS. （说点简单点，那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的，你如果想保证这些操作是原子的，你就得求助于机制②，对总线发出相应的控制信号才行）。 2.对于linux而言，内核提供了两组原子操作接口一组是针对整数进行操作；另一组是针对单独的位进行操作。①原子整数操作：针对整数的原子操作只能对atomic_t类型的数据处理，Linux支持的所有机器上的整型数据都是32位，但是使用atomic_t的代码只能将该类型的数据当作24位来使用。这个限制完全是因为在SPARC体系结构上，原子操作的实现不同于其它体系结构：32位int类型的低8位嵌入了一个锁，因为SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。②原子位操作：原子位操作定义在文件中。令人感到奇怪的是位操作函数是对普通的内存地址进行操作的。原子位操作在多数情况下是对一个字长的内存访问，因而位号该位于0-31之间(在64位机器上是0-63之间),但是对位号的范围没有限制。 为什么关注原子操作？1）在确认一个操作是原子的情况下，多线程环境里面，我们可以避免仅仅为保护这个操作在外围加上性能开销昂贵的锁。2）借助于原子操作，我们可以实现互斥锁。3）借助于互斥锁，我们可以把一些列操作变为原子操作。 CAS带来的问题：1). ABA问题；CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。在Java中提供了AtomicStampedReference解决ABA问题。 2). 循环时间长，开销大；自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3). 只能保证一个共享变量的原子操作；当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 参考连接：https://software.intel.com/zh-cn/blogs/2010/01/14/cpucpuhttp://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.htmlhttp://www.infoq.com/cn/articles/atomic-operationhttp://www.infoq.com/cn/articles/java-memory-model-5http://www.docin.com/p-92508695.html%E3%80%82","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"高并发系统 之 降级特技","slug":"Program/2016-07-05-product-high-use","date":"2016-07-04T16:00:00.000Z","updated":"2018-11-09T14:27:33.440Z","comments":true,"path":"2016/07/05/Program/2016-07-05-product-high-use/","link":"","permalink":"http://heartaway.cn/2016/07/05/Program/2016-07-05-product-high-use/","excerpt":"","text":"高并发场景三把利器保护系统：缓存、降级、限流。当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。本文将介绍一些笔者在实际工作中遇到的或见到过的一些降级方案供大家参考。 降级按自动化程度分类： 系统根据关键数据自动降级; 人工通过配置进行手工降级;自动开关降级指标： 超时降级； 故障降级； 限流降级；超时降级：当访问的数据库/http服务/远程调用响应慢或者超时（比如dubbo客户端超时），且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）。限流降级：当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。手动开关降级：在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：网卡被打满了、挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；此时就可以使用开关来完成降级。 降级按照功能分类： 读服务降级； 写服务降级；读服务降级的思路：1、开关集中化管理：通过推送机制把开关推送到各个应用（比如我们使用Diamond实现动态配置变更）；2、后端读缓存降级（降级到读缓存、降级到走静态化）：比如只读本地缓存、只读分布式缓存、或者只读一个默认的降级数据；3、前段Nginx请求降级：将开关前置到nginx的接入层，从nginx直接返回一些数据请求，请求打不到后端应用。举例：①我们的详情页静态HTML数据默认缓存时间是6min，超过6min就会查询DB进行刷新缓存，如果后端构造详情页的服务挂了，此时缓存又都失效了，就会导致页面出不来，所以我们可以在这里做一个缓存降级策略，如果后端服务挂了，我们是允许使用缓存数据的；用户浏览已经过期的详情页的静态数据比不能浏览要好。②当一些页面请求量非常大时，一些请求直接在Nginx上做了开关拦截，返回固定数据，让主流程可以不受到影响。③订单列表页中不同状态订单数查询，流量较大的时候降级为只走缓存；写服务降级的思路：写服务在大多数场景下是不可降级的，不过可以通过一些迂回战术来解决问题。比如将同步操作转换为异步操作，或者限制写的量/比例。举例：①正常情况可以同步扣减库存，在性能扛不住时降级为异步；另外如果是秒杀场景可以直接降级为异步，从而保护系统。 参考：http://jinnianshilongnian.iteye.com/blog/2306477","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"Mysql  中悲观锁概念和使用","slug":"Mysql/2016-07-01-mysql-lock","date":"2016-06-30T16:00:00.000Z","updated":"2018-11-09T14:25:27.581Z","comments":true,"path":"2016/07/01/Mysql/2016-07-01-mysql-lock/","link":"","permalink":"http://heartaway.cn/2016/07/01/Mysql/2016-07-01-mysql-lock/","excerpt":"","text":"悲观锁介绍（百科）：悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 Mysql InnoDB 排他锁实现悲观锁用法：select…for update; 与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在表X中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 行级锁 （Row Lock）或 表级锁（Table Lock）：使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)；当然Mysql也对for update做了一些优化，并不是没有指定主键，一定会触发表级锁；比如使用索引也会影响数据库的锁定级别。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，注意这里只是影响。具体可以参考：mysql事务和锁InnoDB Mysql InnoDB悲观锁的使用：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 我们的电商设计中是下单扣库存，所以用户下单的时候，会调用商品系统的库存扣减服务，此时商品系统是根据库存行记录进行加悲观锁做库存扣减的，虽然这种方式比较安全，可以一定程度上减少超卖的风险，但是在下单并发非常高的时候，Mysql的悲观锁就会显得效率很低。应对这种场景有几种解决方案：①阿里修改了Mysql底层的源码，提高了悲观锁的效率；②使用Redis进行库存计算，DB作为最终一致性的数据存储；③请求端对库存扣减进行合并统一处理； 其它参考：http://www.cnblogs.com/zhaoyl/p/4121010.htmlhttp://hedengcheng.com/?p=771","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://heartaway.cn/categories/Mysql/"}],"tags":[]},{"title":"商品系统 之 Redis的使用","slug":"Redis/2016-06-29-product-system-redis","date":"2016-06-28T16:00:00.000Z","updated":"2018-11-09T14:27:54.446Z","comments":true,"path":"2016/06/29/Redis/2016-06-29-product-system-redis/","link":"","permalink":"http://heartaway.cn/2016/06/29/Redis/2016-06-29-product-system-redis/","excerpt":"","text":"Redis在现在的电商系统中越来越多的被使用作为缓存体系，掌握基本的Redis的使用还是非常有必要的。 Jedis 客户端初始化： 你是如何初始化Jedis的？使用Spring Bean 或者 静态工具类？项目中有人使用在类的静态初始化块中初始化Jedis连接，有没有捕获异常，导致Jedis初始化失败后，整个类就无法进行加载，进而报ClassNotDefFound的错误，所以我们在初始化Jedis的时候是需要考虑异常场景的（当然使用原来外部资源的方式初始化静态变量就不是一个好的选择）。对于持久化Redis，当连接或请求异常的是，进行连接retry和reconnect，重试时间应该大于cluster-node-time时间，但是有一点需要考虑，当你的线程大量处于重试时，是否会达到线程池的最大值？ Jedis业务代码中的容灾方案：①请求容灾在创业初期，一般公司都是缺乏专业的Redis运维人员，Redis的稳定性也得不到保证，所以这个时候就不能把Redis作为唯一的救命稻草，如果Redis挂了，你的业务也就跪了。在我们电商系统中，各个垂直系统之前公用Redis集群，后来发现如果一个节点出现问题就会导致整个公司的业务挂点，所以对Redis集群进行了业务拆分，不同的业务系统使用单独的Redis集群，持久化缓存和非持久化缓存进行分离。虽然这样在某种程度上降低了Redis宕机给业务带来的风险，但是如果在客户端这边没有对Redis的使用考虑容灾降级的话，也是可能给业务带来一连串的风险；比如，我们遇到了一次公共Redis集群中的几台ECS主机挂掉了，重启redis集群、重启ECS都不起作用，这个时候业务系统由于没有对Redis考虑容灾和降级，在获取Redis资源的时候就开始大量报错，导致使用了此服务的所有应用都出现了异常；如果Jedis客户端采用Spring Bean，由于拿不到Redis连接，还会让应用容器无法启动。这个时候如果通过容灾策略跳过查询Redis转为查询DB的话，大量请求直接打在DB上就可能导致DB瓶颈，但是如果Redis是集群的话，单个节点不可用只会影响落到这个Node的请求，当15s后，Node的Slave升为Master就可以解决缓存，给业务带了的不可用只是短暂的。 ②hot-key 容灾 避免产生hot-key，导致节点成为系统的短板；如果系统容易产生hot-key，建议系统进行本地缓存（比如使用ehcache），这种方案会对业务有侵入性，还有一种解决方案是搭建无状态的proxy，proxy具备缓存hot-key的能力，redis需要具备发现hot-key并进行主动上报proxy，这样hot-key就从单节点转移到了proxy层，同时proxy在压力大的场景下可以平滑水平扩容，当然你也需要考虑数据一致性问题。 ③big-key 容灾避免产生big-key，导致网卡打爆、慢查询； ④TTL避免大量Key在同一时间段过期。最简单的办法是缓存时间随机，这对一次放入大量的Key是有效的，但是对于分散的key不起作用，而且随机不易管理，一个key到底什么时候失效我们无法做到管控。 ⑤高并发key失效 容灾在流量非常大的情况下，如果缓存失效，大量请求就会打到DB上，这个时候很可能达到DB的瓶颈，造成雪崩，所以为了有效防止这种场景下的雪崩，我们引入了 “分段式缓存策略”，将缓存分为缓存逻辑失效(expire)和缓存物理失效(maxExpire)；缓存物理失效时，查询数据重新刷入缓存，这点没什么变化；缓存逻辑失效后，当前线程会获取锁，并进行缓存更新，在缓存更新刷新的过程中，其它大量的请求可以直接返回老数据（只是逻辑过期，并未物理过期），从而有效防止雪崩。 分段式查询缓存: 缓存未命中，尝试获取更新锁: 获取更新锁成功，执行业务并刷新缓存; 获取更新锁失败，说明缓存正在被更新，直接查询DB； 缓存命中，缓存是否逻辑过期： 缓存逻辑未过期，数据有效且正常，直接返回； 缓存逻辑过期，获取更新锁： 更新锁获取成功，执行业务刷新缓存； 获取更新锁失败，说明有线程在刷新缓存直接返回逻辑过期的数据； 注意： 当你进行缓存更新的之前需要获取锁，这个锁一般使用Redis实现分不是锁；获取到锁后，业务处理完毕记得释放锁。 Redis操作中Key的定义：随着业务的发展，Redis的使用越来越多，Redis的内存占用量也水涨船高，但是Redis的内存不是无限，有几种方案降低Redis机器内存占用的值: ①是增加更多的节点，拉平内存占用量水位； ②对数据进行压缩，解决内存碎片问题； ③缩减Key或者Value对Redis的使用量，比如简化Key的占用，或者对Key进行MD5。 ④使用带压缩策略的Redis数据结构，比如Hash。 那么如何更优雅的定义Key呢 ？一般的做法是: 系统名称前缀:表名称:字段名称:版本号:业务数据 设计版本号的作用是当新增字段时，需要更新缓存，只需要修改一下版本号就可以了。然后对这个规则的Key进行最大可能的字段缩减，在保证业务Key不重复的情况下，尽量减少Key的长度。 Redis-Cluster 中使用Multi·Key操作：当然，当我们使用Redis集群的时候，一些业务场景需要让一些相同业务含义的数据落在同一个节点上，方便我们进行MSET、MGET操作（Redis Cluster跨节点点不支持MSET、MGET操作），这个时候我们可能就需要使用Redis的Hash Tag功能，它允许用key的部分字符串来计算hash； 当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。 但是这个会带来一个问题，当流量高峰期的时候，大部分的请求都会落到固定的hash槽中，单台Redis Node的压力会非常大，因为Redis是单进程单线程模式，采用队列模式将并发访问变为串行访问，流量超过了单节点的处理能力后，触发Jedis客户端的超时，重连等错误，客户端不断报： 1JedisClusterMaxRedirectionsException: Too many Cluster redirections? 首先想到最简单的办法就是针对不同的业务场景中的Multi Key操作进行拆分，尽量不要落到同一个Redis Node中，怎么操作让他们落在不同的Redis Node上呢 ？人工通过改变Hash Tag，计算key中{}内的Hash值对应的slot，来达到移动slot的目的，我们称之为预分桶。预分桶的实现如下： 1HASH_SLOT = CRC16(key) mod 16384 其中CRC16算法的C语言实现：CRC16，对Crc16的原理可以参考：Redis源码中的CRC校验码Jedis也提供了计算slot的方法：redis.clients.util.JedisClusterCRC16.getSlot()但是这种方案并没有从根本上解决问题，当一个不可拆分的业务数据量达到单台Redis的瓶颈的时候怎么解决 ？参考唯品会、美团、饿了吗的Redis实践，有一些采用的增加Proxy让服务端分片的方式（twemproxy等），对于multi key操作有服务端进行多次操作来达到目的，但是之前的一次操作会被拆为多个单操作，导致QPS翻倍，好在的是我们可以通过水平扩展节点的方式来达到分担压力的目的。 总结：之所以我们会自主搭建Redis-Cluster，原因是在14年阿里云还未推出KV-Store（云Redis）存储设备，所以只能自建，自建场景下，我们缺乏专业的Redis运维同学，所以导致我们在Redis的运维上除了N多问题，给人的印象是每逢大促必挂，给业务带来了很大的损失。回过头来再计算一下我们购买机器、SSD、运维等的成本，比使用阿里云的Redis还贵，所以如果能使用阿里云的服务还是尽量采用阿里云的服务。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://heartaway.cn/categories/Redis/"}],"tags":[]},{"title":"分布式系统高效唯一ID生成方案","slug":"Java/2016-06-26-distributed-id-generator","date":"2016-06-25T16:00:00.000Z","updated":"2018-11-09T14:34:38.341Z","comments":true,"path":"2016/06/26/Java/2016-06-26-distributed-id-generator/","link":"","permalink":"http://heartaway.cn/2016/06/26/Java/2016-06-26-distributed-id-generator/","excerpt":"","text":"背景：在分布式系统中，对于订单ID如何保证全局唯一地高效的生成，并对性能影响不大的情况下，利于建立索引和业务使用？ 方案一：使用数据库主键ID优势：实现简单；弊端：使用数据库增加写库的压力，生成订单的上限受限于数据库的写性能上限；扩展性差； 方案二：单点批量生成订单号的服务；优势：批量降低了数据库的读写压力弊端：服务单点风险； 方案三：使用UUID优势：本地生成ID，不进行远程调用，延迟低；弊端：无法保证趋势增长；uuid过长且建立索引效率低下；64位太长； 方案四：使用毫秒数优势：本地生成ID，不进行远程调用，延迟低；ID为整数利于建立索引；弊端：并发超过1000，可能会重复；优化方案：使用LRU Cache存储最近生成的100Key，去除后先判断是否重复；进一步降低重复的可能性；但是无法根本上解决高并发下的重复； 方案五：订单号分段表示具体含义方案描述：使用39bit表示毫秒数、4bit表示业务线、7bit表示机器等优势：实现简单，且重复可能性很低；弊端：订单长度过长，不利于业务使用； 方案六：使用Redis服务+毫秒数双重方案优势：使用redis的自增序列特性，每次获取一定数量的数据（1000个），降低了每次调用Redis的开销；当Redis挂了，使用基于毫秒数的本地生成ID优化方案；弊端：redis挂了后，订单号的重复性不可避免； 总结：我们在设计分布式全局唯一单号的时候，不仅需要考虑生成单号的是否重复性，还要考虑生成时的性能开销、是否有容灾方案、是否便于建立索引、是否利于业务使用等。基于这些点的考虑，我们采用了方案六作为线上的唯一生成方案，并把此方案作为一个业务隔离的二方库，可以提供给不同业务方式用；","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Mysql新增字段到大数据表导致锁表","slug":"Mysql/2016-06-15-mysql-lock-table-ddl","date":"2016-06-14T16:00:00.000Z","updated":"2018-11-09T14:25:19.166Z","comments":true,"path":"2016/06/15/Mysql/2016-06-15-mysql-lock-table-ddl/","link":"","permalink":"http://heartaway.cn/2016/06/15/Mysql/2016-06-15-mysql-lock-table-ddl/","excerpt":"","text":"生产环境对Mysql中一张表（sc_stockout_order）做新增一个字段操作： 1ALTER TABLE `sc_stockout_order` ADD `route_remarks` VARCHAR(1024) CHARACTER SET utf8mb4 NULL DEFAULT NULL COMMENT '物流备注' AFTER `remarks`; Mysql的配置： 应用系统也开始报错： 12345Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.tomcat.jdbc.pool.PoolExhaustedException: [DubboServerHandler-10.162.99.129:20880-thread-105] Timeout: Pool empty. Unable to fetch a connection in 50 seconds, none available[size:80; busy:79; idle:0; lastwait:50000]. at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:26) ~[mybatis-3.2.8.jar:3.2.8 从日志上可以看出JDBC连接池拿不到可用连接了，连接池大小为80，当前空闲为0，由于有2太机器，所以这个时候总的最大连接数为160，虽然数据库的最大连接数是300，但是已经达到了客户端的配置；其实这里的配置不太可以，2太机器的话，可以配高一点，比如每台最大连接数可以配置为150。 发现问题后，首先为了解决问题，在Mysql客户端中 show processlist 发现由于ALTER TABLE xx 这条语句导致大量的Query条件的语句处于等待状态，为了减少继续产生问题，必须先解决问题，通过 kill processId 杀掉修改表结构的语句，发现马上processlist恢复正常。 show processlist 中还出现了一条语句： 1Waiting for table metadata lock sc_stockout_order 中现有字段个数 91 个，数据量为 3959102 条, 数据量还是比较大的。 Mysql的连接数： 从图中也可以看出活跃连接数达到160之后就不变了，顶端蓝色水平线部分，当杀掉阻塞进程后，连接得到释放。 事后，查找资料，进行原因分析：Mysql在5.6版本之前，直接修改表结构的过程中会锁表，具体的操作步骤如下： 首先创建新的临时表，表结构通过命令ALTAR TABLE新定义的结构 然后把原表中数据导入到临时表 删除原表 最后把临时表重命名为原来的表名 Historically, many DDL operations on InnoDB tables were expensive. Many ALTER TABLE operations worked by creating a new, empty table defined with the requested table options and indexes, then copying the existing rows to the new table one-by-one, updating the indexes as the rows were inserted. After all rows from the original table were copied, the old table was dropped and the copy was renamed with the name of the original table. 但是在Mysql 5.6 之后引入了Online DDL： MySQL 5.6 enhances many other types of ALTER TABLE operations to avoid copying the table. Another enhancement allows SELECT queries and INSERT, UPDATE, and DELETE (DML) statements to proceed while the table is being altered. This combination of features is now known as online DDL. 那么Online DDL下是如何实现的呢？参考：http://www.cnblogs.com/cchust/p/4639397.html Mysql 5.6 虽然引入了Online DDL，但是并不是修改表结构的时候，一定不会导致锁表，在一些场景下还是会锁表的，比如 ①某个慢SQL或者比较大的结果集的SQL在运行，执行ALTER TABLE时将会导致锁表发生； ②存在一个事务在操作表的时候，执行ALTER TABLE也会导致修改等待； 查看我们mysql的版本： 12SELECT VERSION();5.6.16-log 我们通过Mysql的慢SQL控制台，也在发生问题的时间段内没有出现慢SQL，所以需要排除第一种可能性；由于当时没有保留现场，所以当时是不是由于事物导致的锁表，现在也无从查起，这只能下次查看分析了。 总结：对大表的修改以后千万要注意，修改需要满足一下条件： 需要找一个流量比较小的时候； 需要查看当前是否有未提交的实物； 需要测试环境预演练，有一定预期； 知晓表数据大小（SELECT DATA_LENGTH + INDEX_LENGTH FROM TABLES WHERE TABLE_SCHEMA=’logistics’ AND TABLE_NAME=’stockout_order’ ;） Mysql大表一般DBA都会做归档操作，把大表转为小表；或者使用 percona-toolkit 工具来辅助完成DDL操作，关于PT的工具原理和介绍：http://www.cnblogs.com/zhoujinyi/p/3491059.html有关 Metadata lock wait 请参考：https://help.aliyun.com/knowledge_detail/41723.html","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://heartaway.cn/categories/Mysql/"}],"tags":[]},{"title":"用线程池解决批量任务执行","slug":"Java/2016-06-14-threadpool-handle-batch","date":"2016-06-13T16:00:00.000Z","updated":"2018-11-09T14:34:41.345Z","comments":true,"path":"2016/06/14/Java/2016-06-14-threadpool-handle-batch/","link":"","permalink":"http://heartaway.cn/2016/06/14/Java/2016-06-14-threadpool-handle-batch/","excerpt":"","text":"今天遇到一个场景：用于有一批数据需要批量处理，每一个任务的处理都会花费300~500ms的时间，如果列表为30个时，直接导致http请求超时了（设置的Http请求时间为10s）。所以期望服务端能够多线程执行任务，所有执行完毕后返回最终结果。 解决方案大家比较明确了，在外部接口无法被优化的场景下，只能将顺序执行的任务变为并行执行，Java提供了线程模型和线程池模型。但是要做到合理的利用线程池，必须对其原理了如指掌。 所以问题的解决方案是： 定义线程池对象12protected BlockingQueue queue = new LinkedBlockingQueue(100); protected ExecutorService taskExecutor = new ThreadPoolExecutor(5, 20, 10, TimeUnit.MILLISECONDS, queue); 为什么不使用Executors工厂类提供的集中固定的线程池对象呢？ Executors工厂提供了以下集中常见的线程池（基本上都是通过不同参数实例化ThreadPoolExecutor得到）： Executors.newFixedThreadPool 创建固定数量线程的线程池，线程空闲多久都不会自动关闭，直到线程池主动关闭。当我们线程数不均匀的时候，无法做到很好的扩容。 Executors.newSingleThreadExecutor 创建单线程的线程池。 Executors.newCachedThreadPool 创建无线程上限(Integer.MAX_VALUE)的线程池，默认线程空闲60秒后自动回收，防止资源浪费，因为无上限，所以就没必要使用阻塞队列来存储任务了，因为原则上线程池不会满，这里采用的是SynchronousQueue，这个阻塞队列要求每个插入操作必须等待另一个线程的对应移除操作，相当于一个数量为1的缓冲区，既然线程无上限，那SynchronousQueue的作用是什么呢，我猜想应该是线程池初始化线程是要时间，采用这样一个缓冲区就可以等待线程池中新的线程创建完毕后直接使用，而不是任务当代线程池中线程的创建。一般生产环境线程数受限于Jvm、Linux等限制不可能做到无限大，为了更高的可控性，不会直接使用此方法。 Executors.newScheduledThreadPool 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。 我们自定义线程池： corePoolSize（线程池的基本大小），而不是0，原因是线程空闲时，线程可以直接使用，而不需要等待新线程的创建，加快运行效率； maximumPoolSize（线程池最大大小），设置线程池的最大值而不是Integer.MAX_VALUE，因为我们需要做到资源可控，jvm、linux os的可创建线程数都是有限的（记一次系统Dubbo调用超时的故障）； keepAliveTime（线程活动保持时间），为了加大线程的可用性，设置空闲线程的存活时间，不能太小，否则线程就一直处于销毁和创建过程，也不能太大，否则会是线程池长期处于满空闲状态，导致资源浪费，默认值为60s。 runnableTaskQueue（任务队列），设置当线程池慢后的任务等待队列，ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue；PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 RejectedExecutionHandler（饱和策略），当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。JDK提供了四种策略：AbortPolicy：直接抛出异常；CallerRunsPolicy：只用调用者所在线程来运行任务；DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；DiscardPolicy：不处理，丢弃掉；所以我们推荐使用CallerRunsPolicy，保证业务不受严重影响。 当然这些参数具体该设置多少合适呢？在业务初期我们只能靠经验值才设置，但是运行过程中，我们是可以通过一些线程池的监控来做到调优我们的配置的。 顺便了解一下线程池的工作流程： 当核心线程数未满的时候，创新新的线程，当核心线程数慢了之后，新加入的任务会进入队列，当队列慢了后，如果最大核心数未满，则创建新的线程，如果最大核心数也满了，则使用配置的饱和策略来决定怎么处理新加入的线程。 CountDownLatch 记录并等待所有线程执行完毕123456789101112131415//多线程处理 CountDownLatch countDownLatch = new CountDownLatch(stockoutOrderDOs4Update.size());//初始化countDown List&lt;Future&gt; taskResultList = new ArrayList&lt;Future&gt;(); for (StockoutOrderDO orderDO : stockoutOrderDOs4Update) &#123; StockoutOrderStateConvertTask stockoutOrderStateConvertTask = new StockoutOrderStateConvertTask(orderDO, toState, countDownLatch); Future future = taskExecutor.submit(stockoutOrderStateConvertTask); taskResultList.add(future); &#125; try &#123; //等待所有子线程执行完 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; logger.error(\"设置出库单状态异常\", e); &#125; 这里没有使用Executor的execute方法，使用的submit方法，他返回一个future，因为我们期望获取每一个线程执行的结果信息，我们需要统计那些执行失败了，那些执行成功了，方便做整体业务回滚。 通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。其次，我们还可以在submit方法中向外抛出业务异常，通过future.get()捕获异常，并处理异常。 相比循环判断每一个任务的返回结果是否都执行完毕了，通过计数器CountDownLatch来记录任务是否都完毕的方式更加简洁和清晰，性能也会更高一些。 可能会遇到的问题： 之前单线程处理的任务如果一个失败了，整个请求可以通过Spring的事务进行回滚，但是如果多线程处理的话，就无法做到失败回滚，如果业务允许部分失败，可以将失败的任务信息反馈给用户，如果业务上必须具有强原子性，所以需要自己实现回滚逻辑，比如每次把执行成功的和失败的都记录下来，后续统一处理回滚逻辑。 总结：通过本次优化，之前的一直容易出现超时的问题得到了一定的优化，但是期望更高的性能的话，需要优化外部调用方的性能。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Object Mapping in Java","slug":"Java/2016-06-12-object-mapping","date":"2016-06-11T16:00:00.000Z","updated":"2018-11-09T14:22:23.521Z","comments":true,"path":"2016/06/12/Java/2016-06-12-object-mapping/","link":"","permalink":"http://heartaway.cn/2016/06/12/Java/2016-06-12-object-mapping/","excerpt":"","text":"我们在Java代码编写中经常会遇到DO 、DTO之间的对象隐射转换，我们在设计DO、DTO的时候一般会尽量让对象名称、对象属性保持一致，利于属性拷贝，但是现实场景中可能存在一些对象名称不一致、对象类型不一致的情况，不同的拷贝方案，性能与使用场景也可能存在不一样，那么在众多的对象拷贝框架中如何选择合适的使用呢？ 常用对象属性拷贝方法： commons-beanutils 框架中的 BeanUtils commons-beanutils 框架中的 PropertyUtils ModelMapper Cglib中提供的BeanCopier, BulkBean,BeanMap,FastClass/FastMethod Orika Dozer HardCopy，手工硬编码 有人做了一张性能对比图： HardCopy：手工硬编码的方式是基本是效率最高的方式，但是当一个类有几十个属性的时候，代码编写效率低下，而且丑陋，最重要的是，当新扩展一个字段后，往往容易忽略在mapping convert文件中添加相应的属性隐射，给业务带来一定的潜在风险（error-prone）。硬编码并不是一无是处，当对象属性比较固定，且对性能要求非常高的时候，硬编码是最好的选择方案。但是很多Object的 大量属性需要编写Convert方法时，就感觉很浪费时间，有没有更有效率的编写方法呢？当然，我自己写了一个Convert方法生成器（密码: ycag，Console输出，需要复制粘贴），这样就可以大量节省硬编码ModelConvert的时间。 BeanUtils：因为我们项目中最常用的就是Spring-bean，所以最先想到使用属性拷贝的就是Apache的BeanUtils.copyProperties方法。 工作原理：BeanUtils通过反射机制的方式从orig中获取属性信息和属性的可读、可写方法（通过get、set方法，如果属性没有get、set方法，则此属性不会被拷贝），调用orig的get方法获取属性值，将属性值写入dest的对应属性中（使用dest的set方法）。可以看出BeanUtils是严格要求orig、dest必须符合bean规范，有get、set方法，无法完成不同属性名之间的隐射拷贝。 对象类型转换：BeanUtils为了方便对象类型转换，还提供了ConvertUtilsBean类，此类可以注入一系列Converter对象，提供对象的初始值或者其他转换方法，比如设置Integer的默认值为0 或 从Date 类型到long类型，我们在使用过程中一般NULL与0是不一样的，所以不期望对象转换过程中默认设置值，所以会自定义对象类型转换器。由此说明BeanUtils是对属性类型没有强一致性判断的。 对象拷贝深度：待测试。由于大量采用反射机制&amp;严格的参数校验，所以性能较差，不建议使用。 PropertyUtils：PropertyUtils实际上使用的也是beanUtils，但是在初始化的时候就会发现，BeanUtils初始化了ConvertUtilsBean和PropertyUtilsBean，而PropertyUtils只初始化了PropertyUtilsBean，说明PropertyUtils不支持属性类型自动转换的功能(如果类型不同则会抛出异常)，而BeanUtils支持属性类型自动转换的功能，这也是两者的区别。 性能上，PropertyUtils 与 BeanUtils稍微好一点。 ModelMapper：ModelMapper能用更加紧凑的代码对Java对象进行映射，在更简单的情况下甚至可以实现零配置。它支持以下特性： 基于名称的对象属性映射 复制公开的、受保护的和私有的字段 略过某些字段 可用转换器来影响映射（如将字符串转换为小写） 在不同类型的字段间进行映射（如将字符串转换为数字） 采用不同的条件进行映射 默认条件不充分时采用松散的映射策略 对映射过程进行验证以确保所有字段都被处理 对特殊情况下的映射过程进行完全可定制化的控制 与Guice或Spring集成 Cglib：BeanCopier参考：http://agapple.iteye.com/blog/799827，据说性能比BeanUtils优一个数量级以上，但是其提供的功能也比较简单。 Orika：Github中的源码：https://github.com/orika-mapper/orika基于生成字节码的方式进行属性映射，是目前出了硬编码外性能最好的一款Object mapping工具，他比ModelMapper占用的内存会稍微多一点，空间换时间，这也符合计算机规律。不足时文档较少，API看起来有一些混乱，支持的特性不较少，其次一些属性的注册使用的是“弱类型”，当属性名称变更时容易被忽略（error-prone）。 Dozer：虽然Dozer提供了丰富的特性支持，但是由于其性能较差，所以这里就不做介绍。除了以上介绍的几种之外还有一些其他的Object mapping工具类，比如 mapping4java、GeDA等。 总结：根据自己的需求选择一款合适且性能优雅的框架，如果觉得没有合适的，当然在时间和精力允许的情况下自己也可以去造一个轮子。 参考：https://prezi.com/q7pd1ad2spro/copy-of-object-mapping-in-java/ http://stackoverflow.com/questions/1432764/any-tool-for-java-object-to-object-mapping http://agapple.iteye.com/blog/1075671","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Wireshark监控分析Https的交互过程","slug":"Basic/2016-06-06-https-with-wireshark","date":"2016-06-05T16:00:00.000Z","updated":"2018-11-09T14:16:54.504Z","comments":true,"path":"2016/06/06/Basic/2016-06-06-https-with-wireshark/","link":"","permalink":"http://heartaway.cn/2016/06/06/Basic/2016-06-06-https-with-wireshark/","excerpt":"","text":"首先介绍一下Https在Client与Server之间的理论交互过程： 试想，我们期望在网络中传输的数据是被加密的，并且这个数据包在客户端和服务器端都能进行加密和解密，那么需要对称加密算法，客户端和服务端都需要有一个加解密Key（对称加密），对数据包进行加解密，那么这个Key如何产生并在在网络中安全的传递呢？假设这秘钥是有服务端产生，分配给客户端，为了保证安全，需要在派送Key的过程中进行加密，那么客户端在一无所知的情况下，是无法打开这个加密的数据包的，此方案不行。假设我们引入非对称加密算法，把公钥在网络上传输(传给客户端)，私钥只保留在服务端，让客户端生成一个加密Key，并把加密Key通过公钥进行加密，加密后的数据发送给服务端，服务端使用私钥解开数据，提取加密Key，这样服务端和客户端以后的交互都可以使用这个加密Key进行数据交互了。 这个过程可以参考：http://www.jianshu.com/p/15703d8c34e9 抓包监控分析：首先安装抓包工具Wireshark(最新版为2.0.3)，Mac OS 10.11版本还需要安装X11，OS X 不再随附 X11，但 XQuartz 项目提供适用于 OS X 的 X11 服务器和客户端库，所以需要下载 XQuartz。打开Wireshark &gt; 捕获 &gt; 选项，选择 本地网卡，开启监控数据捕获。这里以腾讯云 https://www.dnspod.cn 为例（首次打开此网站，所以可以捕获到证书获取流程），由于本地有很多其他的应用都会进行网络请求，为排除干扰，查询了腾讯云（https://www.dnspod.cn ）的IP地址：59.37.116.101，然后在Wireshark 的过滤器中输入： 1ip.src==59.37.116.101 or ip.dst==59.37.116.101 表示只监控IP的起始地或者目的地为腾讯云的数据请求，如图所示： 当然，这里还是可能会有其他tcp流的干扰，找到一个Client Hello 的tcp请求，查看Transmission Control Protool,找到Stream Index 序号，这个Stream Index 是Wireshark标识一次完整的TCP通讯。 所以，调整我们的过滤器为： 1ip.src==59.37.116.101 or ip.dst==59.37.116.101 and tcp.stream eq 28 1. 三次握手建立TCP链接：从请求流中，我们可以清晰的看到在建立TLS请求之前，进行了三次TCP请求，这就是我们常说的TCP建立连接的“三次握手”： 第一次握手：客户端请求建立连接（Flags=SYN，Seq = 0 ）： SYN标识初始化连接，序列号这里为0，注意括号里面的备注，说0是相对序列号，并不是真正的实际序列号，相对序列号只是方便我们查看。 第二次握手：服务端发送确认建立连接数据包给客户端（Flags=SYN，ACK，seqNum=0,ackNum=1）： 第三次握手：客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1 当然还可以通过WireShark自带的统计图形工具查看链接交互过程： 有关TCP建立链接和释放连接的过程，可以参考：TCP/IP 之 大明王朝邮差 2. Client Hello： 我们可以看到，从浏览器发出的第一个字节为0×16（十进制的22），它表示了这是一个“握手”记录。 整个握手记录被拆分为数条信息，其中第一条就是我们的客户端问候（Client Hello），即0×01。在客户端问候中，有几个需要着重注意的地方： 随机数（Random）： 在客户端问候中，有四个字节以Unix时间格式记录了客户端的协调世界时间（UTC）。协调世界时间是从1970年1月1日开始到当前时刻所经历的秒数。在这个例子中，a1 60 cf bd 就是协调世界时间。在他后面有28字节的随机数，在后面的过程中我们会用到这个随机数。 SID（Session ID）： 数（Random）：如果出于某种原因，对话中断，就需要重新握手。为了避免重新握手而造成的访问效率低下，这时候引入了session ID的概念， session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。 在这里，SID是一个空值（Null）。说明我们是第一次访问这个网站，如果我们在几秒钟之前就登陆过了www.baidu.com，我们有可能会恢复之前的会话，从而避免一个完整的握手过程。 session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。后面关于https优化部分会着重介绍session ticket。 密文族（Cipher Suites）： 密文族是浏览器所支持的加密算法的清单。RFC2246中建议了很多中组合，一般写法是”密钥交换算法-对称加密算法-哈希算法，以“TLS_RSA_WITH_AES_256_CBC_SHA”为例，TLS为协议，RSA为密钥交换的算法，AES_256_CBC是对称加密算法（其中256是密钥长度，CBC是分组方式），SHA是哈希的算法。浏览器支持的加密算法一般会比较多，而服务端会根据自身的业务情况选择比较适合的加密组合发给客户端。（比如综合安全性以及速度、性能等因素） Server_name扩展： 当我们去访问一个站点时，一定是先通过DNS解析出站点对应的ip地址，通过ip地址来访问站点，由于很多时候一个ip地址是给很多的站点公用，因此如果没有server_name这个字段，server是无法给与客户端相应的数字证书的，Server_name扩展则允许服务器对浏览器的请求授予相对应的证书。 3. Server Hello 服务器在收到client hello协议的握手请求后，会先回复一个ACK，标识client hello握手数据包收到了，然后向客户端发送Server hello协议数据包，这个协议包里面包含了Session ID,Cipher Suite,Random 等数据。 我们记得在client hello里面，客户端给出了21种加密族，而在我们所提供的21个加密族中，服务端挑选了“TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”。这就意味着服务端会使用ECDHE-RSA算法进行密钥交换，通过AES_128_GCM对称加密算法来加密数据，利用SHA256哈希算法来确保数据完整性 。 服务端对于session ID一般会有三种选择： 恢复的session ID：我们之前在client hello里面已经提到，如果client hello里面的session ID在服务端有缓存，服务端会尝试恢复这个session； 新的session ID：这里又分两种情况，第一种是client hello里面的session ID是空值，此时服务端会给客户端一个新的session ID，第二种是client hello里面的session ID此服务器并没有找到对应的缓存，此时也会回一个新的session ID给客户端； NULL：服务端不希望此session被恢复，因此session ID为空。 4. Certificate 我们知道为了安全的将公钥发给客户端，服务端会把公钥放入数字证书中并发给客户端（数字证书可以自签发，但是一般为了保证安全会有一个专门的CA机构签发），所以这个报文就是数字证书，3259 byte 就是证书的长度。 其次，服务端还向客户端发送了协议为Server Hello Done的报文，意思是告诉客户端hello结束，并且不要求验证客户端的证书。（我们知道TLS协议中验证证书可以是双向的，即服务端也要验证客户端的身份来防止客户端的伪冒，但是这种场景在一般基于web的https中很少(通过U盾的网银是例外，U盾其实就是客户端证书，但这样也非常繁琐)，因为基于web的应用客户数量大，很难为每个客户去提供相应的数字证书。但是对于一些企业之间的对接，出于安全考虑，很多情况下会采用双向认证的方式，因为对于两个企业来说也不存在client、server端的说法。） 5. 客户端验证证书当客户端收到服务器发来的证书后会进行校验来确保证书是真实的服务器发来的，那么如何验证其真实性呢？主要靠的就是数字签名。algorithmIdentifier（签名的加密算法）为：SHA_RSA（注意这里的加密算法是证书中自带的，并非我们之间client、server里面的Cipher Suites中的算法，Cipher Suites中的算法只有密钥交换算法、对称数据加密算法、校验完整性的哈希算法，不包括相关签名的算法），而下方的encrypted部分就是数字签名，是由CA的私钥加密的，数字证书制作这块前面一篇文章已经介绍过了，这里就不多说了。客户端收到数字证书中的数字签名后，由于证书的签名都是由上一级来完成的，因此会利用上一级证书提供的公钥进行解密，解密后得到签名值和自己再次哈希证书主题的值进行比对，如果两个值是一致的话，则认证通过。 6. Client Key Exchange客户端验证通过证书后，客户端将采用服务器给出的加密算法以及公钥将后面用于加密数据的对称密钥进行加密并发送给服务器。其实密钥交换这步远没有想象中的那么简单，主要有以下几个步骤（以下为RSA算法密钥交换的过程，腾讯云用的密钥交换算法为ECDHE-RSA，比RSA更为复杂，这里就先介绍RSA算法）： 客户端生成premaster_secret，首先对称密钥为了保证安全一定是随机密钥，一般的系统或者浏览器都会构建它自己的伪随机数发生器，之所以称之为伪随机数是因为真正意义上的随机数算法并不存在，这些函数还是利用大量的时变、量变参数来通过复杂的运算生成相对意义上的随机数，但是这些数之间还是存在统计学规律的，只是想要找到生成随机数的过程并不那么容易。在进行密钥交换的时候，客户端会利用server hello里面带的随机数2（client hello里面的随机数我们称为随机数1，这是为了方面后面master_secret）生成premaster_secret，premaster_secret长度为48个字节，前2个字节是协议版本号，剩下的46个字节填充随机数。 注意，对称加密不会直接用这个premaster_secret进行加密。因为这个premaster_secret完全由客户端来提供，完成没有服务端的相关信息的参与，因此客户端会利用premaster_secret生成master_secret，然后再用master_secret生成对称密钥算法、MAC 算法的密钥。 master_secret =PRF(pre_master_secret, “master secret”, ClientHello.random +ServerHello.random) pre_master_secret就是我们之前传送的随机密码串，”mastersecret”是一串ASCII码，再加上之前提到的random1和random2。PRF是在规范中约定的伪随机函数，它将密钥、ASCII码标签、哈希值整合在一起。各有一半的参数分别使用MD5和SHA-1获取哈希值。这是一种十分明智的做法，即使是想要单单破解相对简单MD5和SHA-1也不是那么容易的事情。而且这个函数会将返回值传给自身直至迭代到我们需要的位数。关于PRF的具体细节问题 客户端得到master_secret后，根据协议约定，我们需要利用PRF生成这个会话中所需要的各种密钥，称之为“密钥块”（key block），密钥块用于构成以下密钥：client_write_MAC_secret、server_write_MAC_secret （MAC 算法的密钥）client_write_key、server_write_key （对称算法密钥or会话密钥）client_write_IV、server _write_IV （初始化向量，运用于分组对称加密，如果mode是CBC则需要这个值，这个后面降到算法那篇会重点介绍）以上的6个密钥都是通过PRF运算出来的，具体的运算方法比较复杂，后面讲到算法那张会单独介绍。 至此，经过前几步客户端已经完成了相关密钥的生成。此时客户端通过证书中的服务端的公钥将premaster_secret加密后发给服务端，如下图报文中的Client Key Exchange，通过RSA非对称密钥算法利用数字证书中获得的公钥将premaster加密发给服务端。（这里是一个RSA作为密钥交换算法的报文，需要注意腾讯云我们从server-hello中就知道了腾讯云用了更为复杂的ECDHE_RSA算法用于密钥交换算法，所以我们在访问腾讯云的同样的报文中看到的EC Diffie-Hellman Client Params的算法。） 在发送Client Key Exchange报文的同时，客户端还会回一个Change Cipher Spec的报文（如上图），意思就是通知服务端后续报文将采用协商好的密钥和加密套件进行加密和 MAC计算。 最后，客户端计算已交互的握手消息（除 Change Cipher Spec 消息外所有已交互的消息）的 Hash值，通过前面生成的密钥client_write_MAC_secret对hash值进行加密得到MAC，并通过HandShake Messag报文发送给服务端（如上图）。 服务端此时会收到一个premaster_secret，以及一个客户端发来的MAC。利用Change Cipher Spec报文中协商好的密钥和算法，服务端也会计算出用于加密的数据的密钥以及MAC的加密密钥。此时服务端会用利用同样的方法计算已交互的握手消息的 Hash 值，并用client_write_MAC_secret解密客户端发来的MAC，两者进行比较，如果二者相同，且 MAC值验证成功，则证明服务端密钥交换协商成功。 当服务端密钥交换协商成功的同时，会同样回客户端一个Change Cipher Spec报文（如上图），通知客户端后续报文将采用协商好的密钥和加密套件进行加密和 MAC计算。（注意，这个报文前面还有一个New Session Ticket的报文，这个是百度对于https的优化之一，后面会详细讲，在最为基础的https连接中是没有这个报文的。） 同样服务端也会计算已交互的握手消息的 Hash值，通过前面生成的密钥server_write_MAC_secret对hash值进行加密得到MAC，并通过HandShake Message报文（如上图）发送给客户端。 由于客户端在发送消息给服务端前就已经计算出了数据加密的对此密钥，因此只需要验证服务端返回的MAC即可，所以此时客户端端会用利用同样的方法计算已交互的握手消息的 Hash 值，并用server_write_MAC_secret解密服务端发来的MAC，两者进行比较，如果二者相同，且 MAC值验证成功，则证明客户端密钥交换协商成功。 至此，整个密钥交换的协商全部完成，开始传输应用层的数据。 7. 数据传输经过之前6大步骤，SSL的连接建立完成，开始有客户端发起Application Data，实际上下图中的encrypted application data就是http协议的数据经过client_write_key、server_write_key进行加密后的传输，我们通过一些工具解密后，发现应用层实际就是标准的http协议，也就是说SSL实际上就是在http协议外面套了层壳 请求链路分析文件（可直接通过wireshark打开）：http://pan.baidu.com/s/1hsi5U4W 参考链接：http://www.jianshu.com/p/a766bbf31417 http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html","categories":[{"name":"Basic","slug":"Basic","permalink":"http://heartaway.cn/categories/Basic/"}],"tags":[]},{"title":"Redis连接池的相关问题分析与总结","slug":"Redis/2016-06-02-redis-conn-pool","date":"2016-06-01T16:00:00.000Z","updated":"2018-11-09T14:27:46.883Z","comments":true,"path":"2016/06/02/Redis/2016-06-02-redis-conn-pool/","link":"","permalink":"http://heartaway.cn/2016/06/02/Redis/2016-06-02-redis-conn-pool/","excerpt":"","text":"问题表象：服务端连接未释放 问题背景：商品系统在运行过程中发生过一次Redis服务端连接数超限的问题。截图未保存，表现是：商品服务停掉，但RedisServer端看到的TCP连接任然存在，而且是 ESTABLISHED状态，导致的直接结果就是每次商品重启都会创建400个（minIdle=400）新的redis连接，而且停止的时候还不释放，重启几次之后RedisServer的连接就超过上限10000，无法再创建新的连接。 一、初步分析： TCP是可靠协议，断开是需要经过4次挥手，既然服务端的连接未释放，那十之八九是客户端没有发送断开请求； 即使客户端没有主动断开连接，但是这个连接实际上已经失效了，RedisServer为啥没有自动检测，而一直没有释放？ 二、定位与排查过程：问题一的分析： 首先怀疑的点是商品在停止的时候没有释放Jedis的连接，所以赶紧把JedisCluster的代码看了，果然有个close方法： 1234567891011121314@Overridepublic void close() throws IOException &#123; if (connectionHandler != null) &#123; for (JedisPool pool : connectionHandler.getNodes().values()) &#123; try &#123; if (pool != null) &#123; pool.destroy(); &#125; &#125; catch (Exception e) &#123; // pass &#125; &#125; &#125;&#125; 直接把这个方法注册到spring的destroy-method中： ​​​​​​​在性能测试环境上重新做下实现，发现此方法一直没有被调用，不解，看了下spring源码，调用destroy-method的触机有两个： 显示的调用org.springframework.context.support.AbstractApplicationContext.close()方法； 显示的调用org.springframework.context.support.AbstractApplicationContext.registerShutdownHook()，这样在程序正常停止的时候（kill，非kill -9 ）就可以触发shutdownHook的调用： 123456789101112public void registerShutdownHook() &#123; if (this.shutdownHook == null) &#123; // No shutdown hook registered yet. this.shutdownHook = new Thread() &#123; @Override public void run() &#123; doClose(); &#125; &#125;; Runtime.getRuntime().addShutdownHook(this.shutdownHook); &#125;&#125; check了我们的应用代码，这两个调用我们都没有做，所以如果需要触发Spring的destroy-method需要在想想办法。因为我们线上服务都是通过dubbo的Main启动，dubbo监管了Spring容器的生命周期管理，看看Dubbo的代码：(com.alibaba.dubbo.container.Main) 12345678910111213141516171819202122232425if(\"true\".equals(System.getProperty(\"dubbo.shutdown.hook\"))) &#123; Runtime.getRuntime().addShutdownHook(new Thread() &#123; public void run() &#123; Iterator i$ = var8.iterator(); while(i$.hasNext()) &#123; Container container = (Container)i$.next(); try &#123; container.stop(); Main.logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\"); &#125; catch (Throwable var6) &#123; Main.logger.error(var6.getMessage(), var6); &#125; Class t = Main.class; synchronized(Main.class) &#123; Main.running = false; Main.class.notify(); &#125; &#125; &#125; &#125;);&#125; 这里发现一段重要代码，如果应用启动的时候指定了-Ddubbo.shutdown.hook=true，就会注册一个钩子函数，在Jvm进程正常停止的时候回触发container.stop()，而这些container中有一个就是com.alibaba.dubbo.container.spring.SpringContainer 123456789101112131415161718192021222324252627282930313233343536public class SpringContainer implements Container &#123; private static final Logger logger = LoggerFactory.getLogger(SpringContainer.class); public static final String SPRING_CONFIG = \"dubbo.spring.config\"; public static final String DEFAULT_SPRING_CONFIG = \"classpath*:META-INF/spring/*.xml\"; static ClassPathXmlApplicationContext context; public SpringContainer() &#123; &#125; public static ClassPathXmlApplicationContext getContext() &#123; return context; &#125; public void start() &#123; String configPath = ConfigUtils.getProperty(\"dubbo.spring.config\"); if(configPath == null || configPath.length() == 0) &#123; configPath = \"classpath*:META-INF/spring/*.xml\"; &#125; context = new ClassPathXmlApplicationContext(configPath.split(\"[,\\s]+\")); context.start(); &#125; public void stop() &#123; try &#123; if(context != null) &#123; context.stop(); context.close(); context = null; &#125; &#125; catch (Throwable var2) &#123; logger.error(var2.getMessage(), var2); &#125; &#125;&#125; springContainer的stop方法就是调用spring-context的close方法，最终会遍历每个bean的destroy-method。找打原因之后修改我们的启动脚本，加上参数：-Ddubbo.shutdown.hook=true，再次实验发现连接正常释放了，至此第一个问题的解决方案找到了，但是根本原因还没有找到，接下来通过抓包方式看能不能发现什么原因。 Redis客户端断开连接，服务端连接未释放的根本原因分析： 这里选用了常用的抓包工具，tcpdump + wireshark（wireshark默认不支持redis协议，网上找了下，github上刚好有个同学共享了一个redis的协议解析插件：http://blog.cheyo.net/257.html，????）选用性能环境测试，在性能环境的RedisServer上抓包，同时监控RedisServier的连接数。 12tcpdump -nnnvvv -s0 -X port 6379 and host 10.163.242.152 -i eth0 -w xxx.wap netstat -anp |grep ’10.163.242.152’ | wc -l 然后启动商品服务和停止商品服务，抓包观察。 我在做实现的时候搞个两个JedisCuster实例，每个实例的初始连接数（minIdle）都是1，有个实例注册了destroy-method，另一个实例未注册。 第一个网络包是商品服务的启动过程，6个TCP包，报内容就是简单的TCP3次握手，创建了2个TCP链接 第二个网络包是商品服务的停止过程，这里有看出区别了：第一个JedisCluster实例在结束的时候调用close命令，向RedisServe端发送了Quit指令，RedisServer返回OK。然后RedisServer主动发送FIN包，请求关闭连接，客户端ACK响应，然后客户端直接发送RST中断连接，这确保了服务端RedisServer可以断开连接。另一个JedisClsuter就直接给RedisServer发送一个RST，然后就没了。 这里面有两个疑问？ (1). 为什么客户端没有遵循TCP的4次回收规范直接发送RST包中断连接？ (2).我们线上这么长时间都没有配置JedisCluster的close函数，启动脚本也没有配置-Ddubbo.shutdown.hook=true，为啥到现在也发现大问题，除了商品系统触发了？ 先解答(2)的问题，我通过几次实现，发现即使我们什么都不做，直接停止服务，甚至kill -9 JVM线程，Client也会向RedisServer发送RST请求（我猜是OS自己做的，但具体没有再深入，有时间再看），但是并不是每次都发，会偶发性的丢包，一旦丢包，RedisServer就SB了，Client端私自把连接关闭了，然Server端却不知道，所以连接一直保持。 kill -9的网络包: 再看(1)的问题，为啥调用close的情况下Client还是给Server端返回RST包呢。查看了JedisCluser的源码，找到了原因： redis.clients.jedis.Connection#connect 1234567891011socket = new Socket();// -&gt;@wjw_addsocket.setReuseAddress(true);socket.setKeepAlive(true); // Will monitor the TCP connection is// validsocket.setTcpNoDelay(true); // Socket buffer Whetherclosed, to// ensure timely delivery of datasocket.setSoLinger(true, 0); // Control calls close () method,// the underlying socket is closed// immediately// &lt;-@wjw_add Jedis在创建Socket连接的时候配置了一个参数：socket.setSoLinger(true, 0); 这个参数的作用就是：在此socket调用close方法的时候不发送FIN包，而是直接发送RST包。 为什么Jedis要特意这么做呢？ 简单来说就是TCP是一个可靠消息，而且TCP的4次挥手过程中存在一个半关闭状态，过程比较纠结： 『假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说“我Client端没有数据要发给你了“，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息“。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了“。Client端收到FIN报文后，“就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了“。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！』 TCP建立连接与释放链接的流程： 总结：​ 一句话，就是TCP的正常关闭比较磨叽，而且会导致大量存在TIME-WAIT状态的连接。相对来说RST包就比较粗暴，直接告诉你『我要关闭连接了，老子不给你发数据，也不接收你的数据，你看着办吧』，然后自己就GG了。所以看Jedis的注释： 123Control calls close () method,// the underlying socket is closed// immediately 关于RST的这个问题大家可以参考一下两个文章： http://xiaoz5919.iteye.com/blog/1685138（看评论） http://docs.oracle.com/javase/1.5.0/docs/guide/net/articles/connection](http://docs.oracle.com/javase/1.5.0/docs/guide/net/articles/connection)（解释的很好，建议深读） 至此第一个问题『因为TCP是可靠协议，断开是需要经过4次挥手，既然服务端的连接未释放，那十之八九是客户端没有发送断开请求』的根本原因基本调查清楚了，解决方案是在JVM加上启动参数：Ddubbo.shutdown.hook=true 问题二的分析：接下来再看第二个问题『即使客户端没有主动断开连接，但是这个连接实际上已经失效了，RedisServer为啥没有自动检测，而一直没有释放？』，而且第二个问题还引发了上周我们线上的另一个问题。 在商品系统出现连接未释放的问题之后，我紧急求救了啊泉，啊泉凭靠自身多年的运维经验很快反应这是RedisServe的一个配置的问题： 12# Close the connection after a client is idle for N seconds (0 to disable)timeout 0 这个配置的意思是：RedisServer会自动关闭超过N seconds时间的idel连接，如果配置0那就是用不关闭。（我们现在所有的集群都是默认0）。啊泉当机立断，改成600。过了一会，Server端连接全部释放，应用恢复正常。 本来故事当这里就应圆满结束了，然后面几周却不消停，最初从财务系统开始，到订单系统、积分系统都开始偶发性报Jedis错误： 还有商品系统一天到晚都偶发性报错：（部分原因可能是mget的原因) 1redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException: Too many Cluster redirections? 我们Check了下财务、订单、积分公用的Redis集群，除了内存使用量增长之外（单机超过1.3G），其他并无任何异常，初步猜想『这个Redis集群撑不住了』？拆，第二天就把购物车的Redis-DB拆出来了，但是错误依旧。难道还是内存的问题，当晚又把新的Redis-DB的key清理了下，把不用的key全删了，把使用内存降到350M左右。 公共Redis-DB的内存： 购物车的Redis-DB的内存： 然降了内存之后错误依旧，SB了。中间翔把jedis的连接超时和请求超时时间都配置成20s，ms也解决了问题。但是我们讨论下来，这不是一个好的解决方案，这是饮鸩止渴的法子。我们需要从源头找问题，通过翻查资料和源码，初步判断是Client和Server的连接出了问题，感觉像是Jedis用了一个坏的连接去请求数据，然后Server端异常返回。Jedis官方有个贴了很详细的讨论了这个问题： https://github.com/xetorthio/jedis/issues/965。这篇文章很长，结论就是这个问题一般是RedisServer的连接坏了引发了的，坏了有几种可能：1. 网络抖动，连接失效。2. RedisServer这端主动关闭了，然Client端不知道（网络丢包）。所以解决方案有两个： RedisServer端配置timeout = 0，用不释放连接； Client需要定时检测和清理死链； 我们目前采用的解决方式是1，2都用了（2是最优解，因为网络环境相对复杂，网络断开的情况时有发生，所以客户端需要有检测死链的机制）。1的相关配置如下，主要有两个重要参数： 1234567891011121314151617181920212223242526private JedisPoolConfig getJedisPoolConfig(int redisMaxTotal, int redisMinIdle, int redisMaxWaitTime, int redisMaxIdle, boolean redisTestOnBorrow) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //最大连接数, 默认20个 poolConfig.setMaxTotal(redisMaxTotal); //最小空闲连接数, 默认0 poolConfig.setMinIdle(redisMinIdle); //获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted), 如果超时就抛异常, 小于零:阻塞不确定的时间, 默认 - 1 poolConfig.setMaxWaitMillis(redisMaxWaitTime); //最大空闲连接数, 默认20个 poolConfig.setMaxIdle(redisMaxIdle); //在获取连接的时候检查有效性, 默认false poolConfig.setTestOnBorrow(redisTestOnBorrow); poolConfig.setTestOnReturn(Boolean.FALSE); //在空闲时检查有效性, 默认false poolConfig.setTestWhileIdle(Boolean.TRUE); //逐出连接的最小空闲时间 默认1800000毫秒(30分钟) poolConfig.setMinEvictableIdleTimeMillis(1800000); //每次逐出检查时 逐出的最大数目 如果为负数就是: idleObjects.size / abs(n), 默认3 poolConfig.setNumTestsPerEvictionRun(3); //对象空闲多久后逐出, 当空闲时间 &gt; 该值 且 空闲连接&gt;最大空闲数 时直接逐出, 不再根据MinEvictableIdleTimeMillis判断 (默认逐出策略) poolConfig.setSoftMinEvictableIdleTimeMillis(1800000); //逐出扫描的时间间隔(毫秒) 如果为负数, 则不运行逐出线程, 默认 - 1 poolConfig.setTimeBetweenEvictionRunsMillis(60000); return poolConfig;&#125; 配置这两个参数之后问题解决，且商品也不报错了，至此这两个问题算是解决了。 问题总结：客户端与服务端之间的连接问题，可能存在客户端断开了连接服务端不知晓、服务端断开了连接客户端不知晓，为了解决这两个问题，需要做的就是服务端和客户端定期检查，客户端通过setTestWhileIdle(Boolean.True)、setTimeBetweenEvictionRunsMillis(xxx) 来定期检查方式死链；服务端通过设置超时时间来做到检查连接的问题。 后续：昨晚看VIP的运维分享，他们不建议RedisServer端的timeout配置成0，同样一个原因，网络异常的情况不可避免（或者应用端Kill -9），所以Server端同样需要有检查和清理死链的能力。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://heartaway.cn/categories/Redis/"}],"tags":[]},{"title":"计算Java方法执行时间","slug":"Java/2016-05-31-java-method-cost-time","date":"2016-05-30T16:00:00.000Z","updated":"2018-11-09T14:34:49.217Z","comments":true,"path":"2016/05/31/Java/2016-05-31-java-method-cost-time/","link":"","permalink":"http://heartaway.cn/2016/05/31/Java/2016-05-31-java-method-cost-time/","excerpt":"","text":"我们在对系统进行性能调优的时候，很多时候都会统计接口的调用时间或者内部方法的执行时间来查看具体的性能瓶颈点。 编码式一般比较简单的左右是在方法开始和结束的时候分别添加时间记录方法： 1234long startTimeMillis = System.currentTimeMillis()…..long endTimeMillis = System.currentTimeMillis()long spendTime = endTimeMillis - startTimeMillis; StopWatch当然你可以可以通过Apache-Commons工具包中的工具类： 1org.apache.commons.lang3.time.StopWatch StopWatch 底层也是采用的System.currentTimeMillis()进行时间统计，使用StopWatch的优点： 封装好了基本的时间统计方法，你直接在方法开始和结束的时候调用一次就好了，使用简单； 他还提供了时间统计挂起、恢复和复位等功能，这点通过方法一是无法实现的； 使用StopWatch的弊端： 会抛出IllegalStateException或者RuntimeException异常，这点使用者如果不进行封装容易引起业务异常。一般我们不期望一个测试性能的代码影响到了正常的业务逻辑； 使用Spring AOP方式：示例如下： 12345678910111213141516171819202122232425262728293031public class MethodTimeActive implements MethodInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(MethodTimeActive.class); /** * 自定义map集合，key：方法名，value：[0：运行次数，1：总时间] */ public static Map&lt;String, Long[]&gt; methodTest = new HashMap&lt;String, Long[]&gt;(); @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; StopWatch watch = new StopWatch(); watch.start(); Object object = methodInvocation.proceed(); watch.stop(); String methodName = methodInvocation.getMethod().getName(); Long time = watch.getTime(); if (methodTest.containsKey(methodName)) &#123; Long[] x = methodTest.get(methodName); x[0]++; x[1] += time; logger.info(\"MethodTime _method=\" + methodName + \" _totalCount=\" + x[0] + \" _totalTime=\" + x[1] + \" ms _avgTime=\" + x[1] / x[0] + \"ms\"); &#125; else &#123; methodTest.put(methodName, new Long[]&#123;1L, time&#125;); logger.info(\"MethodTime _method=\" + methodName + \" _totalCount=1 _totalTime=\" + time + \"ms _avgTime=\" + time + \"ms\"); &#125; return object; &#125;&#125; 定义方法拦截器 spring-context 中对待监控的服务和方法进行配置（通过AOP的代理bean代理需要被检测的bean对象）： 12345678910111213141516171819202122&lt;bean id=\"venderSpuService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt; &lt;property name=\"target\" ref=\"venderSpuServiceImpl\"/&gt; &lt;property name=\"interceptorNames\"&gt; &lt;list&gt; &lt;value&gt;spuServiceAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"methodTimeActive\" class=\"com.sfebiz.vender.util.MethodTimeActive\"/&gt; &lt;bean id=\"spuServiceAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\"&gt; &lt;property name=\"mappedNames\"&gt; &lt;list&gt; &lt;value&gt;querySpuByProvider4Page&lt;/value&gt; &lt;value&gt;querySpuByVSpuId&lt;/value&gt; &lt;value&gt;stashSpu&lt;/value&gt; &lt;value&gt;commitSpu&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"advice\" ref=\"methodTimeActive\"/&gt; &lt;/bean&gt; 需要maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.6&lt;/version&gt;&lt;/dependency&gt; 遇到的问题： 通过AOP统计到的方法耗时，发现每次API调用打印了次接口调用，具体为什么还没有时间去排查。 其它： 如果裸露的使用System.currentTimeMillis()在高并发场景下也会带来一定的耗时，因为每一个请求都会进行一次系统交互，可以通过内存缓存的方式定时更新当前时间，这样虽然性能提高了，但是可能导致统计的时间不够准确。 如果期望使用System.currentTimeMillis()获取高精度的时间，可能需要注意了，因为System.currentTimeMillis()调用的还native方法，有依赖于操作系统。 使用AOP代理服务于原始服务的性能差异还需要进行测试，所以目前还不太敢在生产环境上使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"微微拼车给我们的反思","slug":"Think/2016-05-28-weiwei-car-think","date":"2016-05-27T16:00:00.000Z","updated":"2018-11-09T14:30:03.770Z","comments":true,"path":"2016/05/28/Think/2016-05-28-weiwei-car-think/","link":"","permalink":"http://heartaway.cn/2016/05/28/Think/2016-05-28-weiwei-car-think/","excerpt":"","text":"每个团队的成功都有成功的因素，但是失败更能让我们认清自我，知道什么可行，什么不行，选择什么，放弃什么。 老总王永通过自身多年沉淀的人脉迅速打开市场，但是一段时间每天系统宕机三四次的高不可用性，损害了用户体验，高获客成本下，用户的流式想必也非常严重。这点在我们公司也出现了N多次，我们的VIP用户都对每次活动必挂习以为常，但是市场部花钱买来的流量、运营部熬夜制作的专场活动就这样一次次成了炮灰，机会就一次次从指间流失。为此我们专门成立了稳定性小组、架构组，展开了一次次全链路压测。但这还是一些场景考虑不到，导致短板效应。系统稳定性直接影响的是用户体验，这“用户体验”不可忽视，别把用户当傻子，用户比你想的要聪明的多，不耐烦的多。 资本是药，也是鸩。 被资本绑架或者资本过剩都不是好事情。王永获得到资本支持后，大量通过烧钱模式获取用户和市场，这种模式称为猪模式，有钱谁不会花呢？在2011年疯狂烧钱的团购战场，目前货到现在的有几家呢？烧钱没有错，现在没有不少钱的公司，但是不能活活把自己烧死还不知道转变模式。企业不盈利就是最大的恶，烧钱之后需要从另一方面把这部分钱赚回来，让企业处于良性健康的状态才是可持续发展之路。很多企业在拿到投资之后就混了头，追求高工资、高享受，性格随之变得傲慢不堪，往往正式这些会在关键时刻让你走向灭亡。当然我们也不例外，我们烧钱请明星做广告，部分人高薪，但是不提供同等价值，团队内部开始眼红和“内耗（外部看的，且不可当真）”，大量采买商品，动销率低，导致占用大量资金，现金流告急。这些并没有绝对的对与错，只是人性，那个饥寒交迫的人能抵抗住玉盘珍馐的诱惑呢？资本只会是锦上添花，绝不会雪中送炭。让你膨胀的资金，让你饿死的也是资金。 练好内功，抵挡严寒。企业发展一定需要能够看到远方的人，需要知道怎么在湍急的溪流中保护自我并能最快达到终点的人，需要懂中国市场行情懂企业战略的人。中国的互联网，基本大家都会有一个意识，“假如你被腾讯抄袭了怎么办？”王总应该是能思考到这一点的，也许思考到了还没来得及掉头已撞击冰山。拼车服务的价值大家都非常认可，但是市场大竞争也大，Uber、滴滴、快递、顺风车等企业迅速崛起，不及时找到适合自己的发展之路，跟巨头硬碰硬，等待的只有死亡。 管理失控。 核心团队的能力部分决定了公司的氛围和气味，核心团队一定需要创业者心态，以打工心态的职业经理人靠不住。企业发展无论什么时候都必须重视内部管理，一点都不可松懈，因为创业初期大家的目标都是业务，业务高速发展过程中会积累下来种种的问题，如果不能及时消除这些问题，这些因素就会成为埋藏的定时炸弹，早晚会让你尝这个债。及时把企业发展的利于与员工利益绑定在一起，大家聚在一起都是拼一个未来，没有人愿意无偿为你付出，因为他也需要生活，作为老板，也不能一味的要求员工提供免费的剩余价值，是不是的需要给团队一些鼓励，很多人害怕被不重视，害怕付出了没有回报。有人说优秀的团队可以以低于市场价的薪水与企业共同成长，但是大家也是有前提的，要么是企业与个人已经完成了利益绑定，大家拼的是一个未来，要么是积累一些他们认为还有价值的东西，后面选择一个合适的时间离开你。这也是人性，当一个人还在为面包拼搏时，你让他去实现个人理想，太虚、太假了，还不如来一些实际的。怎么推送企业做好团队内部有效管理，提供平等的晋升空间、加薪幅度等，是一个很大的学问。回归到王永的企业管理中，发现CFO只是一个出纳，各分点管理者也只为个人利益掏空公司资金费尽心思，这里面反映了企业招人太过粗糙、管理太过混乱了；很多事情企业发展状态、财务健康程度、用户满意度等CEO竟不知晓，那CEO该干的事情是否履行了呢？太多太多的企业死在公司内耗上面了，这个不足为奇。 微微拼车老板至少还算一个爷们，在拿不到融资的情况下，自己掏钱借钱来处理公司的后事，没有选择跑路，不说值得称赞，至少对得起“企业家”这三个字。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"我为什么开始讨厌加班了？","slug":"Think/2016-05-15-hate-over-work","date":"2016-05-14T16:00:00.000Z","updated":"2018-11-09T14:30:27.595Z","comments":true,"path":"2016/05/15/Think/2016-05-15-hate-over-work/","link":"","permalink":"http://heartaway.cn/2016/05/15/Think/2016-05-15-hate-over-work/","excerpt":"","text":"从阿里离职之后来到丰趣海淘的这一年，是我加班最多的一年，一周连续通宵，每天3点才能睡觉，一周工作七天，这样的日子也许只有创业初期的那股激情才能让我坚持下来。当时的思维方式是，为什么要把自己大把的时间浪费在跟家人聊天，跟朋友聚会或者无聊的睡觉上面呢，时间太宝贵了，需要用来为公司创造价值，让产品早日能在市场上有一定机会。 当然年轻人确实是需要拼劲和能够吃苦，互联网讲究的是为快不破，老板们也是挥舞着皮鞭，快点，快点，再快点。我无数次因为把时间都花在了工作上导致家庭矛盾，无数次因为太投入工作而忘记了吃饭，好几次劳累过度而身染疾病。在辗转沪杭两地的路途中，几次感觉自己因为劳累快要撑不下去了。一切的付出，当年的回报是没有年终奖，第二年的付出也与每天按时下班的人一样。想想确实挺悲哀的，当付出与回报严重不成正比的时候，是非常打击人的士气的。我每天多加5个小时的班只是为了年终多拿1个月的工资？如果是为了这个目的，为什么不把这5个小时花在提升自身能力上面呢，个人价值的提升比一个月的工资奖金更持久。所以，我现在学会了选择，选择我自己的方式工作和生活，不为讨好老板，不为五斗米折腰。 最近企业内部氛围的气味很不正常，很多人似乎都抱着能干就干不能干就走人的态度在做事情。其实这种环境不是自下而上的，而是由老板们决定的，但是似乎管理者并没有意识到这个问题，他们认为底层员工出问题了，消极怠工，不愿意加班，并且还提出了狼性文化、精兵制度、甚至裁员等方式。我为这个公司感到悲哀，因为他们太不懂人性，更不懂得管理。你在讲狼性文化的时候，有没有考虑到狼性文化是建立在任性文化的基础之上，有没有为狼性文化建立相应的配套制度？你们似乎一直在漠视员工，反过来责骂员工“冷漠”。你们期望员工无时无刻不在为公司无偿加班，但又不想多为员工付出哪怕跟市场价持平的报酬，你们似乎还在想为什么现在的员工要求的工资越来越高了，能不能找到更廉价的劳动力。对，员工在你们看来只是廉价劳动力，你的看法逐渐让员工从可能有创新精神或者匠工情况的人退化成了单纯的劳动力资源，我也比较讨厌把人作为“资源”来称呼。 如果你把劳动力看作商品，劳动者看作供应商，你就能发现这种糟糕的企业文化的问题了。员工都在竞争稀缺的升职，所以对于员工来说，这并不是一个很糟糕的模式，并且通常在老板没有强迫他们时，他们自己就会这样做。公司，作为消费者，在购物区逛，表示自己想要买条裤子。在那儿，能让她最高兴的服装店在以后都有可能有更多的生意，所以她才能在这个街区傲慢地逛。而为了能够得到她这个生意，所有的商店都在降价跟其他商店竞争。第一家店少 5 美元，第二家店少 6 美元并且送一个T恤。第三家可能会买一赠一，等等。 不久，能够确定的是，这种反向竞标大赛的赢家会丢掉很多钱，也就是通常说的赔本赚吆喝。然而，问题是，我们再转换去看雇佣模式，这种模式下的赢家 5 年每周 60 个小时的工作换取了每年涨 1 万元的工资。供应商为了 公司 损害自己的利益，而她却不耐烦的翘着脚，困惑他们怎么不能再卖的便宜点儿。 这些事件的问题本质并不是 糟糕的企业文化本身，而是现在一天工作 8 个小时竟成为了一个新的原罪。现在的世界推崇这样的企业文化：公司拥有每周工作 60 个小时的空想者，这些人在法老的要求下挥着鞭子强迫劳动人员去建造金字塔，这样的世界这样的文化期待我们对没有额外付出而产生负疚感。多工作成了新的需求，这点已经到了这样的程度： 公司 觉得裁掉不具有特定要求资质的底层 x% 的员工是非常合理的。 我们带着无偿加班的荣誉徽章。睡不够，炫耀着喝了多少咖啡，一天 18 小时接收电话和邮件。我们以多少时间被安排了两倍甚至三倍的工作来衡量自己的重要性，还倒行逆施地认为免费做到这一点是很光荣的事。 那面对被要求加班，怎么办呢？很简单：制止它。别再想着比你身边的人多提供点免费劳动力是很给人留好印象的。当你的公司暗示你每天工作时间应该从 8 个小时增加到 10 个小时的时候，不要因为询问“这对我有什么好处”而感到内疚。不要想着通过每天捐赠额外的 20%-40% 的时间来让自己 5 年内有升职的可能是什么重要的事，这其实是一个很糟糕的时间投资。不要参与进这样糟糕的企业文化。 重新规划你的时间，因为你的时间是你现在最宝贵的财富，远离加班，重新规划自己的时间吧。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"《Spring 技术内幕》之 bean的初始化","slug":"Spring/2016-05-10-spring-bean-init","date":"2016-05-09T16:00:00.000Z","updated":"2018-11-09T14:28:05.121Z","comments":true,"path":"2016/05/10/Spring/2016-05-10-spring-bean-init/","link":"","permalink":"http://heartaway.cn/2016/05/10/Spring/2016-05-10-spring-bean-init/","excerpt":"","text":"BeanFactory：指定IOC容器的基本功能规范； IOC是水桶，那么这个类就定义了水桶的基本功能; BeanDefinition：对依赖反转模式中管理的对象依赖关系的抽象；它就像容器里装的水，有了这些基本数据，容器才能发挥作用； BeanFactory 与 FactoryBean的区别：BeanFactory 是 Factory，也就是IoC 容器或对象的工厂，所有的Bean都是由BeanFactory 来管理的。 FactoryBean 是 bean，但不是一个简单的bean，而是一个能生产或修饰对象生成的工厂bean（工厂模式类似）； 我们可以认为直接的BeanFactory 实现是IoC容器的基本实现，而各种ApplicationContext的实现是IoC容器的高级表现形式。 IoC容器的建立过程:（XmlBeanFactory） 创建IoＣ配置文件的抽象资源，这个抽象资源包含了BeanDefinition 的定义信息 创建BeanFactory（实现类） 创建一个载入BeanDefinition的读取器，然后通过一个回调配置给BeanFactory 从定义好的资源位置读入配置信息。DefaultListableBeanFactory 非常重要的BeanFactory。 IoC容器 的初始化包括 BeanDefinition的Resouce定位、载入和注册这三个基本过程。ResourceLoader，BeanDefinition.三大过程： ① BeanDefinition 的载入和解析② BeanDefinition向 IoC容器中进行注册③ IoC 容器的 依赖注入(bean 在使用时才进行初始化) 整个过程可以理解为是容器的初始化过程。第一个过程是 ApplicationContext 的职责范围，第二步是 BeanFactory的职责范围。 Resource 定义了资源文件 ResourceLoader 对Resource进行加载 12345678910ResourceLoader |__ DefaultResourceLoader . |__ ServletContextResourceLoader/ServletContextResourceLoader/FileSystemResourceLoader . AbstractApplicationContext . |__ AbstractRefreshableConfigApplicationContext . |__ AbstractXmlApplicationContext . |__ 各种 XmlAplicationContext . AbstractRefreshableWebApplicationContext ResourcePatternResolver Cotext 中的构造方法中的 refresh() 代表启动容器，是bean加载和解析的入口。 BeanDefinition 定义了 bean的数据结构 BeanDefinitionReader 是对Bean的加载； 12345BeanDefinitionReader |__ AbstractBeanDefinitionReader |__ PropertiesBeanDefinitionReader XmlBeanDefinitionReader 两大容器体系： BeanFactory 和 ApplicationContext 左边黄色部分是 ApplicationContext 体系继承结构，右边是 BeanFactory 的结构体系,两个结构是典型模板方法设计模式的使用。 从该继承体系可以看出： BeanFactory 是一个 bean 工厂的最基本定义，里面包含了一个 bean 工厂的几个最基本的方法，getBean(…) 、 containsBean(…) 等 ,是一个很纯粹的bean工厂，不关注资源、资源位置、事件等。ApplicationContext 是一个容器的最基本接口定义，它继承了 BeanFactory, 拥有工厂的基本方法。同时继承了ApplicationEventPublisher 、 MessageSource 、 ResourcePatternResolver 等接口，使其 定义了一些额外的功能，如资源、事件等这些额外的功能。 AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory 是两个模板抽象工厂类。AbstractBeanFactory 提供了 bean 工厂的抽象基类，同时提供了 ConfigurableBeanFactory 的完整实现。AbstractAutowireCapableBeanFactory 是继承了 AbstractBeanFactory 的抽象工厂，里面提供了 bean 创建的支持，包括 bean 的创建、依赖注入、检查等等功能，是一个核心的 bean 工厂基类。 ClassPathXmlApplicationContext之 所以拥有 bean 工厂的功能是通过持有一个真正的 bean 工厂DefaultListableBeanFactory 的实例，并通过 代理 该工厂完成。 ClassPathXmlApplicationContext 的初始化过程是对本身容器的初始化同时也是对其持有的DefaultListableBeanFactory 的初始化。 BeanDefinition 的载入包括两部分，首先是通过调用XML 的解析器得到document 对象，但这些document对象 并没有按照Spring 的bean 规则进行解析，在完成通用的XML 解析以后，才是按照Spring 的bean 规则 进行解析的地方，按照Spring的bean 规则进行解析的过程是在 documentReader 中实现的。 具体容器初始化过程如下： 依赖注入是发生在容器中的BeanDefinition 数据已经建立好的前提下进行的。 那么 IoC容器的依赖注入是怎么实现的 ？（getBean()的过程） 在bean 的创建和 对象依赖注入的过程中，需要根据BeanDefinition 中的信息来递归地完成依赖注入。 bean 是在什么时候被创建的，有哪些规则？容器初始化的时候会预先对单例和非延迟加载的对象进行预先初始化(调用 getBean()方法)。其他的都是延迟加载是在第一次调用getBean 的时候被创建。从 DefaultListableBeanFactory 的 preInstantiateSingletons 里可以看到这个规则的实现。 Bean 的创建过程？对于 bean 的创建过程其实都是通过调用工厂的 getBean 方法来完成的。这里面将会完成对构造函数的选择、依赖注入等 GetBean 的大概过程： 先试着从单例缓存对象里获取。 从父容器里取定义，有则由父容器创建。 如果是单例，则走单例对象的创建过程：在 spring 容器里单例对象和非单例对象的创建过程是一样的。都会调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。 不同的是单例对象只创建一次并且需要缓存起来。 DefaultListableBeanFactory 的父类 DefaultSingletonBeanRegistry 提供了对单例对象缓存等支持工作。所以是单例对象的话会调用 DefaultSingletonBeanRegistry 的 getSingleton 方法，它会间接调用AbstractAutowireCapableBeanFactory 的 createBean 方法。如果是 Prototype 多例则直接调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。 doCreateBean 的流程： 会创建一个 BeanWrapper 对象 用于存放实例化对象。 如果没有指定构造函数，会通过反射拿到一个默认的构造函数对象，并赋予beanDefinition.resolvedConstructorOrFactoryMethod 。 调用 spring 的 BeanUtils 的 instantiateClass 方法，通过反射创建对象。 applyMergedBeanDefinitionPostProcessors populateBean(beanName, mbd, instanceWrapper); 根据注入方式进行注入。根据是否有依赖检查进行依赖检查。 initializeBean(beanName, exposedObject, mbd);判断是否实现了 BeanNameAware 、 BeanClassLoaderAware 等 spring 提供的接口，如果实现了，进行默认的注入。同时判断是否实现了 InitializingBean 接口，如果是的话，调用 afterPropertySet 方法。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://heartaway.cn/categories/Spring/"}],"tags":[]},{"title":"怎么编写用户注册/登录服务","slug":"Program/2016-05-09-user-login-and-regist","date":"2016-05-08T16:00:00.000Z","updated":"2018-11-09T14:26:27.894Z","comments":true,"path":"2016/05/09/Program/2016-05-09-user-login-and-regist/","link":"","permalink":"http://heartaway.cn/2016/05/09/Program/2016-05-09-user-login-and-regist/","excerpt":"","text":"看似简单的注册登录功能，如果想考虑完善，并且做到极致体验和良好的安全性，并不是一件容易的事情。本篇文章就结合我们公司的登录体系来分析一下怎么去做好一个用户注册与登录功能。 密码设置与传输：用户在注册的时候最好对密码的强度做验证，防止弱密码。其次切记不能将密码明文传输，一般的做法是前对对密码做一次Md5加密，后端再做一次Md5加密然后出到DB中。 请求参数签名与验签：现在主流的开发模式是前后端分离，那么前端再对参数加密的时候，怎么管理盐值？盐值怎么在请求中传递？服务端怎么在不侵入业务的方式下做到验签？接下来主要讲讲Token(CrsfToken/UserToken)在请求加解密中的使用方式： UserToken是通过用户基本信息和CrsfToken进行AES加密生成，并存储到用户的Cookie中，每次请求的时候浏览器自动会携带Cookie进行数据请求，这样服务端就可以从request中获取到Cookie对象。UserToken的主要作用是进行验签。 CrsfToken的作用是防止CRSF攻击，传统的做法是在form表单中加入此参数，后端验证crsfToken的有效性，但是这种方式对业务有侵入性，比较好的做法是无业务侵入就完成预防Crsf的功能。我们采用的方式是用户登录成功后将CrsfToken存储在浏览器的localStorage中，每次请求的时候使用CrsfToken作为盐值对参数进行Md5签名，网关从请求的Cookie中取出userToken并AES解密出CrsfToken，再进行验签。用户退出或者userToken时效的时候都会主动从LocalStorage中清除CrsfToken,从cookie中清除Token和用户信息，任何需要访问用户登录态的数据因为都需要加密，所以首先会判断CrsfToken是否存在，不存在直接跳登录页了。 下图为JS方式使用CrsfToken对请求参数进行加密处理： 下图为页面服务请求时Request中Cookie携带的userToken信息： 总结：这就相当于把加密使用的盐值超出在用户的浏览器中，盐值并不会在每次请求中传递，只用来加密使用，每次在请求中传递的是使用盐值+用户的基本信息进行AES加密生成的秘钥Token，网关系统从此秘钥Token中反解密出CrsfToken来验证请求的合法性。这种实现方式在攻击者未拿到localStorage中的CrsfToken时是无法生成正确的签名值的，所以就在一定程度上解决了CRSF攻击问题。假设攻击者劫持了用户登录请求，就可以拿到CrsfToken，就有可能被CRSF攻击，所以在Web端简单处理办法是用户每次重新登录都会更新CrsfToken和userToken。当然，如果网站上了HTTPS的话，攻击者就无法获取到CrsfToken了。 其次，通过自主管理Cookie的生命周期，也可以完成用户登录态的维护。 那你肯定会问App端如何存储CrsfToken，如何通过Cookie传递用户登录态，如何在多设备上同时登录？ 图片/短信验证码：现在大部分的网站注册基本都使用的是手机号注册的方式，那手机号注册为了验证手机号的正确性，一般都会使用手机验证码，考虑到短信成本，在下发手机验证码前为了防止机器攻击，会加上图片验证码。那怎么选择有效的图片验证码服务？如果你随便从网上找一段生成验证码的代码，很不幸告诉你，你找的很可能会被破解，现在图片验证码识别的技术还是也算比较成熟，回想一下12306的图片验证码吧。如果图片验证码做的太复杂，干扰元素太多，那么又会降低用户体验，直接影响是用户注册率。怎么寻找一个体验好的图片验证码方案呢？ 目前我认为有两种选择，第一，自主编写一套服务，在用户体验和安全性上寻求一个平衡，我们目前使用的是Captcha,体验还不错。第二，采用三方图片验证服务，比如类似于极验的厂商。 目前图片验证码的服务实现一般分为两部分，一部分是通过sessionId生成图片验证码，一部分是使用sessionId校验用户输入的验证码的正确性，验证完毕后就会从服务端清楚缓存的sessionId对应的图片验证码。 短信验证码：短信验证由于一定的延迟性，基本会考虑60s下发一次，服务端也要控制一下同一来源短信下发的次数，做好一定的风控防范。短信下发中好的用户体验的几项考核指标是短信下发送达率、送达时效、多网支持度等，试想，你兴致傲然的注册一家网站，结果半天收不到短信，试了N次未果，这是怎么样的糟糕体验，所以选择一家优质的短信提供商很有必要。 短信验证业务实现原理：上面讲到了图片验证码，在下发短信钱强制图片验证码必填，这个时候用户点击获取短信验证码的时候首先验证图片验证码的有效性，如果图片验证码有效，在验证用户是否符合下发短信的限制条件，为什么要这部分呢，因为在一些恶意攻击情况下，防止短信成本增加，是需要对恶意攻击进行风控的，其次，就算不是恶意攻击，也需要配合前段做60s限制，最后生成随机数缓存Redis，并调用短信服务商的短信发送接口。 多域登录：其实我们这里阐述的方式是通过自主管理Cookie的生命周期来达到多系统共享登录态的，如果我们有fengqu.com 和 fengxiang.com两个域名，想公用登录体系，能否还利用Cookie的实现方式实现呢？答案是可以但稍微麻烦。因为对于Cookie，处于安全性考虑，它有一个作用域问题，这个作用域由属性Domain和Path共同决定的。也就是说，如果浏览器发送的请求不在此Cookie的作用域范围内，请求是不会带上此Cookie的。我们的网关就无法拿到Cookie中的userToken，也就无法做验签；怎么办呢，我们需要一个SSO，来做Cookie的中转操作，这部分晨悟同学在阿里做了不少SSO的工作，经验丰富。 扩展阅读：你会做Web上的用户登录功能吗？","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"努力并不等于优秀，选择更重要","slug":"Think/2016-05-09-choice-is-important","date":"2016-05-08T16:00:00.000Z","updated":"2018-11-09T14:30:20.435Z","comments":true,"path":"2016/05/09/Think/2016-05-09-choice-is-important/","link":"","permalink":"http://heartaway.cn/2016/05/09/Think/2016-05-09-choice-is-important/","excerpt":"","text":"最近从原来的工作岗位跳了出来，尝试去做不同的事情。回顾过去，结果发现自己在过去的一年过得非常混沌，没有目的，自以为是，非常努力的做着对自身毫无价值的事情。 一个事情，你做的时间长了，就容易产生惰性，因为你已经有了舒适区，很多时候忘记了为什么要做这样的事情。就比如我负责的物流订单系统，每天都要处理很多的异常单，处理多了，也就习惯了，忘记了怎么彻底的解决问题或者寻找高效的解决方案，总想着，怎么把当前问题摆平，事情一多，难免需要加班解决。我每天加班到很晚，实则是在用行为上上的努力来掩饰思维上的懒惰。 决定一个人有多优秀，并不是看他有多努力，而是看这个人的思维模式，思维方式决定了行为习惯。 再努力，再加班，如果不思考的话，也只能做一些简单的活，提供的也是基本价值，因为你选择的做事情的内容和方式已经决定了你即将提供的价值。过去一年，我为公司的业务发展燃烧着自己的生命，几乎把除了睡觉的时间都投入在了工作当中，然而结果却是，我让自己逐渐丧失了竞争能力。 你很努力，每天工作16个小时，然并卵，你并没有变得更优秀，因为走在错误的道路上，停止努力，你就是进步。 优秀的人能够快速抓取事物背后的运行规律(方法论)。看实物不要去看表面，尝试去抓取事物背后的运行规律和本质。反思自己，感觉还是太年轻，一般人都懂的道理，自己却不懂，全世界感觉就自己一个是傻瓜。 优秀的人知道自己想要什么，能很好的实现理想与现实之间的自洽。理想是什么，现实又是什么，一开始我还天真的以为自己真的是在创业，一年之后幡然醒悟，自己原来只是在一家创业公司打工而已。之前一切动心的承诺都似那过眼烟云，纵然是落下的白纸黑字，有时也无济于事。你在资本的游戏里面，只是一个连智力都没有发展健全的婴儿而已。 每一个人的时间与精力都是有限的，想要变得优秀，需要在这个领域不断的投入和产出，因而优秀的人往往方向明确，知道自己想要什么，并且最大化自己的投入与产出比。时间与精力就是他们的匕首和投枪，用只会来指挥操纵他们，战无不胜。 不做无用功，多想想你得到了什么？ 你的选择决定了你是什么样的人。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Java基础 之 IO","slug":"Java/2016-05-06-java-io","date":"2016-05-05T16:00:00.000Z","updated":"2018-11-09T14:34:18.073Z","comments":true,"path":"2016/05/06/Java/2016-05-06-java-io/","link":"","permalink":"http://heartaway.cn/2016/05/06/Java/2016-05-06-java-io/","excerpt":"","text":"操作系统IO五类模型 IO操作的两个阶段：1.等待数据的到来，当数据到来时将数据拷贝到内核临时缓冲区；2. 将数据从内核临时缓冲区拷贝到用户缓冲区； 阻塞IO、非阻塞IO：阻塞IO就是进程一直等待数据的到来直到抵达超时时间；非阻塞IO就是采用“轮询”的方式询问操作是否准备就绪，是一种浪费CPU的方式；在阻塞IO上上进一步改进，一个阻塞IO监控一个套接字比较改进为使用IO复用（select 、poll），一次监控多个套接字，减少轮询次数，轮询模式一定程度上牺牲了实时性；当然select一次管理的socket的数量有上限，比如在linux 2.6.15内核中最大值为1024。 当然IO复用一定程度上解决了我们一些问题，但是他的副作用也很明显，对CPU的压力、牺牲的实时性。接下来还有2种方式时异步IO模式，型号驱动IO模式和异步IO模式；异步IO与异步信号IO的区别是异步IO是内核所有操作处理完毕后才会通知，而信号异步IO是内核执行过程中也会通知，比如数据准备完毕后的通知。异步IO是最理想的工作方式，但是目前在实践中一直没有稳定的内核版本推出。 在异步IO未成熟的情况下，解决select模式的socket句柄数限制，在Linux 2.6 内核中引入了epoll IO多路复用技术。poll每次调用时对集合进行线性扫描，而epoll只会对活跃的socket进行操作，这样IO效率不随FS数量的增加而线性下降；其次，为了解决数据从内核态到用户态的拷贝，在用户空间和内核空间的划出一片共同区域mmap实现数据交换；基于事件驱动，避免每次都把所有fd都扫描一遍 BIO(Blcok IO)基本类熟悉: File类 InputStream OutputStream 面向字节形式的I/O Reader Writer 兼容Unicode与面向字符的I/O; 提供了内置锁lock，对临界区考虑了线程安全性，默认使用自身对象作为对象锁，否则使用构造函数传入的锁对象。 FilterInputStream FilterOutputStream 对InputStream outStream进行包装，实现装饰器模式。为什么要使用装饰器模式？ FilterReader FilterWriter InputStreamReader OutputStreamWriter 适配器模式，提供了对InputStream、OutputStream的兼容 bufferedInputStram bufferedOutputStream 通过 属性添加volatile/方法sychronized关键字实现线程安全； bufferedReader bufferedWriter 通过synchronized+内部对象锁实现临界区的并发访问；通过自己写测试类，确认方法synchronized是对象锁this，多一个synchronized方法之间互斥访问；因为后者在已经方法就进行加锁，所以两种方式在执行性能上相差无几，只是两种代码编写风格，synchronized写在方法上会更优雅一些，因为可以让使用者明确知晓方法为线程安全的，此次对象锁也会增加代码工作量。如果一个方法中只有很少一部分访问临界区，那么采用编写对象lock锁性能更高。 理解： 两个对称性：1. InputStream 与 OutputStream 对称，分别位于流管道的两端；2. （inputStream、outputStream）字节操作与字符（reader、writer）操作的对称性； 两个设计模式：装饰器模式 和 适配器模式；IO库使用装饰器（组合）模式，不采用继承的原因是，如果采用继承,那么在多个实现类上每一个都需要添加子类，会导致类爆炸，采用装饰器模式，让原始类与辅助功能类进行拆分，可以做到辅助功能类对其它原始类复用。其次可以做到原始实现类对修改关闭，装饰器对扩展开放。这个就像我们我们提供豆制品（Component）的一种实现原味的豆腐脑（ConcreteComponent）、和原味豆浆（ConcreteComponent），并且提供了佐料 糖、盐、酱油、花生米等（Decorator）,每一种作料都可以用来装饰豆腐脑或者豆浆形成新的口味。佐料需要接受一个豆制品的具体实现素材才能制作新口味饮品，所以必须把豆制品的引用传递给佐料。 为什么Decorator也需要实现Component接口呢？举个例子，豆腐脑加了酱油形成了酱油豆腐脑，如果酱油豆腐脑不是一种Component，那么用户要吃带花生米的酱油豆腐脑怎么办呢，没法扩展了，因为花生米只接受豆制品（Component），所以佐料也实现Component接口这样通过Decorator组建的新产品可以作为另外一个佐料的输入源进一步被装饰。这样不仅支持了纵向扩展，也支持了水平扩展。 为什么Decorator需要一个抽象父类呢？因为没必要为每一个装饰后的类都重新写一个装饰器，其次抽象装饰器父类可以做到ConcreteComponent与Decorator解耦。 NIO(Non-blcok IO)NIO里面重要的引入了三个概念，通道Channels、缓冲区Buffers、选择器Selectors。在BIO中IO基于字节或字符，但NIO基于通道、缓冲区进行操作。 Buffer：底层是一个固定长度数组，并有几个int对象标识一些指针，capacity &gt;= limit &gt;= position &gt;= mark，通过这些指针标识写入的数据位置和可读数据的区域。一帮对象采用HeapByteBuffer，但堆大小有限，对于大文件的操作需要机遇磁盘IO进行处理，这个时候就需要借助MappedByteBuffer进行处理。 文件加锁：通过Channel的lock()或tryLock()方法获得文件锁，文件锁依赖于操作系统实现，属于系统调用，也因此当文件被加锁以后，不仅是当前进程中的其它线程无法再次获得锁，其他任何进程（无论本地还是远程）都无法再对文件进行操作（具体还要取决于操作系统对文件是否支持共享锁，比如我的Mac系统就不支持共享锁）。但是由于这种机制高度依赖系统，所以实际应用中应该并不常用。而且FileLock是JVM持有的，而非线程持有，一个JVM只能持有一次，所以当已经持有锁的情况下同一JVM里的另一线程再次请求锁，会抛出OverlappingFileLockException，而非阻塞，即使是使用tryLock()方法，也不会直接返回null，同样抛出OverlappingFileLockException。 图形化demo学习工具：http://www.javanio.info/filearea/demos/ 参考：http://www.iteye.com/magazines/132-Java-NIO","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"JVM内存可见性之use Or read-load-use","slug":"Java/2016-05-05-mem-visiable","date":"2016-05-04T16:00:00.000Z","updated":"2018-11-09T14:21:59.374Z","comments":true,"path":"2016/05/05/Java/2016-05-05-mem-visiable/","link":"","permalink":"http://heartaway.cn/2016/05/05/Java/2016-05-05-mem-visiable/","excerpt":"","text":"问题描述：如果两个线程都对静态共享变量shareVar有引用，其中一个线程1使用 shareVar，另外一个线程2对shareVar进行修改，那么线程1是否能够理解拿到修改后的值呢？ 代码描述： 12345678910111213141516171819202122232425262728293031323334353637public class StaticVarVisibility &#123; public static boolean shareVar = true; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int i = 0; //JVM优化导致，当频繁使用主存变量的时候只做use，并未做read-load-use while (shareVar) &#123; i++; //循环1000次，进行new Object(); //synchronized (this) &#123; &#125; 会强制刷新主内存的变量值到线程栈?我认为不是，是因为同步操作是一个耗时操作，所以对is的使用从单纯的use变为read-load-use //System.out.println(i); //println 是synchronized 的 //try &#123; //sleep操作释放了CPU，所以遵循JVM优化基准，尽可能保证工作内存和主存的及时同步，如果CPU一直被占用，就无法及时做到数据同步 //TimeUnit.MICROSECONDS.sleep(1); //&#125; catch (InterruptedException e) &#123; //&#125; &#125; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; shareVar = false; //设置shareVar为false，使上面的线程结束while循环 &#125; &#125;).start(); &#125;&#125; 程序现象：如果线程1中循环体内只有i++，此时循环并不会立即停止下来，为什么呢？线程2已经对shareVar设置了false，为什么线程1没有及时获取到修改后的变量呢？ 在线程1中无论是循环创建对象还是使用synchronized还是sleep，都会触发线程1对shareVar变量的可见性。 结果分析：为什么static的变量能够实现可见性？其实跟static是否无关，即使只是一个简单的变量，线程1也是可以读到修改后的数据的，只是时间不可预期而已。 那为什么开始循环没有及时停止呢？原因是在JVM的优化策略下，当线程1频繁使用主存变量shareVar的时候只做use，并未做read-load-use，所以变更后的数据未能及时同步，当执行创建对象、sleep、synchronized这些耗时操作时，cpu对共享变量shareVar的使用不再频繁，所以jvm就可以来保证数据的同步，并从单纯的use变为read-load-use。 当然在shareVar变量前主动加上volatile关键字，程序会立即停下来，因为这相当于告诉jvm当变量进行变更后强制进行read-load-use。 总结： 知晓JVM什么时候只进行use，什么时候进行read-load-use。 在后续的编程中，如果需要修改后的数据必须做到实时可见性，必须在前面添加volatile关键字，这可能在支付相关的业务中存在。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"记一次系统Dubbo调用超时的故障","slug":"Java/2016-05-03-dubbo-timeout","date":"2016-05-02T16:00:00.000Z","updated":"2018-11-09T14:21:54.051Z","comments":true,"path":"2016/05/03/Java/2016-05-03-dubbo-timeout/","link":"","permalink":"http://heartaway.cn/2016/05/03/Java/2016-05-03-dubbo-timeout/","excerpt":"","text":"现象：生产环境用户无法使用下单，订单无法交易。 异常日志： 123456Caused by: com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2016-05-03 15:45:29.514, end time: 2016-05-03 15:45:35.771, client elapsed: 0 ms, server elapsed: 6257 ms, timeout: 1000 ms, request: Request [id=288854, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=getItemInfoListForOrder, parameterTypes=[interface java.util.List], arguments=[[xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx]], attachments=&#123;id=xxx, input=xxx, path= 分析:发现订单调用商品的API超时了，登陆商品系统并没有发现任何的异常调用，感觉订单的系统调用并没有抵达商品系统，后来陆续发现订单访问其他系统的Dubbo调用都超时了，由此可断定可能是订单系统的问题。首先想到的是数据库的链接数，查看RDS的连接数： 可以看到，15点开始，总连接数开始飙升，并且临近最大值480(但是一直没到最大值480)，但是活跃连接数却始终保持在非常低的水平。可能是由于活动开始，根据之前经验，连接数上升是正常的情况，活动连接数低说明db在获取数据中，并且db的其他性能并没有出现瓶颈情况，iops情况如下： 看了一下rds的性能优化发现有一条慢sql，但此时重点并没有放在这里。原因如上，我们认为db没有到达瓶颈（连接池没满，而且iops在正常范围）。 当时我们还查看了db的实时会话，当时有大量的处于sleep中的语句，大约有200多个,这说明，有大量sql连接正在等待mysql返回数据，这就是iops不高的原因。上图这是事后正常的截图。 另外一边进行jstack， 查看日志，发现大量线程处于wait状态： 12345[admin@order2.hz /home/admin]$grep 'java.lang.Thread.State:' 17116.jstack |awk '&#123;FS=\":\"&#125; &#123;print $2&#125;'|awk '&#123;print $1&#125;' |sort |uniq -c 18 RUNNABLE 147 TIMED_WAITING 662 WAITING 初步判断应该不竞争锁，否则出现的应该是blocked， Locked ownable synchronizers: – None 也说明了这个情况，也没有找到死锁的迹象。我们查看Mysql的使用情况，发现200多个实物处于Sleep状态，但是没能推测出是由于大数据量查询都处于等待数据的返回。接下来查看日志里面有java.lang.OutOfMemoryError: Java heap space ，查看GC的情况，发现系统每5s就进行了一次FullGC，此时在查看内存情况，堆内存基本被占满。继续查看日志， 发现由于一个SQL的query操作引起的，在跟进这段代码深入分析，发现这段查询逻辑直接查询数据库，而且数据量非常大，每次3W条数据，大于每个线程需要占用30M的堆内存，100个连接就需要3G的内存，但是我们的JVM最大设置的是2G内存所以导致存储空间不足。这下明白了，由于堆内存空间不足，所以任何dubbo的调用都无法正常分配到内存，所以就导致了任何接口的超时表现。 异常日志中出现 Unable to create new native thread，出现这个异常的原因、排查方法是什么呢？根据毕玄的文档： 查看操作系统Linux的最大线程数： 1[admin@order1.hz /home/admin]$cat /proc/sys/kernel/threads-max 结果是：60949 。ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。 1234567891011121314151617[admin@order1.hz /home/admin]$ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 30474max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 10240cpu time (seconds, -t) unlimitedmax user processes (-u) 1024virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited max user processes Linux默认限制用户最大的线程数为1024。那么在本系统中JVM中最大的进程数是多少呢？Jvm（jdk7）中，-Xms2g -Xmx2g 未设置Xss（the stack size for each thread），影响JVM线程数的因子有堆大小(Xmx)、每个线程的栈大小(Xss)、系统最大线程数据数（ulimit -u）,参考：JVM中可生成的最大Thread数量。 未设置Xss，默认值是1M（参考1 、参考2），至于操作系统上栈大小（ulimit -s）为10M，这个配置只影响进程的初始线程；后续用pthread_create创建的线程都可以指定栈大小。HotSpot VM为了能精确控制Java线程的栈大小，特意不使用进程的初始线程（primordial thread）作为Java线程，相关参考： What the difference between -Xss and -XX:ThreadStackSize is? Inconsistency between -Xss and -XX:ThreadStackSize in the java launcher 能够创建线程的最大个数的估算公式： (MaxProcessMemory – JVMMemory – ReservedOsMemory) / (ThreadStackSize) = Number of threads 通过大致计算，xmx=2G、xss=1M，那么4G – 2G – 300M(根据top参数预估) / 1M = 1700 预计可以创建1700个左右的线程，但是受限于ulimit -u ：1024的限制，所以最多可以创建1024个进程。查看Jvm进程当前的进程数： 1ps -eLf |grep java -c 未做活动是的数量为800，如果不修改ulimit的值，这很容易导致线程数超限的问题，所以建议修改到2000。 总结：整个问题定位花费了很长时间，起先没有能从订单的错误日志入手，其次，监控信息的缺失，FullGC、内存这么重要的监控指标没能监控起来。所以以后遇到这样的类似的问题应该第一时间查看日志，其次查看各种指标数据CPU、内存、GC、jstack等；其次，在编码上，一定要注意任何的查询是否可能会导致大量数据的返回，如果有这种设计就应该重新设计方案。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"一个程序员的醒悟","slug":"Think/2016-04-17-programmer-think-point","date":"2016-04-16T16:00:00.000Z","updated":"2018-11-09T14:30:39.057Z","comments":true,"path":"2016/04/17/Think/2016-04-17-programmer-think-point/","link":"","permalink":"http://heartaway.cn/2016/04/17/Think/2016-04-17-programmer-think-point/","excerpt":"","text":"工作四年了，作为一个程序员，该有怎样的定位，如何更新自己的知识库不至于自己落后于时代，如何保证自己不沉溺于每天重复性的劳动而缺乏思考，这些问题最近一直萦绕于耳。为什么是最近，因为最近参与了公司招聘新人的流程，深切感受到了刚毕业同学最技术的追求，感觉似乎自己掌握也不比他们太多，一下子感觉自己是不是要被淘汰了。静下心来，仔细回顾自己的这几年的成长，发现前两年主要在阿里做测试领域，虽然感觉对技术没有什么帮助，但是阿里的工作氛围和做事方式让我受益良多，比如结果导向、用户为上、用户体验。来到创业公司的这一年半，一直在做业务系统，缺乏技术积累和磨练，虽然写了大量代码，现在去看看，很多都有优化空间，似乎只是为了实现功能而实现，完全缺乏深入的思考。 在目前企业中，我逐渐从他人身上领悟到一个道理，那就是在公司发展的同时，让自己也能有更大的挑战。不是任何事情事必躬亲就一定会让你的价值得到凸显，而是要学会选择，学会做什么事情，不做什么事情。对一个已经工作了四年的人来说，你具备能力挑选你想做的事情，而不是等待被安排。自己的成长路线只有自己对自己负责，老板最多也就给你一些指导而已，老板还要思考他自己的成长路线，以为的把自己的未来之路交给老板去规划与督促，这个就像把自己的命运交给别人掌控一样，至少不是一个聪明人的做法。把握好事情的核心层面，找人帮你完成实现就可以了，关键你自己要把里面的核心点想清楚。 创业公司一定少不了加班，但是自己不能一直加班而不知道停下来想想为什么自己要加班，而别人就不用，是自己的效率低下还是真的事情比较多。如果是自己的效率为题，就应该停下来，想想怎么跟聪明的把这个事情做好，通过更好的框架设计还是把这个事情抛出来让大家配合去完成。我在过去的一年中很有一段时间就忘了自己为什么加班而加班，每天都感觉有做不完的事情，做的越多，给人的印象就是越不会做事情，效率低下。对我自己来说，损害了自己的身体，做了一堆垃圾活，对自己的个人成长一点好处都没有，反而最终结果也不好。我以前一直认为，一些事情我能做掉的就不要麻烦别人，能通过加班时间多为公司多争取一些利益的事情我就会去做；但是现在看看，至少有更聪明的做法让自己在得到成长的同事，更轻松。时常问问自己为什么要加班？难道是为了年终的绩效？那有多少钱呢，为什么不是把加班的时间拿来用于自己的技能成长呢，技术的提升可以在后期解决收入的问题，而不需要靠加班来解决这个问题。 我庆幸有这样的环境，因为让我自己只使用了一年的时间就明白了这个道理，而不是用两到三年。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"为什么SimpleDateFormat 不是线程安全","slug":"Java/2016-03-10-simpledateformat","date":"2016-03-09T16:00:00.000Z","updated":"2018-11-09T14:21:44.403Z","comments":true,"path":"2016/03/10/Java/2016-03-10-simpledateformat/","link":"","permalink":"http://heartaway.cn/2016/03/10/Java/2016-03-10-simpledateformat/","excerpt":"","text":"查看SimpleDateFormat类的说明，在最后一条已经明确说明了此类非线程安全，建议为每一个线程创建一个单独的实例，如果多线程共享实例，务必保证同步性； 要知道为什么不是线程安全的，首先我们需要知道SimpleDateFormat的作用和工作原理。 SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar类的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。 SimpleDateFormat最重要的两个方法，一个是format，一个是parse。 format方法： 可以看到，方法一开始就使用传入的date参数对属性calendar进行了初始化，试想如果此类是共享的，那么其它类还在使用此calendar的引用时，可能下一次获取到的值就与之前获取到的值不一样了。那format方法为什么要使用传入参数date对calendar的进行设置呢？为什么不可以把calendar作为方法参数在内部方法中传递呢？如果这里calendar是内部方法属性，并在subFormat中通过方法传递，一切问题就都解决了。作者这么做也许只是想减少一个参数的传递吧，但是这带了了诸多的线程安全问题。 parse方法：首先从方法的注解上可以了解到parse的实现方式是通过对时间字符串逐步进行解析，然后通过java.text.CalendarBuilder.establish和calendar构建时间对象。 Date字符串解析中使用了calendar对象，在解析前，会调用Calendar#clear()方法，对引用的calendar对象的各个域进行初始化为默认值；然后把每次解析出来的时间片段设置到calendar相应的属性中，最后返回calendar中的time。 不难想出在高并发情况下，如果calendar是多线程共享的，一定会出现A线程中calendar进行了clear(),导致B线程受到影响。 无状态性：思考：SimpleDateFormat类中是什么因素导致了此类不是线程安全的呢？是对calendar的引用，方法中对calendar的引用对象进行了修改，从而导致了此类是有状态的，我们一般在设计代码的时候尽量让自己的代码处于无状态，好处是，在各种情况下，无论并发掉多少次，结果总是一样的。 SimpleDateFormat线程安全的解决方案： SimpleDateFormat设计为方法内实例；好处，从共享变为非共享，线程安全。弊端是每次创建性能开销大。 在进行parse或者format时对SimpleDateFormat对象进行加锁； 使用ThreadLocal，为每一个线程维护一个实例对象。 使用Apache commons包中的FastDateFormat 或者 Joda-Time类库。 下午在代码开发中使用到的时间Util，采用的是方法三： 12345678910111213141516171819202122232425262728293031323334353637383940/** * &lt;p&gt; * 由于SimpleDateFormat不是线程安全的，所以在作为静态工具类使用的时候需要特殊处理 * &lt;/p&gt; * Date: 16/3/10 * Time: 下午3:38 */public final class DateUtil &#123; private static final Logger logger = LoggerFactory.getLogger(DateUtil.class); public static final String DEF_PATTERN = \"yyyy-MM-dd HH:mm:ss\";//默认时间格式 public static final String DATE_PATTERN = \"yyyy-MM-dd\";//日期格式 //注意，这里初始化会有问题，后面会讲到（自己使用时需要删除此行） public static final Date START_NULL_DATE = parseDate(\"1970-01-01 08:00:00\", DATE_PATTERN); private static final ThreadLocal&lt;Map&lt;String/**pattern**/, DateFormat&gt;&gt; threadLocal = new ThreadLocal&lt;Map&lt;String, DateFormat&gt;&gt;() &#123; @Override protected Map&lt;String, DateFormat&gt; initialValue() &#123; return new HashMap&lt;String, DateFormat&gt;(); &#125; &#125;; /** * 获取DateFormat * * @param pattern * @return */ private static DateFormat getDateFormat(String pattern) &#123; DateFormat dateFormat = threadLocal.get().get(pattern); if (dateFormat == null) &#123; dateFormat = new SimpleDateFormat(pattern); threadLocal.get().put(pattern, dateFormat); &#125; return dateFormat; &#125;&#125; 在生产环境中使用过程中，Runtime期间JVM报错： 1java.lang.NoClassDefFoundError: Could not initialize class com.xxxx.vender.util.DateUtil 开始怀疑是因为把ThreadLocal作为静态初始化块导致的问题，但是查阅ThreadLocal的官方文档，给出的实例就是作为static属性使用，有同学说最好把DateUtil工具类做成单例模式进行使用，但是这个并没有找到报错的原因，后来有再本地进行了测试，发现抛出了NPE的异常，再仔细看看代码，发现有同学在ThreadLocal的初始化块之上添加了静态属性START_NULL_DATE,而START_NULL_DATE的初始化依赖threadLocal属性的初始化，抛出NPE是合乎情理的，那为什么生产环境上却出现的是java.lang.NoClassDefFoundError而不是NPE呢？ java.lang.NoClassDefFoundError到底是什么：NoClassDefFoundError发生在JVM在动态运行时，根据你提供的类名，在classpath中找到对应的类进行加载，但当它找不到这个类或者初始化这个类（静态属性或代码块）失败时，就发生了java.lang.NoClassDefFoundError的错误。 更多有关此类的解释可以参考： http://blog.csdn.net/jamesjxin/article/details/46606307","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"透过序列化字节码看Java序列化","slug":"Java/2016-03-09-byte-code-java-serailze","date":"2016-03-08T16:00:00.000Z","updated":"2018-11-09T14:21:38.654Z","comments":true,"path":"2016/03/09/Java/2016-03-09-byte-code-java-serailze/","link":"","permalink":"http://heartaway.cn/2016/03/09/Java/2016-03-09-byte-code-java-serailze/","excerpt":"","text":"Java序列化的基础知识 请参考之前的文章 ‘Java基础 之 序列化与反序列化’ 序列化数据的存储结构： Java序列化后存储的信息包括：类元数据描述、类的属性、父类信息以及属性域的值。 编写一个测试类： 1234567891011121314public class SerializableTest implements Serializable &#123; private int father; private static final long serialVersionUID = 1937803012639770720L; private class ObjectSaver extends SerializableTest implements Serializable&#123; private static final long serialVersionUID = -1460368089309853877L; public String name; public int old; public ObjectSaver(String name, int old) &#123; super.father = 1; this.name = name; this.old = old; &#125; &#125;&#125; 通过Junit进行序列化，生成序列化后的对象： 12345678@Testpublic void testWriteObject() throws Exception&#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"/Users/xinyuan/tmp/ObjectSaver.obj\")); objectOutputStream.writeObject(\"严明明\"); objectOutputStream.writeObject(new Date()); objectOutputStream.writeObject(new ObjectSaver(\"测试类\",30)); objectOutputStream.close();&#125; 使用strings打开ObjectSaver.obj 文件，可以看到存储下来的可打印的字符信息如下： 12345678910java.util.DatehjScxsr7com.java.demo.serializable.SerializableTest$ObjectSaveroldLnametLjava/lang/String;Lthis$0t-Lcom/java/demo/serializable/SerializableTest;xr+com.java.demo.serializable.SerializableTestfatherxp 二进制内容为： 1234567891011121314151617181920aced 0005 7400 09e4 b8a5 e698 8ee6 988e7372 000e 6a61 7661 2e75 7469 6c2e 44617465 686a 8101 4b59 7419 0300 0078 70770800 0001 5356 b659 b778 7372 0037 636f6d2e 6a61 7661 2e64 656d 6f2e 7365 7269616c 697a 6162 6c65 2e53 6572 6961 6c697a61 626c 6554 6573 7424 4f62 6a65 63745361 7665 72eb bbba f5cb 5ec7 4b02 00034900 036f 6c64 4c00 046e 616d 6574 00124c6a 6176 612f 6c61 6e67 2f53 7472 696e673b 4c00 0674 6869 7324 3074 002d 4c636f6d 2f6a 6176 612f 6465 6d6f 2f73 65726961 6c69 7a61 626c 652f 5365 7269 616c697a 6162 6c65 5465 7374 3b78 7200 2b636f6d 2e6a 6176 612e 6465 6d6f 2e73 65726961 6c69 7a61 626c 652e 5365 7269 616c697a 6162 6c65 5465 7374 1ae4 7592 b5134860 0200 0149 0006 6661 7468 6572 78700000 0001 0000 001e 7400 09e6 b58b e8af95e7 b1bb 7371 007e 0006 0000 0000 第一部分：aced STREAM_MAGIC 流的幻数，用于标识序列化协议； 0005 STREAM_VERSION 标识序列化协议的版本号； 一些标识性字符可以参考类：ObjectStreamConstantsObjectOutputStream.writeStreamHeader()方法： 1234protected void writeStreamHeader() throws IOException &#123;bout.writeShort(STREAM_MAGIC);bout.writeShort(STREAM_VERSION);&#125; 第二部分：1objectOutputStream.writeObject(“严明明”) 74 标识TC_STRING 00 09 标识第一个String的长度为9个字节 e4 b8a5 e698 8ee6 988e 表示String类型的值：严明明 1objectOutputStream.writeObject(new Date()) 7372 标识TC_OBJECT 和 TC_CLASSDESC 000e 标识类名称长度为14个字节 6a61 7661 2e75 7469 6c2e 4461 7465 表示类型值：java.util.Date 686a 8101 4b59 7419 标识uid对象序列化ID的类型为long型，占用8个字节 03 这一个字节可能有十种值标识：参考java.io.ObjectStreamConstants#SC_* 0000 标识类属性个数，因为是Date类型，所以没有自定义属性 78 标识域类型TC_ENDBLOCKDATA ，因为属性个数为0，所以对象数据结束 70 再没有父类的标识 77 对象数据块开始，TC_BLOCKDATA 08 标识数据长度为8个字节 00 0001 5356 b659 b7 标识new Date()的对象时间戳long型，占用8个字节 78 TC_ENDBLOCKDATA 对象数据库结束标识 1objectOutputStream.writeObject(new ObjectSaver(“测试类”,30)) 7372 0037 表示TC_OBJECT 和 TC_CLASSDESC ，且类名称长度为55个字节 636f ​ 6d2e 6a61 7661 2e64 656d 6f2e 7365 7269 ​ 616c 697a 6162 6c65 2e53 6572 6961 6c69 ​ 7a61 626c 6554 6573 7424 4f62 6a65 6374 ​ 5361 7665 72 ​ 表示类名值：com.java.demo.serializable.SerializableTest$ObjectSaver eb bbba f5cb 5ec7 4b 标识ObjectSaver对象序列化ID的类型为long型，占用8个字节 ，值为-1460368089309853877L，因为uid为静态属性，所以属于类元信息一部分 02 这一个字节可能有十种值标识，其中02标识SC_SERIALIZABLE，此类继承了Serializable接口 0003 标识类属性个数为 3 个，包含this； 49 域类型，49转十进制为73，73在ASC码中对应的是 I ，因为old为int类型 00 03 标识属性名称长度为3个字节 6f 6c64 标识属性名称为 old 4c 域类型，4c转十进制为76，76在ASC码中对应的是 L，因为name为String对象 00 04 标识属性名称长度为4个字节,name字符占四个字符 6e 616d 65 标识属性名称的值 name 74 标识TC_STRING一个新的字符串 0012 域类型长度为18个字节 4c6a 6176 612f 6c61 6e67 2f53 7472 696e​ 673b​ 对象类型签名 Ljava/lang/String; 包含封号 4c 域类型，4c转十进制为76，76在ASC码中对应的是 L 00 06 标识属性名称长度为6个字节 74 6869 7324 30 标识字符串 this$0 74 标识TC_STRING一个新的字符串 002d 域类型长度为45个字节 4c63​ 6f6d 2f6a 6176 612f 6465 6d6f 2f73 6572​ 6961 6c69 7a61 626c 652f 5365 7269 616c​ 697a 6162 6c65 5465 7374 3b​ Lcom/java/demo/serializable/SerializableTest; 78 标识域类型TC_ENDBLOCKDATA 上面为之类ObjectSaver的描述信息和元信息，下面为父类SerializableTest的描述信息和元信息 72 标识TC_CLASSDESC 002b 标识类名称长度为43个字节 63​ 6f6d 2e6a 6176 612e 6465 6d6f 2e73 6572​ 6961 6c69 7a61 626c 652e 5365 7269 616c​ 697a 6162 6c65 5465 7374​ 标识类字符串：com.java.demo.serializable.SerializableTest 1ae4 7592 b513 4860 标识ObjectSaver对象序列化ID的类型为long型，占用8个字节 ，值为-1937803012639770720L 02 这一个字节可能有十种值标识，其中02标识SC_SERIALIZABLE，此类继承了Serializable接口 00 01 标识类属性个数为1个 49 域类型，49转十进制为73，73在ASC码中对应的是 I ，因为old为int类型 0006 标识属性名称长度为6个字节 6661 7468 6572 标识father六个字符； 7870 TC_ENDBLOCKDATA 对象数据库结束标识，且没有父类 第三部分：接下来是对象属性域的值部分，按照从父类到子类的顺序写入域的值 0000 0001 标识的十进制为1，对应父类father的值为1 0000 001e 标识十进制为30，标识之类old的值为30 74 标识TC_STRING一个新的字符串 0009 标识占用9个字节 e6b5 8be8 af95 e7b1 bb 标识字符“测试类” 73 71 标识TC_OBJECT TC_REFERENCE 007e 0006 0000 0000 总结 Java序列化算法的基本步骤 输出序列化的头部信息，包括序列化协议的幻数和版本； 基本类型按照一字节的类型标识、两字节类型长度、N个字节值 基本对象类型，7372标识OBJECT和CLASSDESC，两字节类型长度，8字节uid，一些辅助信息 复杂对象类型，第一步按照由子类到父类的顺序，递归的输出类的描述信息，知道不再有父类为止；类描述信息按照类元数据，类属性信息的顺序写入序列化流中；第二步按照由父类到之类的顺序，递归的输出对象域对象域的实际数据值；而对象的属性信息是按照基本类型到java对象类型的顺序写入序列化流中，其中java对象类型的属性会从第一步重新开始递归的输出，知道不再存在java对象类型的属性。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"分布式系统高效唯一ID生成方案","slug":"Program/2016-02-26-distributed-system-id-generator","date":"2016-02-25T16:00:00.000Z","updated":"2018-11-09T14:26:18.597Z","comments":true,"path":"2016/02/26/Program/2016-02-26-distributed-system-id-generator/","link":"","permalink":"http://heartaway.cn/2016/02/26/Program/2016-02-26-distributed-system-id-generator/","excerpt":"","text":"背景：在分布式系统中，对于订单ID如何保证全局唯一地高效的生成，并对性能影响不大的情况下，利于建立索引和业务使用？ 方案一：使用数据库主键ID优势：实现简单；弊端：使用数据库增加写库的压力，生成订单的上限受限于数据库的写性能上限；扩展性差； 方案二：单点批量生成订单号的服务；优势：批量降低了数据库的读写压力弊端：服务单点风险； 方案三：使用UUID优势：本地生成ID，不进行远程调用，延迟低；弊端：无法保证趋势增长；uuid过长且建立索引效率低下；64位太长； 方案四：使用毫秒数优势：本地生成ID，不进行远程调用，延迟低；ID为整数利于建立索引；弊端：并发超过1000，可能会重复；优化方案：使用LRU Cache存储最近生成的100Key，去除后先判断是否重复；进一步降低重复的可能性；但是无法根本上解决高并发下的重复； 方案五：订单号分段表示具体含义方案描述：使用39bit表示毫秒数、4bit表示业务线、7bit表示机器等优势：实现简单，且重复可能性很低；弊端：订单长度过长，不利于业务使用；方案六：使用Redis服务+毫秒数双重方案优势：使用redis的自增序列特性，每次获取一定数量的数据（1000个），降低了每次调用Redis的开销；当Redis挂了，使用基于毫秒数的本地生成ID优化方案；弊端：redis挂了后，订单号的重复性不可避免； 总结：我们在设计分布式全局唯一单号的时候，不仅需要考虑生成单号的是否重复性，还要考虑生成时的性能开销、是否有容灾方案、是否便于建立索引、是否利于业务使用等。基于这些点的考虑，我们采用了方案六作为线上的唯一生成方案，并把此方案作为一个业务隔离的二方库，可以提供给不同业务方式用；","categories":[{"name":"Program","slug":"Program","permalink":"http://heartaway.cn/categories/Program/"}],"tags":[]},{"title":"二零一五，我的失败与伟大","slug":"Think/2016-01-03-2016-my-success-and-fail","date":"2016-01-02T16:00:00.000Z","updated":"2018-11-09T14:30:47.321Z","comments":true,"path":"2016/01/03/Think/2016-01-03-2016-my-success-and-fail/","link":"","permalink":"http://heartaway.cn/2016/01/03/Think/2016-01-03-2016-my-success-and-fail/","excerpt":"","text":"回顾2015这一年，感觉自己起起伏伏，有过激情不顾一切的奋斗，有过一蹶不振的低沉，心情的变化起伏跟这一年的股市走线很像，经历了超出预期的大牛市后，出现了看一切都绝望的段崖般跳水。现在回想起来并不一定是坏事，创业需要激情，但是激情过后需要对生存本质的思考，关键是如何从低沉期度过，寻找到下一个支撑点。 ####【不顾一切的加班】从去年决定加入创业团队以来，公司业务一直处于高速发展期，团队整体环境还不错，有节凑的项目规划、执行、上线，大家的注意力也是跟随的公司业务发展不断前进。这段时间一直维持到7月份。那个时候每天工作到晚上10点多，回去了可能继续工作，很多时间到2~3点才休息，第二天依然亢奋的去做事情。有一次，为了赶一个项目的进度，周日从杭州回到上海，晚上加班到第二天5点完成任务。当时没觉得这种节奏有什么问题，但是现在回归头来想想，发现问题挺多的，首先，我让我的状态变得不可持续，长时间的透支了自己的身体，致使年末身体出现各种不适，其次，过度的沉溺于业务中，忘记了自身的发展的思考，年末总结的时候哀叹“一年来没学到什么东西”，技术上的踏步更加剧了我未来的恐惧。 这段时间的经历也并不是没有收获，我对我负责的项目还是比较用心的，跟产品、运营同学合作也非常融洽，大家对我也表示了一致的认可。好几个同学都说，如果今年评选优秀员工，一定会选我，这个对我的一种肯定。在阿里，它教会了我让他人变得简单，用自己的技术能力给他人以帮助，共同提高效率的工作模式；你再努力让别人工作更轻松的时候，你的工作也会在一定程度上变得轻松，这些值得坚持的事情还得继续坚持。 我不反对加班，但反对沉溺于加班而忘记了为什么加班，“吾日三省吾身”，关注自身成长，在日常工作中实践成长的过程，努力了，才不会让未来的自己恐惧。保持良好的作息规律，加强锻炼，是我接下来需要做的事情，让自己找到工作和生活的一个平衡点。 ####【搬新家&amp;结婚】2015年注定是我难忘的一年，5月份的时候，我搬进了自己在杭州新家，摆脱了租房的不稳定，虽然远离市区，但小区环境确实称赞，购买这套房只为自住不为投资，一开始还会关注小区房价的走势，担心自己是不是买贵了，会不会吃了大亏，后来想想，即使我每天看24个小时房市变化，对我们小区有帮助吗，想通了也就不再关心了。 在我11年第一次到杭州的时候，就被杭州的文化气息所陶醉，我跟自己说我以后一定要在这个城市落下来，这就是我奋斗的目标，这不是为了证明给大山里面的邻里街坊看，只为内心中逃离了偏僻落后的农村追求更加文明和前沿的大城市的憧憬。我一直认为我是幸运的，相比儿时的伙伴们，我拥有了更多的选择机会，他们背负了太多的压力和责任。 十一，我升级了跟女朋友长达7~8年的恋爱，跟她正式步入了婚姻殿堂，虽然在没能给她豪华艳丽的结婚排场，但我以一种农村农乡的方式给她呈现了拜天地的热闹场景，现在回想起这段记忆，我都像吃了蜜一样甜。我可能不能给她大富大贵，但是我一定会努力，让自己成为一个上进的男人，让她值得依托。 这一年，我一心投入到工作，似乎忘记了家庭的经营，伯昊说的很对，幸福的婚姻是需要用心去经营的，这个不比工作简单，需要花时间做，一点一滴都会成为幸福生活的影响因子。2016年，我在我的GTD工具中增加了一项，叫“生活经营”，也会像给自己布置学习任务一样，制定一些计划在与老婆的共同生活之中。这一年，我完成了人生中的2大事情，置业和婚姻，自己心底安定了很多，很多时候，我们觉得自己伟大不一定需要做出浑浑烈烈见天动地的大事情，选择舒适的生活环境、跟心爱的人生活在一起就是伟大。 ####【选择坚持或放弃】出发的目的已在半途中迷失了，剩下的激情便也成了迷路的飞矢。下半年，公司发展收到外部一些因素的制约，资金捉襟见肘，内部运营团队撤离，一时感觉公司遥遥可危，再加上外部一些用户和媒体对我们公司的期望值降级，更动摇了我坚持走下去的决心，不是我为了躲避危险，没有责任感不能跟公司共同度过难关，而是一时没有找到支撑我继续下去的点，一切的外部因素都告诉我回到阿里会有更好的钱途，但内心又有一颗不干的心，不愿就此放弃。但各种不愉快小事情累加在一起，聚集成了心理噪音，它在很长一段时间内成为我心理萦回不去的主旋律，甚至忘记了其他目的，而我过于简单的把问题归咎于家庭或者个人发展的原因，没有认真分析到底是什么原因形成了这些心理噪音，如何消除心理噪音，不被其蒙蔽双眼影响自身的长远发展。好的一面是现在相比半年前，我更加信任了团队，敢于跟Leader讲真话，以一种更加真诚的方式交流，只要我觉得对我们有利的事情，我就会去做。 我们的团队出现了问题，值得庆幸的是大家都意识到了，都在用自己的行动力促使事情朝好的一面发展。在这件事情我做做的就不太好，没能发挥出正能量，有时候还起到了反作用。之所以出现这种情况，我认为是团队管理的缺陷，我也同样需要被管理和正确的引导。 很多时候我会有一点点后悔放弃了阿里高新&amp;继续深入学习技术的机会，选择投入到创业的大潮之中，但是又想想，这点放弃算什么呢，跟其他人相比，我的放弃算是小的了，至于钱，没必要过早把自己逼到一切朝钱看得角度，工作中有更美好的事情值得追求。有一句话叫做“你今天放弃的一切，以后都会以另外一种方式馈赠给你”，不纠结，放弃舒适的环境并不一定是坏事情。 当我这次再次面对选择的时候，我没有像去年从阿里离职的一时头热，而经过了更多的思考，首先我会去与留的各种利弊全部罗列出来，跟老婆进行商量，共同决策，我内心已经有了一个选择的想法，再跟老婆的沟通中稍微带一下，当然我也会尊重她得看法，毕竟以后的生活是两个人的，不再为我一个人生活。在面临选择的时候，我需要结合自己长远的发展规划，认清自己，消灭选择，然后让自己尽量进入到这个圈子，结识上赏识的人，跟着大家一起集团性的成长。 留在现有的团队，2016年需要学习和进步的地方还非常多，有太多的机会让我在2016年里可以快速成长，前提是我是否做好了准备。看看身边的人那些还在不停奋斗的人，我有神马理由不努力呢？ 总结2015年，感觉自己看书和思考的太少，这也是我感到恐惧的根本原因，消除它的唯一办法就是迎面直击，多看书，充实自己的大脑，多思考，把学到的东西转换为自己的技能。 回顾、总结是为了能够走的更远，希望在轻装上阵的2016能够走的更远。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"动态配置中心学习笔记","slug":"Middleware/2015-12-20-diamond-study","date":"2015-12-19T16:00:00.000Z","updated":"2018-11-09T14:25:04.430Z","comments":true,"path":"2015/12/20/Middleware/2015-12-20-diamond-study/","link":"","permalink":"http://heartaway.cn/2015/12/20/Middleware/2015-12-20-diamond-study/","excerpt":"","text":"客户端使用： 首先需要绑定HOST：xx.xx.xx.xx diamond.configserver.net前面的IP地址为Diamond-server的部署IP。 应用Diamond-clien二方库并开始使用； Diamond的核心原理：主要范围4个部分： Diamond-server的集群同步； Client获取Server的地址； Client从Server获取数据； Client运行时感知Server的数据变化； 使用前必读的四篇文章： Diamond的核心原理：http://jm-blog.aliapp.com/?p=1592 Diamond的架构：http://jm-blog.aliapp.com/?p=1606 Diamond的容灾：http://jm-blog.aliapp.com/?p=1617 Diamond与ZK的区别：http://jm-blog.aliapp.com/?p=2561 此时我们对Diamond大致上有了一定的了解，那Diamond到底是怎么实现的嗯？只有仔细研读源码才能了解的更清楚。 工程目录结构： Server的实现： 配置管理服务（ConfigService）： 此服务用户配置信息的增删改查，内部为了了一个所有配置信息的ConcurrentHashMap，用于记录数据key和对应的数据的Md5值，由于只是记录数据的MD5值，所以在内存开销上也并不算大；查询配置信息：是直接查询的数据库；添加配置信息：先将配置信息保存到数据库中，然后更新缓存中的Md5值，再将配置信息保存到本地磁盘中，最后通知其他server节点更新配置信息；更新配置信息：与保存配置信息流程基本类似；删除配置信息：首先删除本地磁盘数据，再删除环境中的key，然后删除数据库中的配置，最后通知其他server节点； Server之间的通知服务（NotifyService）： 此服务在启动时首先会从本地文件node.properties中将所有的server访问IP地址加载到Properties中，当调用notifyConfigInfoChange时，会遍历所有的节点信息逐个通过httpGet请求发送指定的dataId和Group的数据变更请求；当其他Server接收到Notify请求时，会调用ConfigService的loadConfigInfoToDisk方法，将数据库中的配置信息加载到磁盘中（包含cache中的Md5值的变更）；备注：这里的疑惑点是，当server水平扩展的时候，如何动态配置server的节点数据？Server的列表是从另外一台Http Server中获取，并一段时间更新一次；当然Diamond的这个版本没实现这个功能，默认的实现是静态加载node的方式； 磁盘操作服务（DiskService）： 此服务就是将配置信息写入本地磁盘，唯一需要注意的点是，并发写的控制，这里使用的是ConcurrentHashMap的putIfAbsent方法，当正在写的时候将key设人map，写完后，remove掉。 定时任务服务（TimerTaskService）： 服务启动的时候就起了一个scheduledExecutorService，将DumpConfigInfoTask加入其中，使用配置中的间隔时间，默认是600秒（10分钟）；DumpConfigInfoTask做的事情就是分页查询数据库里面的配置信息，然后批量更新到本地磁盘文件中，并修改ConfigService缓存中的数据Md5值；总结：从server的实现上，我们可以学习到以下几点 使用MD5来比较文件内容是否发生变化； 多服务节点之间怎么做数据同步； 使用乐观锁来做文件的并发写操作； Client的实现： 监听器： DefaultSubscriberListener 为默认的业务监听器集合，管理了所有注册进来的DataId监听器，当DefaultSubscriberListener收到配置信息时，会从所有dataId的监听器中找到关心此diataid的监听器集（Map的Key），然后逐个做异步的事件通知；ManagerListener 是针对一个dataId的配置信息进行监听的监听器接口，需要用户自己实现接收到数据的处理方式； 订阅者： 通过工程类DiamondClientFactory实现单例订阅者DefaultDiamondSubscriber，DefaultDiamondSubscriber 管理业务监听器聚集、Diamond的基本配置、本地配置处理器、Snapshot配置处理器、服务地址处理器等；DefaultDiamondSubscriber 实现了DiamondClientSub，拥有启动和终止’定时获取配置信息‘的方法：start()、stop(); start()方法中会间隔一段时间轮询一次配置信息的变更； 轮询配置信息的变更分为三部分： 检查本地文件的配置信息LocalConfigInfoProcessor； 检查远程DiamondServer上的配置信息变更，DiamondServer那么多配置信息，如何知道那些更新了呢？原因很简单，远程DiamondServer上配置信息多，但是应用里面使用的配置信息是一定的，找出缓存里面的所有配置信息，然后排除掉那些指定使用本地文件配置信息的DataId后把所有的DataId:Group:Md5拼接成一个文本（每行一条数据），通过http请求DiamondServer，查看这批配置里面那些dataId的Md5发生了变更，对发生了变更的dataId等信息拼接起来作为响应内容，客户端拿到这些变化了的dataid后，逐条向DiamondServer请求具体的内容数据，然后将数据发送给监听了此dataId的监听器，并保存数据到SNAPSHOT中； 检查SNAPSHOT中配置文件；对没有获取本地配置，也没有成功从diamond server获取到配置的DataId，加载上一次的SNAPSHOT信息； 数据处理器： Diamond提供了三种数据处理器，本地配置文件处理器LocalConfigInfoProcessor（配置文件存放于~/diamond/data/config-data/组名/dataId名）、Diamond远程服务配置文件处理器ServerAddressProcessor（从DiamondServer上获取配置信息）、快照配置文件处理器SnapshotConfigInfoProcessor（配置文件存放于~/diamond/snapshot/组名/dataId名） 当我们在~/diamond/data/config-data下放置了配置信息时，优先使用本地配置文件（如果存在此配置，则此配置会被标识为使用本地），如果本地文件与内存中的配置有差异时会触发内存数据更新，即popConfigInfo给此dataId的监听器发信息；如果没差异则跳过；被标识使用本地配置的dataId，在进行远程DiamondServer配置检查的时候，是被跳过的； 无论使用本地配置还是远程配置，都会将配置信息保存到本地快照中（popConfigInfo中实现），用户当Diamond不可用的时候，可以从SNAPSHOT中进行加载； 从实现上我们了解到Diamond的配置信息是异步获取到的，那我们在使用时，如何保证第一次读取一定能拿到配置信息呢？ 原因：自己在实现ManagerListener的时候，构造函数中可以使用默认的DefaultDiamondManager，然后主动调用defaultDiamondManager.getAvailableConfigureInfomation(5000)来获取配置信息； DefaultDiamondManager中getConfigureInfomation 和 getAvailableConfigureInfomation 方法的区别：getConfigureInfomation只从本地和远程DiamondServer上获取配置信息；getAvailableConfigureInfomation 首先会从本地和远程DiamondServer上获取配置信息，如果都没有则从SNAPSHOT中加载配置信息； 总结：从Client的实现上，我们学习到以下几点 如何做多级容灾策略（强制指定配置、从DiamondServer上拉取配置 或 使用SNAPSHOT中的配置）； 订阅者模式的应用； 接口设计上的巧妙，给用户留了很多可以自由选择的地方，比如接收到数据内容后的格式处理、初始化获取配置的方式等； 合理的使用cache；","categories":[{"name":"Middleware","slug":"Middleware","permalink":"http://heartaway.cn/categories/Middleware/"}],"tags":[]},{"title":"成为我想成为的人","slug":"Think/2015-06-25-be-myself","date":"2015-08-24T16:00:00.000Z","updated":"2018-11-09T14:30:55.042Z","comments":true,"path":"2015/08/25/Think/2015-06-25-be-myself/","link":"","permalink":"http://heartaway.cn/2015/08/25/Think/2015-06-25-be-myself/","excerpt":"","text":"人需要每隔一段时间进行一次自省。在自省中矫正自己的步伐，放下过于称重的包袱，这样才能轻松上阵，不至于迷失方向；自省也是一种跳出繁杂的日常琐事，站在圈外看问题的一种方式，当我们每天沉浸在工作、生活中时，很容易一叶蔽目不见泰山，在这种场景下作出的的决策，往往都是片面、短视、偏本性的。古人云：当局者迷，旁观者清，说的就是这个道理，因为旁观者站在圈外，以一种全局的视角看到问题。 伯昊说过一句话：当一个人清醒的时候，他是用思想在做事情；当一个人处于情绪低谷的时候，左右他想法的是他的本性或者潜意识，但这个潜意识对他们的影响是非常大的，往往决定了他一生的发展。最近我对这句话感受特别深，因为我正处于情绪的低谷，而我表现出来的状态跟之前努力奋进时是截然不同的，消极、怠慢、抱怨，对待事情不像以前那样有激情了，有时候还会萌发放弃的念头，不过这也符合人的本性，遇到外部的刺激就会偏向于保护自己，偏向于舒适的环境。以前我总是告诫自己，任何事情都要认真负责，尽量把事情做好，做到超出预期；但是在自己很不爽或者受委屈的时候，很想说，“去他妹的工作，老子不干了，你牛逼你来呀！”，当然这也就是想想而已，因为生活还要继续，我还没有强大到可以撂挑子的程度。我需要调整自己的状态，让自己跳出繁琐的工作，看清自己当前的处境，做什么才是最有价值的，而不是不会拒绝，一味的任何事情都全盘接受。有时候有些事情我来做并不是最合适的，别人来做可能效率更高；从全局来将，让合适的人来做合适的事情是实现效率最大化的基本原则。什么是老板，老板就是从最里层，一圈一圈的跳到了外圈，最后到达了一个很大的圈外，这个时候再回过头来看里面的是是非非，一目了然，清清楚楚，那种俯视全局的视野才让他之所以成为老板。 创业，是很多人的梦想，但是当自己在实践这个梦想的时候，并没有感到那么快乐，因为你会遇到巨大的压力和挑战，让你很不舒服，而且这种压力是持续的，不是三五天，而是一连就是好几个月。也许你在前几个月或者半年都非常有激情，每天晚上都可以到凌晨三四点，当激情不再了还是这么累，还不时遭受指责时，你一定会反弹，这个时候有些人就会选择离开，这种离开可能是因为觉得团队变得陌生，没有自己的位置，没有任何的话语权，纯粹的沦为执行者，可能是对公司前景发展的堪忧，可能是搜委屈了，也可能是领到手的面包太小，无论那种原因，我觉得他的领导都应该反思，但是在我们这个公司，走了一个又一个，老板没有一丝的自责，反而是说xx和xy太不够意思了，来转一圈就走了。思考问题的方式不同，营造出来的企业文化就不同。说来也挺悲哀的，到目前位置，当同学问到我们公司的规则和文化时，我竟然无言以对，我不知道这是好呢还是不好，不过我觉得我们公司缺少了一种东西，叫人情。大家之间有的只是工作的配合，除了工作之外，就没有其它的了。虽然身处一个战壕，但是我向东，你向西，仅此而已。 说道梦想这东西，很是奇怪，你说他没有吧，他就存在在那里，还不时的想起，你说他应该成为你前进奋斗的目标吧，他似乎又显得那么弱不禁风，让你毫无靠近他的动力。“很多时候你认为你会成为什么样的人时，你就会成为这样的人”伯昊说，虽然不是他的原创，但是我比较赞同，因为你认为你是什么样的人的时候，你在潜意识会把自己朝那个方向靠。我既然赞同，那我想成为什么样的人呢？我初中就有一个梦想，那就是“成为一家公司的CEO”，那要想成为一个出色的CEO，需要具备那些素质呢，那这些素质在我当前的创业公司的环境里面是否可以学习到呢？这样想想还有点小激动。接下来就是怎么实践，怎么一步一步的向外圈跳跃了。 嗯，对，成为我想成为的人。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Java 中的单例模式","slug":"Java/2015-06-02-java-singleton-four-method","date":"2015-06-01T16:00:00.000Z","updated":"2018-11-09T14:21:29.044Z","comments":true,"path":"2015/06/02/Java/2015-06-02-java-singleton-four-method/","link":"","permalink":"http://heartaway.cn/2015/06/02/Java/2015-06-02-java-singleton-four-method/","excerpt":"","text":"方案一：非延迟加载单例类1234567public class Singleton &#123; private Singleton()&#123;&#125; private static final Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125; 方案二：简单的同步延迟加载12345678public class Singleton &#123; private static Singleton instance = null; public static synchronized Singleton getInstance() &#123; if (instance == null) instance ＝ new Singleton(); return instance; &#125; &#125; 方案三：双重检查成例延迟加载12345678910111213public class Singleton &#123; private static volatile Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance ＝ new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 为什么不将 synchronized 关键字加载静态方法上呢？原因是，如果加载方法上，每次获取都会加锁，效率降低了很多。如果加载内部为空的方法里面，则只是在初始化的时候加锁一次。在可能的情况下,一般尽量将要同步的代码最小化, 这样可以达到线程的阻塞最小化。 方法四：类加载器延迟加载123456789public class Singleton &#123; private static class Holder &#123; static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return Holder.instance; &#125; &#125; 推荐方式四，利用内部类初始化时才进行单例类的初始化，实现了延迟加载，而且防止了并发，且避免使用锁的开销。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java 内存管理可视化","slug":"Java/2015-03-26-java-mem-visualization","date":"2015-03-25T16:00:00.000Z","updated":"2018-11-09T14:21:21.820Z","comments":true,"path":"2015/03/26/Java/2015-03-26-java-mem-visualization/","link":"","permalink":"http://heartaway.cn/2015/03/26/Java/2015-03-26-java-mem-visualization/","excerpt":"","text":"开源项目：https://github.com/kittylyst/jfx-mem 提供给我们一个Java内存分配和GC的可视化过程。 运行方法：下载代码到本地，使用IDEA打开工程，新建配置，选择“Application”。 区块解释：eden区用户新分配内存区，也是使用最为频繁的区域，一般线程的TLAB（Thread Local Allocation Buffer）都是在eden去开辟，且线程间隔离。eden区 、survivor区、old区的内存之和为Heap区，其中eden区与servivor为Young Gen（新生代）。当eden区满后会触发一次YGC，eden区中还需要被使用的对象会被移到survivor区中（survivor一般为2个，也成为from区、to区），这样整个Eden区都是未被使用的空间，可共继续创建对象，当Eden区再次用完，再触发一次Yong GC，将Eden区和From区还在被使用的对象复制到To区，下一次Yong GC则是将Eden区和To区的还被使用的对象复制到From区。因此，进过多次Yong GC，某些对象会在From区和To区多次复制，如果超过某个阀值对象还未被释放，则将该对象复制到Old Generation。如果Old Generation空间也用完，那么就会触发一次Full GC，即所谓的全量回收，全量回收会对系统性能产生较大影响，因此应根据系统业务特点和对象周期，合理设置Yong Generation 和 Old Generation大小，尽量减少 Full GC。为什么Full GC会对系统性能产生较大影响，原因是Full GC不可避免的需要“stop the world” 让应用程序的所有经常暂停。 执行过程：从动画中我们还可以看出，Old区采用的跟踪计数器（相对于引用计数器）的算法是：标记-清除-压缩 的方式，那我们常用的跟踪计数器的算法有那些呢，各有什么优缺点？ 常见的垃圾回收方法有：1. 复制；从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效； 2. 标记-清除；从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；弊端是造成内存碎片，可能内存有500M，当需要100M时就没有内存了，需要触发一次FGC。 3. 标记-压缩；标记形式和“标记清除”一样，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高； 新时代中对象存活时间比较短，YGC次数也比较多，故可以采用效率比较高的复制策略，YGC触发时，把Eden区和From区还存在应用关系的复制到To区中，下一次是把Eden区和To区复制到From区。 新时代可用的GC方法和老年代可用的GC方法是不一样的： 新时代可用GC方法：串行GC（Serial GC）、并行回收GC（Parallel Scavenge）、并发GC（ParNew） 老年代可用GC方法：串行GC（Serial MSC）、并行GC（Parallel MSC）、并发GC（CMS） GC 的组合类型（每个参数类型都对应了YGC、FGC采用的GC策略）： 参数 描述 UseSerialGC 虚拟机运行在Client模式的默认值，打开此开关参数后，使用Serial+Serial Old收集器组合进行垃圾收集。 UseParNewGC 打开此开关参数后，使用ParNew+Serial Old收集器组合进行垃圾收集。 UseConcMarkSweepGC 打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。 UseParallelGC 虚拟机运行在Server模式的默认值，打开此开关参数后，使用Parallel Scavenge+Serial Old收集器组合进行垃圾收集。 UseParallelOldGC 打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。 查看我们小二后台的jvm参数设置，我们使用的是CMS方式： -XX:+UseConcMarkSweepGC 表示使用CMS策略；CMS策略默认只做标记-清除，并不做压缩，如果期望FGC的时候，同时做压缩，解决内存碎片的问题，可以采用的方式是添加参数： -XX:+UseCMSCompactAtFullCollection； -XX:CMSInitiatingOccupancyFraction=80 表示只有在第一次Old区使用率超过80%时，自动触发CMS GC，后面都是使用HotSpot VM自动计算出来的值。 -XX:+UseCMSInitiatingOccupancyOnly 表示命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。 -XX:+CMSClassUnloadingEnabled 相对于并行收集器，CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，可用设置标志-XX:+CMSClassUnloadingEnabled。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。如果想更深入了解CMS收集器的原理，可以参考：http://ifeve.com/useful-jvm-flags-part-7-cms-collector/ 从上图中可以看出，Old区满了，即将做一次FGC，如果FGC后内存还是满了，就会触发OutOfMemory。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"小二后台CPU使用率超高的问题排查","slug":"Java/2015-03-25-crm-cpu-high-analysis","date":"2015-03-24T16:00:00.000Z","updated":"2018-11-09T14:21:16.140Z","comments":true,"path":"2015/03/25/Java/2015-03-25-crm-cpu-high-analysis/","link":"","permalink":"http://heartaway.cn/2015/03/25/Java/2015-03-25-crm-cpu-high-analysis/","excerpt":"","text":"排查方法： 首先找到cpu使用率高的进程：1top 查看进程对应的应用信息：1ps -ef |grep 进程id 发现是小二后台的进程，由于没有配置gc日志，所以看不当gc日志，但是可通过其他方法排查； 打印堆栈信息，查找占用大量CPU的线程：1jstack 查看GC情况：1jstat -gc 每列的含义： S0C Current survivor space 0 capacity (KB). 当前survivor0的容量 S1C Current survivor space 1 capacity (KB). 当前survivor1的容量 S0U Survivor space 0 utilization (KB). survivor0的使用 S1U Survivor space 1 utilization (KB). survivor1的使用 EC Current eden space capacity (KB). 当前eden的容量 EU Eden space utilization (KB). eden的使用 OC Current old space capacity (KB). 当前old的容量 OU Old space utilization (KB). old的使用 PC Current permanent space capacity (KB). 当前perm的容量 PU Permanent space utilization (KB). perm的使用 YGC Number of young generation GC Events. young gc的次数 YGCT Young generation garbage collection time. young gc的总时间 FGC Number of full GC events. full gc的次数 FGCT Full garbage collection time. full gc的总时间 GCT Total garbage collection time. 所有gc的总时间 从上图看到 Yong GC 次数不变，但是FGC的次数几乎每4s一次，一般FGC的触发是由于YGC触发，但是这个就比较特殊了，难道是主动调用了FGC？不会呀，从我们的启动脚本上看，我们禁止了主动调用GC(-XX:+DisableExplicitGC)。重启后，发现没有再频繁的FGC了，恢复了正常，此时我们也同时开启了GC日志（-verbose:gc -Xloggc:/home/admin/logs/gc.log）。 但是一天后又出现了同样的情况，CPU使用率飙高，FGC频繁，此时内存使用为1.3G。那有没有可能是大对象在Eden内存不够分配，直接进入Old区，而Old区也不够触发了FGC呢？ 通过分析，这种情况不台可能，首先我们看了Eden和Old区还剩余大量内存，通过Jmap也没有发现大对象。其次，我们使用的GC收集器是CMS，这种情况，CMS必定会触发YGC，因为CMS无法回收New区（至于为什么还需要查一些文档）。 根据之前毕玄大师给出的GC频繁的排查方法： CMS GC频繁 的原因可能是缺少UseCMSInitiatingOccupancyOnly参数，而触发了JVM的悲观策略。 那什么是JVM的悲观策略呢？JVM自动触发GC(JVM的动态策略)，是基于之前GC的频率以及旧生代的增长趋势来评估决定什么时候开始执GC；如果不希望JVM自行决定，可以通过-XX：UseCMSInitiatingOccupancyOnly=true来制定； 旧生代剩余的空间（available）大于新生代中使用的空间（max_promotion_in_bytes），或者大于之前平均晋升的old的大小（av_promo），返回false。cms gc是每隔一个周期（默认2s）就会做一次这个检查，如果为false，则不执行YGC，而触发cms gc。 对于悲观策略的解释换句话说： 当Minor GC时如果存活对象过多，无法完全放入Survivor区，就会向老年代借用内存存放对象，以完成Minor GC。在触发Minor GC时，虚拟机会先检测之前GC时租借的老年代内存的平均大小是否大于老年代的剩余内存，如果大于，则将Minor GC变为一次Full GC，如果小于，则查看虚拟机是否允许担保失败，如果允许担保失败，则只执行一次Minor GC，否则也要将Minor GC变为一次Full GC。说白了，新生代放不下就会借用老年代的空间来进行GC。查看GC的log日志：（由于被重启了所以被请清理掉了，但是看到CMS后的内存比CMS前的还大），类似： 12015-03-26T18:18:06.349+0800: 7.092: [GC 7.092: [ParNew: 471872K-&gt;471872K(471872K), 0.0000420 secs]7.092: [CMS: 366666K-&gt;524287K(524288K), 27.0023450 secs] 838538K-&gt;829914K(996160K), [CMS Perm : 3196K-&gt;3195K(131072K)], 27.0025170 secs] ParNew的时间特别短，jvm在FGC前会首先确认old区是不是足够大，如果不够大，这次YGC直接返回，进行MSC。综合以上判断可能是触发了JVM的悲观策略，所以在JVM的启动参数中添加了-XX：UseCMSInitiatingOccupancyOnly=true，在观察一段时间内存使用情况。 其他思考：为什么生产环境只有小二后台出现了这个情况，其他应用没有呢？ 目前我们小二后台配置的Heap的大小为1G，GC的策略为CMS方式，但是毕玄写过一片文章叫做《为什么不建议&lt;=3G的情况下使用CMS GC》；而其他应用大部分配置的Heap区大小为2G；淘宝线上应用基本配置均为4核8G，配置的Heap大小为4G，所以一般GC采用CMS，并开启UseCMSInitiatingOccupancyOnly，非常明确的GC策略，方便问题排查。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"学着选择","slug":"Think/2014-10-07-learn-choise","date":"2014-10-06T16:00:00.000Z","updated":"2018-11-09T14:31:00.598Z","comments":true,"path":"2014/10/07/Think/2014-10-07-learn-choise/","link":"","permalink":"http://heartaway.cn/2014/10/07/Think/2014-10-07-learn-choise/","excerpt":"","text":"我深信: 今日的失败，都由于过去的不努力。我深信: 今日的努力，必定有将来的大收成。 我没必要再为苍白的过去感到懊悔，过去的就让他如浮云般飘去，珍惜现在的时光，才会让以后的自己不为今天的不努力惋惜。这些大道理每个人都懂，但是很多时候我却选择了安逸、拖延、甚至逃避。计划今天完成的事情，心想先玩一把游戏再说；计划周末要看的书籍，却选择了跟朋友聚会聊天。一切的美好的计划似乎是堕落的说辞，用以敷衍内心渴求上进的良知。 我不是一个会选择的人，在一次次的选择中，我趋向于懦弱、无知、堕落。与我相处一段时间的人基本会给我贴上“沉默寡言”、“懦弱”等标签，看到这样的评价，我想反抗，但力不从心，最终还是不得不接受事实。 我不会选择，所以我希望自己能够逐渐学会选择，一般选择的方法是分析利弊，找出最优解（有点像大学学习的线性规划），或者使用经济学的机会成本理论来坐镇，在其次，就是听从内心的声音，苹果副总裁Heidi Roizen说“我们的内心比自己掌握更多的信息，所以很多时候我们很难做决定时，问一下自己的内心，它其实已经有了答案”。 所以这次面对去与留的选择，谁也不知道那个会更好，每个选择都会有一定的取舍，但是我知道自己内心中想要的东西，我的内心已近帮我做了选择，虽然这个选择会让我放弃目前这个稳定的工作，很多人认为，低风险的事情才是稳定的，但讽刺的是，在瞬息万变的当今社会，寻求稳定反倒是有可能是最大的冒险。 我不是一个主动驱动性的人，或者自认为自主驱动型较弱的人。从牛顿的第一定律，我们知道“力不是维持物体运动的原因，而是改变物体运动状态的原因”，我自己很难改变自己的状态，所以我堵上了自己的一切，来选择了一个能驱使我改变状态的环境。 王安石说：世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。 所以要去加倍努力，不是为了换取成功，不是为了去超越别人，而是一种想去体验更大世界的欲望。","categories":[{"name":"Think","slug":"Think","permalink":"http://heartaway.cn/categories/Think/"}],"tags":[]},{"title":"Android 高效的 Layout","slug":"Android/2014-09-11-layout","date":"2014-09-10T16:00:00.000Z","updated":"2018-11-09T14:16:13.453Z","comments":true,"path":"2014/09/11/Android/2014-09-11-layout/","link":"","permalink":"http://heartaway.cn/2014/09/11/Android/2014-09-11-layout/","excerpt":"","text":"我们知道随着我们业务越来越负责，UI布局也会越来越复杂，大量的布局信息必定会带来一定的性能损耗，那么我们怎么才能写出高效的布局呢？ 1.使用 &lt;include&gt; &lt;merge&gt; &lt;viewStub&gt;标签。https://developer.android.com/training/improving-layouts/optimizing-layout.html 2.LinearLayout中减少使用layout_weight参数，因为使用此属性会导致子元素被测量两次。 3.学会测量Layout的层次结构,优化布局https://developer.android.com/training/improving-layouts/optimizing-layout.html 4.使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）连接真机时，HierarchyVIewer报错了：无法加载设备上的窗口数据 原因：若需要使用hierarchyviewer，需要手机上开启对应的ViewServer服务。Hierarchy Viewer在连接手机时，手机上必须启动一个叫View Server的客户端与其进行socket通信。而在商业手机上，是无法开启View Server的，故Hierarchy Viewer是无法连接到普通的商业手机。 解决办法： 方法一：使用模拟器。 方法二：App中需要开启View Server，可以参考一下连个类的实现。 http://pan.baidu.com/s/1sjIulYl 提取码：wrc8 使用方法： 引入ViewServer.java 类到Util包中，在需要查看Layout层次结构的Activity类中，加入以下代码： 123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); … ViewServer.get(this).addWindow(this);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); ViewServer.get(this).removeWindow(this);&#125;@Overridepublic void onResume() &#123; super.onResume(); ViewServer.get(this).setFocusedWindow(this);&#125; 5.使用Lint工具来优化Layout 使用merge根框架 – 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签； 无用的分支 – 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率 无用的父控件 – 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件 深层次的layout – 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10Lint工具在android Studio中的使用:Analyze → Inspect code 这个时候会自动启动Lint工具。 6.虽然官方说LinearLayout 与 RelationLayout在性能上相差无几，但是能使用relative layout的地方尽量不要使用LinearLayout。 7.有同事对比了RelationLayout 与 FrameLayout的性能，发现FrameLayout性能比RelationLayout更优。原因很简单：因为FrameLayout比RelationLayout更简单，没有那么多属性，所有效率更高。无论是使用那种布局，在都能满足需求的情况下，只要记住，使用属性跟少、更简单的布局方式一定是没错的。http://stackoverflow.com/questions/22875453/framelayout-vs-relativelayout-for-overlays 8.对于textview和imageview组成的layout，直接使用textview替换（drawableTop类似属性）","categories":[{"name":"Android","slug":"Android","permalink":"http://heartaway.cn/categories/Android/"}],"tags":[]},{"title":"Android 之 Listview","slug":"Android/2014-09-01-listview","date":"2014-08-31T16:00:00.000Z","updated":"2018-11-09T14:16:05.056Z","comments":true,"path":"2014/09/01/Android/2014-09-01-listview/","link":"","permalink":"http://heartaway.cn/2014/09/01/Android/2014-09-01-listview/","excerpt":"","text":"ListView显示的三要素： ListView，用来展示列表 Adapter，用来存在数据&amp;将数据与视图进行绑定 数据，将被映射的字符串、图片url等等。 关于Adapter ，请参考 Android 之 Adapter。 ListView 的工作原理：Adapter的作用就是ListView界面与数据交互的桥梁，当列表里面每一项显示到页面上时，都会调用Adapter的getView方法。系统需要回执ListView时，首先会调用getCount()函数，得到要绘制的这个列表额长度，然后开始从第一行开始绘制，每行的回执方法是调用getView函数。那么Android是不是为每一行都会新创建一个View呢？试想加入行数为几万行，内存肯定会爆掉的，所以Android官方早就想到了这一点，在ListView实现中添加了视图的缓存-Recycler，每当有行移除屏幕的可视区域时，这个被移除的行的View对象就会被添加到Recycler中，也就是在渲染新行时的那个参数convertView。 ListView的初始化：疑问一：ListView绘制时是如何获取每行的View的呢？ 首先ListView通过setAdapter方法，将Adapter与ListView关联起来，查看ListView的setAdater方法源码可知，setAdater将传递经来的Adapter的引用复制给了内部全局变量mAdapter，ListView在绘制每行的时候根据行号position调用父类AbsListView中的obtainView，obtainView首先会从recycler中获取是否有匹配的视图，如果存在的话，可以看到则调用adapter.getView方法，并传递了scrapView给convertView变量，否则传递的是null。 疑问二：ListView中数据发生变更了，我们一般会调用Adapter的 notifyDataSetChanged()方法， 那么视图是怎么发生变化的呢？ ListView 中的数据适配器Adapter 采用的是观察者模式（参考之前的”观察者模式“） ListView在setAdapter时，会新建ApdateDataSetObserver，并注册此观察者。 AdapterDataSetObserver类实在AbsListView中定义： AdapterView中AdapterDataSetObserver的实现如下(部分省略)： AdapterDataSetObserver 实现了DataSetObserver接口，并重写了onChanger方法，里面调用了requestLayout方法，此方法的作用是要求parent view 重新调用它的哦弄Measure onLayout方法重新布局视图，但不会重新绘制任何视图包括该调用者本身。requestLayout的实现方法需要到View类中查看：可参考：http://blog.csdn.net/androiddevelop/article/details/8561076 疑问三：RecyclerBin的数据结构是这样的呢？当ListView有多个视图类型（在界面上就是有不同的样式和数据类型）又是怎么选择合适的convertView的呢？首先看一下RecycleBin的类定义（AbsListView中内部类） 从注释中我们就可以得知 ： RecycleBin一共有两个存储结构分别是ActiveViews 和 ScrapViewsActiveViews储存当前在界面(手机显示区域)中显示View，移出界面会存入ScrapViewsScrapViews存储当前已经滑动出当前界面(手机显示区域)显示的View，这些view存储起来相当于回收，当再次请求的时候从此存储中取出反复使用。当ListView中有N个视图类型时，RecycleBin会创建N个scrapView数组，每个类型一个view数组，后面在获取view时会先判断view的类型，然后到对应的数组中去取。 怎么从ScrapViews中获取可用的view视图呢？getScrapView → retrieveFromScrap retrieveFromScrap（这个不属于RecycleBin类，是属于外部类AbslistView中的方法） 根据position，从mScrapView中找： 1. 如果有view.scrappedFromPosition = position的，直接返回该view； 2. 否则返回mScrapView中最后一个； 3. 如果缓存中没有view，则返回null； 下面，我们来分析下这三种情况在什么条件下满足？ a. 第三种情况，这个最简单： 一开始，listview稳定后，显示N个，此时mScrapView中是没有缓存view的，当我们向上滚动一小段距离（第一个此时仍显示部分），新的view将会显示，此时listview会调用Adapter.getView，但是缓存中没有，因此convertView是null，所以，我们得分配一块内存来创建新的convertView； b. 第二种情况： 在a中，我们继续向上滚动，直接第一个view完全移出屏幕（假设没有新的item），此时，第一个view就会被detach，并被加入到mScrapView中；然后，我们还继续向上滚动，直接后面又将要显示新的item view时，此时，系统会从mScrapView中找position对应的View，显然，是找不到的，则将从mScrapView中，取最后一个缓存的view传递给convertView； c. 第一种情况： 紧接着在b中（标示为橙色的文字后面），第一个被完全移出，加入到mScrapView中，且没有新增的item到listview中，此时，缓存中就只有第一个view；然后，我此时向下滑动，则之前的第一个item，将被显示出来，此时，从缓存中查找position对应的view有没有，当然，肯定是找到了，就直接返回了。 ListView使用过程中遇到的问题：Listview 滑动中背景错乱：场景： 我有一个listView作为菜单，当菜单选中时有一个指示器会展示出来，其他的会被隐藏，默认第一个菜单为选中状态，但是当滑动listview时，新加在出来的item中指示器也展示出来了。 原因： 理解了上面的getView和RecycleBin的工作原理之后，这个问题不难定位，肯定是在渲染新行时从scropViews中没有匹配position位置的view，此时默认返回了最后一个view（也就是场景中对应的第一个），这个view是被我们设置了指示器为可见状态，所以就引起了背景的错乱。 解决办法： 对于positon等于我们选择的下标时会指示器可见，当position不等于我们选择的下标时，防止convert被复用，我们需要设置指示器为不可见，也就是else中的代码，之前我只写了if中的代码，却忽略了else中的代码。 这个问题也可以参考：http://www.myexception.cn/mobile/1612364.html","categories":[{"name":"Android","slug":"Android","permalink":"http://heartaway.cn/categories/Android/"}],"tags":[]},{"title":"HTTP学习笔记（二）之HttpClient","slug":"Java/2013-07-04-httpclient","date":"2013-07-03T16:00:00.000Z","updated":"2018-11-09T14:21:04.646Z","comments":true,"path":"2013/07/04/Java/2013-07-04-httpclient/","link":"","permalink":"http://heartaway.cn/2013/07/04/Java/2013-07-04-httpclient/","excerpt":"","text":"HttpClient 是什么：HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 HttpClient 主要功能：实现了所有 HTTP 的方法（GET,POST,PUT,HEAD 等）支持自动转向支持 HTTPS 协议支持代理服务器等HttpClient包下面都有那些内容： HttpClient 的基本使用方法：Get方法：使用 HttpClient 需要以下 6 个步骤： 创建 HttpClient 的实例 创建某种连接方法的实例，在这里是 GetMethod。在 GetMethod 的构造函数中传入待连接的地址 调用第一步中创建好的实例的 execute 方法来执行第二步中创建好的 method 实例 读 response 释放连接。无论执行方法是否成功，都必须释放连接 对得到后的内容进行处理 Demo 示例： 123456789101112131415161718192021222324252627282930//构造HttpClient的实例 HttpClient httpClient = new HttpClient(); //创建GET方法的实例 GetMethod getMethod = new GetMethod(\"http://www.ibm.com\"); //使用系统提供的默认的恢复策略 getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler()); try &#123; //执行getMethod int statusCode = httpClient.executeMethod(getMethod); if (statusCode != HttpStatus.SC_OK) &#123; System.err.println(\"Method failed: \" + getMethod.getStatusLine()); &#125; //读取内容 byte[] responseBody = getMethod.getResponseBody(); //处理内容 System.out.println(new String(responseBody)); &#125; catch (HttpException e) &#123; //发生致命的异常，可能是协议不对或者返回的内容有问题 System.out.println(\"Please check your provided http address!\"); e.printStackTrace(); &#125; catch (IOException e) &#123; //发生网络异常 e.printStackTrace(); &#125; finally &#123; //释放连接 getMethod.releaseConnection(); &#125;&#125; 注意点： HttpClient的恢复策略是指在遇到异常时自动重试的机制，并且可以自定义（通过实现接口HttpMethodRetryHandler来实现）。通过httpClient的方法setParameter设置你实现的恢复策略，demo中使用的是系统提供的默认恢复策略，该策略在碰到IOException的时候将自动重试3次。 用GetMethod将会自动处理重定向，如果想要把自动处理重定向去掉的话，可以调用方法setFollowRedirects(false)。 executeMethod返回值是一个整数，表示了执行该方法后服务器返回的状态码； 获取响应内容的方式有三种：getResponseBody(返回二进制byte流)、getResponseBodyAsString(返回String)、getResponseBodyAsStream(这个方法对返回大量数据处理效率很高)； 乱码：在使用getResponseBodyAsString容易出现乱码，影响响应内容字符编码的地方有两个：第一，Response的header设置，这里的设置编码可能与html内容编码不符，通过method对象的getResponseCharSet()方法就可以得到http头中的编码信息；第二，Respone的body内容中设置了&lt;meta http-equiv=”Content-Type” content=”text/html; charset=GBK”/&gt;或&lt;?xml version=”1.0″ encoding=”GBK”?&gt;标签，这样也可能与header编码冲突造成乱码。 释放连接。无论执行方法是否成功，都必须释放连接。 1method.releaseConnection(); Post方法：PostMethod基本与GetMethod类似； 不同点： POST和PUT，不支持自动重定向，因此需要自己对页面转向做处理。 Proxy代理服务的使用(host绑定)：在日常工作中很多url的访问都是需要绑定host地址的，使用httpClient如何进行绑定访问？ 123HttpClient httpclient = new HttpClient(); // 设置HTTP代理IP和端口 httpclient.getHostConfiguration().setProxy(hostIp, hostIpPort); 支持Https：HttpClient提供了对SSL的支持，允许HttpClient来打开Https连接。 有两种方法可以打开https连接，第一种就是得到服务器颁发的证书，然后导入到本地的keystore中；另外一种办法就是通过扩展HttpClient的类来实现自动接受证书。 方法1参考：处理HTTPS协议 方法2： 实现自己的socket factory，必须实现SecureProtocolSocketFactory接口。 自定义私有类 TrustAnyTrustManager implements X509TrustManager。 定义Protocol ，将socket factory注册到 Protocol中。 12Protocol myhttps = new Protocol(\"https\", new MySecureProtocolSocketFactory(), 443); Protocol.registerProtocol(\"https\", myhttps); Cookie处理： 通过state获取cookie：httpclient.getState().getCookies(); 123CookieSpec cookiespec = CookiePolicy.getDefaultSpec(); cookies = cookiespec.match(\"login.daily.taobao.net\", hostIpPort, \"/\", false, httpClient.getState().getCookies()); CookieSpec接口代表了cookie管理的规范。cookiespec.match获取匹配路径下的cookie数组。 通过state设置cookie: 123456789httpclient.getParams().setCookiePolicy(CookiePolicy.RFC_2109);//RFC_2109是支持较普遍的一个，还有其他cookie协议HttpState initialState = new HttpState();Cookie cookie=new Cookie();cookie.setDomain(\"www.balblabla.com\");cookie.setPath(\"/\");cookie.setName(\"多情环\");cookie.setValue(\"多情即无情\");initialState.addCookie(cookie);httpclient.setState(initialState); cookie协议：RFC 2109（过时的严格策略）、RFC 2965（严格策略的标准符合）、best-match：最佳匹配meta（元）策略(推荐使用)。 携带cookie进行页面访问： 1postMethod.setRequestHeader(\"Cookie\", cookieToString(cookies)); httpClient本身就可以保持cookie，可以通过同一个httpclient进行页面登录访问，但是对于有页面跳转的只能使用自带cookie进行模拟登录后访问。 通过HTTP上传文件：httpclient使用了单独的一个HttpMethod子类来处理文件的上传，这个类就是MultipartPostMethod，该类已经封装了文件上传的细节，我们要做的仅仅是告诉它我们要上传文件的全路径即可。 123456789101112131415ArrayList&lt;Part&gt; partArray = new ArrayList&lt;Part&gt;(); for (int i = 0; i &lt; params.size(); i++) &#123; if (params.get(i) instanceof FileNameValuePair) &#123; partArray.add(new FilePart(params.get(i).getName(), ((FileNameValuePair) params.get(i)).getFile())); &#125; else &#123; postMethod.addParameter(params.get(i).getName(), params.get(i).getValue()); &#125; &#125; Part[] parts = new Part[partArray.size()]; for (int i = 0; i &lt; partArray.size(); i++) &#123; parts[i] = partArray.get(i); &#125; postMethod.setRequestEntity(new MultipartRequestEntity(parts, postMethod.getParams())); int statusCode = httpclient.executeMethod(postMethod); 通过HTTP模拟登录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static String LoginDailyToGetPageWithHost(String nick, String psw, String scopeString, String url, List&lt;NameValuePair&gt; params, String hostIp, Integer hostIpPort) throws IOException &#123; Protocol myhttps = new Protocol(\"https\", new MySecureProtocolSocketFactory(), 443); Protocol.registerProtocol(\"https\", myhttps); HttpClient httpClient = new HttpClient(); Cookie[] cookies; LOGIN_URL = LOGIN_URL + \"?redirectURL=\" + url; PostMethod postMethod = new PostMethod(LOGIN_URL); postMethod.getParams().setParameter(HttpMethodParams.HTTP_CONTENT_CHARSET, \"GBK\"); List&lt;org.apache.commons.httpclient.NameValuePair&gt; nameValues = new ArrayList&lt;org.apache.commons.httpclient.NameValuePair&gt;(); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"TPL_username\", nick)); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"TPL_password\", psw)); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"action\", \"Authenticator\")); /** httpclient post不支持方式重定向,fuck */// nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"TPL_redirect_url\", url)); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"from\", \"tb\")); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"event_submit_do_login\", \"anything\")); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"TPL_checkcode\", \"8888\")); nameValues.add(new org.apache.commons.httpclient.NameValuePair(\"loginType\", \"3\")); postMethod.setRequestBody(nameValues.toArray(new org.apache.commons.httpclient.NameValuePair[nameValues.size()])); try &#123; int status = httpClient.executeMethod(postMethod); System.out.println(status); CookieSpec cookiespec = CookiePolicy.getDefaultSpec(); cookies = cookiespec.match(\"login.daily.taobao.net\", hostIpPort, \"/\", false, httpClient.getState().getCookies()); &#125; catch (Exception e) &#123; System.out.println(\"Exception: \" + e.toString()); return null; &#125; finally &#123; postMethod.releaseConnection(); &#125; int postresult = -1; if (scopeString != null) &#123; url = url + \"&amp;\" + scopeString; &#125; try &#123; URI uri = new URI(url); postMethod.setURI(uri); // 如果不使用cookie 返回状态码 302，跳到i.daily.taobao.net去了，不能直接跳转到我们自己的页面 postMethod.setRequestHeader(\"Cookie\", cookieToString(cookies)); // 设置HTTP代理IP和端口 httpClient.getHostConfiguration().setProxy(hostIp, hostIpPort); if (params != null) &#123; for (int i = 0; i &lt; params.size(); i++) &#123; postMethod.addParameter(params.get(i).getName(), params.get(i).getValue()); &#125; &#125; postresult = httpClient.executeMethod(postMethod); &#125; catch (Exception e) &#123; System.out.println(\"Exception: \" + e.toString()); &#125; finally &#123; postMethod.releaseConnection(); &#125; return postresult + postMethod.getResponseBodyAsString(); &#125; public static String cookieToString(Cookie[] cookie)&#123; StringBuffer cookieBuf = new StringBuffer(256); for(Cookie tmpCookie:cookie)&#123; cookieBuf.append(tmpCookie).append(\";\"); &#125; return cookieBuf.toString(); &#125; MySecureProtocolSocketFactory 的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MySecureProtocolSocketFactory implements SecureProtocolSocketFactory &#123; private SSLContext sslcontext = null; private SSLContext createSSLContext() &#123; SSLContext sslcontext=null; try &#123; sslcontext = SSLContext.getInstance(\"SSL\"); sslcontext.init(null, new TrustManager[]&#123;new TrustAnyTrustManager()&#125;, new java.security.SecureRandom()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return sslcontext; &#125; private SSLContext getSSLContext() &#123; if (this.sslcontext == null) &#123; this.sslcontext = createSSLContext(); &#125; return this.sslcontext; &#125; public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException &#123; return getSSLContext().getSocketFactory().createSocket( socket, host, port, autoClose); &#125; public Socket createSocket(String host, int port) throws IOException, UnknownHostException &#123; return getSSLContext().getSocketFactory().createSocket( host, port); &#125; public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException &#123; return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort); &#125; public Socket createSocket(String host, int port, InetAddress localAddress, int localPort, HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException &#123; if (params == null) &#123; throw new IllegalArgumentException(\"Parameters may not be null\"); &#125; int timeout = params.getConnectionTimeout(); SocketFactory socketfactory = getSSLContext().getSocketFactory(); if (timeout == 0) &#123; return socketfactory.createSocket(host, port, localAddress, localPort); &#125; else &#123; Socket socket = socketfactory.createSocket(); SocketAddress localaddr = new InetSocketAddress(localAddress, localPort); SocketAddress remoteaddr = new InetSocketAddress(host, port); socket.bind(localaddr); socket.connect(remoteaddr, timeout); return socket; &#125; &#125; //自定义私有类 class TrustAnyTrustManager implements X509TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[]&#123;&#125;; &#125; &#125;&#125; HttpClient 使用中的坑： 为什么 返回状态吗 为 200，但是 responebody = null ？原因：在执行完 executeMethod 方法后，立即使用 getMethod.getResponseBodyAsString() 得到的是null，通过在 executeMethod 后面打印出 返回体后在获取 返回内容，这时就能获取到了，添加 if (getresult == HttpStatus.SC_OK) 判断条件后也能获取到，说明 返回值内容不是立即写入的，有延迟。解决方案： 添加 是否成功的判断。 在进行请求的发生时，经常会遇到构建url参数时没有添加协议头:http://,这样会抛状态异常。 new HttpGet(url) 时出现 java.net.URISyntaxException 错误？原因：url 中涉及了特殊字符，如‘｜’‘&amp;’等。所以不能直接用String代替URI来访问。必须采用%0xXX方式来替代特殊字符。但这种办法不直观。所以只能先把String转成URL，再能过URL生成URI的方法来解决问题. 解决方案①： 1234URL url = new URL(strUrl);URI uri = new URI(url.getProtocol(),null, url.getHost(),url.getPort(), url.getPath(), url.getQuery(), null);HttpClient client = new DefaultHttpClient();HttpGet httpget = new HttpGet(uri); 有时候会越到 把http://头也给替换掉了，这样就会引发其它异常，所以还有一种比较保险的做法是使用queryString构建参数部分: 1234String url = \"http://**.**.com/user/deployPackInfoDetail.htm\"; String queryString = \"buildPackageId=\"+ buildPackageId; GetMethod getMethod = new GetMethod(url); getMethod.setQueryString(queryString);","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"HTTP学习笔记（一）之初探","slug":"Java/2013-07-03-http","date":"2013-07-02T16:00:00.000Z","updated":"2018-11-09T14:21:00.725Z","comments":true,"path":"2013/07/03/Java/2013-07-03-http/","link":"","permalink":"http://heartaway.cn/2013/07/03/Java/2013-07-03-http/","excerpt":"","text":"http概览HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 http特征http是应用层协议，由请求和响应构成，支持客户/服务器模式。 http是一个无状态的协议（每次发出的请求都是独立的，和上次的请求是没有关系的，所以如果需要通过http进行模拟登陆，就需要传递登录cookie）。 无连接协议（每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接）。 http服务器Web服务器使用的基本都是http协议，所以web服务器也被称为是http服务器。 http服务器 与 app 服务器 的区别：Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL。与客户端的网络浏览器配合。 应用程序服务器(简称应用服务器)，我们先看一下微软对它的定义：”我们把应用程序服务器定义为“作为服务器执行共享业务应用程序的底层的系统软件”。 通俗的讲，Web服务器传送(serves)页面使浏览器可以浏览，然而应用程序服务器提供的是客户端应用程序可以调用(call)的方法(methods)。确切一点，你可以说:Web服务器专门处理HTTP请求(request)，但是应用程序服务器是通过很多协议来为应用程序提供(serves)商业逻辑 (business logic)。 Apache是纯粹的web服务器，而Tomcat和IIS因为具有了解释执行服务器端代码的能力，可以称作为轻量级应用服务器或带有服务器功能的Web服务器。 详细可参考：http://blog.csdn.net/gideal_wang/article/details/4442525 一个http请求过程： 用户在浏览器中输入一个URL，浏览器首先回去查host文件，如果此域名有对应的ip，如果没有就会根据网络连接里面的DNS地址去查选此URL对于的IP地址，再根据这个IP地址和默认80端口与远程服务器建立socket连接，然后浏览器根据这个URL组装成一个get类型的HTTP请求头，通过outputStream.write 发送到目标服务器，服务器等待inputStream.read返回数据，最后断开连接。 一张HTTP请求过程图示： http 请求头 和 相应头的组成： 123456789101112131415161718192021222324Request Header:Request URL:http://www.taobao.com/Request Method:GETStatus Code:200 OK200 OKRequest Headersview sourceAccept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding:gzip,deflate,sdchAccept-Language:zh-CN,zh;q=0.8Cache-Control:max-age=0Connection:keep-aliveCookie:miid=.....Host:www.taobao.comUser-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1469.0 Safari/537.36Respone Header:Cache-Control:max-age=3600Connection:keep-aliveContent-Encoding:gzipContent-Type:text/html; charset=gbkDate:Wed, 03 Jul 2013 02:03:28 GMTExpires:Wed, 03 Jul 2013 03:03:28 GMTServer:TengineTransfer-Encoding:chunkedVary:Accept-Encoding http 与 TCP 关系：参考之前写的一片文章《Websocket 探究》 http 与socket关系：首先说一下什么是socket，Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，而不是协议。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。Socket 可以支持不同的传输层协议（TCP 或UDP ）。 http连接：是基于TCP协议之上的协议，是短连接； socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉，但会由于网络因素断开，所以经常使用轮询心跳来保持连接； HTTP 是基于Socket 通信的子协议, Socket 收发信息自由, 协议都可由使用者定义。 HTTP 在Socket 基础上做了协议规范, 通信只能按照特定的格式去做, 用户可在HTTP 上做自己的子协议, 如网页浏览,webservice 等.","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Websocket 探究","slug":"Basic/2013-05-02-websocket","date":"2013-05-01T16:00:00.000Z","updated":"2018-11-09T14:16:44.039Z","comments":true,"path":"2013/05/02/Basic/2013-05-02-websocket/","link":"","permalink":"http://heartaway.cn/2013/05/02/Basic/2013-05-02-websocket/","excerpt":"","text":"WebSocket： 基于 HTML5 的一种浏览器与服务器之间的即时通讯解决方案(基于 TCP 连接的双向通道)； Java容器支持：目前只支持 jetty 和 tomcat。 应用场景：即时通讯（网页游戏[双向异步消息模式]，网页聊天，微博等） 一、概念区分：HTTP 协议 与 TCP 协议区别：HTTP协议是应用层协议，是用于www浏览的一个协，应用层协议包括HTTP协议，TELNET协议，WebSocket协议等。Http 协议是请求/响应范式的, 每一个 http 响应都是由一个对应的 http 请求产生的; http 协议是无状态的, 多个 http 请求之间是没有关系的.TCP协议是传输层协议,是机器之间建立连接用的到的一个协议,传输层协议包括TCP协议，UDP协议。 长轮询 、短轮询 、长连接区别:长轮询：首先长轮询并不等于长连接，长轮询还是采用的http短连接，只是服务器端把请求hold。长连接：是多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp 建立关闭所产生的时间消耗。短轮询：服务器收到请求不管是否有数据都直接响应 http 请求; 浏览器受到 http 响应隔一段时间在发送同样的 http 请求查询是否有数据; Http协议 与 webSocket协议关系：WebSocket和Http协议一样都属于应用层的协议，webSocket在第一步进行握手时采用的是Http请求，第二步进行数据流传输是在TCP协议上操作，所以webSocket长连接 跟 Http长连接之间基本没有关系。本质上来说，WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket借用HTTP和HTTPS的端口。由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。 WebSocket连接除了建立和关闭时的握手，数据传输和HTTP没丁点关系了。 二、之前即时通讯的折衷方案： 短轮询(Polling)：定时轮询，一定时间间隔浏览器向服务器发送请求。 长轮询(Long Polling)：浏览器向服务器发送请求，有数据更新时反馈数据，如果服务器端没有新的数据需要发送，这里与Polling方法不同的是，服务器不是立即发送回应给浏览器，而是把这个请求保持住，等待有新的数据到来时，再来响应这个请求；当然了，如果服务器的数据长期没有更新，一段时间后，这个Get请求就会超时，浏览器收到超时消息后，再立即发送一个新的Get请求给服务器。然后依次循环这个过程。 流：流技术方案通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务器端的连接不过期。 折衷方案的缺点： 两次HTTP请求模拟双向通道，增加了编程复杂度。 增加了服务器压力。 制约应用的扩展性。 三、WebSocket原理： 浏览器与服务器建立握手： 浏览器与服务器之间进行双向数据传输; Java中使用方法： 依赖 jetty 服务包： 12345&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty.aggregate&lt;/groupId&gt; &lt;artifactId&gt;jetty-all-server&lt;/artifactId&gt; &lt;version&gt;8.1.9.v20130131&lt;/version&gt;&lt;/dependency&gt; IdeWebSocketServlet 继承 WebSocketServlet 抽象类：必须实现抽象接口方法 doWebSocketConnect()创建websocket的入口.定义 WebSocket连接缓存-new ConcurrentHashMap&lt;String, WebSocket&gt;()；用来管理所有webSocket连接，每次新建连接都会写入map，断开连接也会从map中移除这个元素。 建立WebSocket连接的过程： 定义自己的WebSocket对象,实现 WebSocket.OnTextMessage 接口,比如 SessionWebSocket：实现onOpen、onClose、onMessage 方法。当事件类型较多时，定义一组事件列表， onMessage 中根据事件类型执行相应事件的具体方法。 客户端中Js的写法： 12345678910111213141516171819202122232425262728293031323334function connect() &#123; var target = document.getElementById('target').value; if (target == '') &#123; alert('Please select server side connection implementation.'); return; &#125; if ('WebSocket' in window) &#123; ws = new WebSocket(target); &#125; else if ('MozWebSocket' in window) &#123; ws = new MozWebSocket(target); &#125; else &#123; alert('WebSocket is not supported by this browser.'); return; &#125; ws.onopen = function () &#123; setConnected(true); log('Info: WebSocket connection opened.'); &#125;; ws.onmessage = function (event) &#123; log('Received: ' + event.data); &#125;; ws.onclose = function () &#123; setConnected(false); log('Info: WebSocket connection closed.'); &#125;; &#125; function updateTarget(target) &#123; if (window.location.protocol == 'http:') &#123; document.getElementById('target').value = 'ws://' + window.location.host + target; &#125; else &#123; document.getElementById('target').value = 'wss://' + window.location.host + target; &#125; &#125; WebSocket优势： 从服务器上主动给客户端推送信息； 比Http协议传输效率高；WebSocket劣势： 浏览器支持的兼容性不好，对于IE，支持IE10； WebSocket为什么要把message分成frame：因为HTTP协议有chunk功能，可以让服务器一边生数据，一边发。而websocket协议也考虑到了这点。如果没有framing功能，那么我必须知道整个message的长度之后，才能开始发送message的data。 长连接误解：关于 http 长连接一个误解就是服务器主动推送数据, 这个在 http 协议下是无法实现的, 因为 http 请求/响应范式决定的, http 中服务器返回数据必须要有一个浏览器端的请求对应, 服务器无法主动推送给浏览器数据. 长短轮询策略：不管 http 长轮询还是 http 短轮询 保证同一个用户在多 tab 下只存在一个定时查询是有好处的, 这可以通过在浏览器端缓存数据解决, 在 http 响应后在浏览器端缓存数据, 并设置一个有效期, 然后在每次发送 http 请求时检查是否有有效数据, 没有则发送请求获取。","categories":[{"name":"Basic","slug":"Basic","permalink":"http://heartaway.cn/categories/Basic/"}],"tags":[]},{"title":"Java基础 之 final 和 static","slug":"Java/2013-04-30-java-final-static","date":"2013-04-29T16:00:00.000Z","updated":"2018-11-09T14:20:53.349Z","comments":true,"path":"2013/04/30/Java/2013-04-30-java-final-static/","link":"","permalink":"http://heartaway.cn/2013/04/30/Java/2013-04-30-java-final-static/","excerpt":"","text":"final1.final变量：当你在类中定义变量时，在其前面加上final关键字，那便是说，这个变量一旦被初始化便不可改变，这里不可改变的意思对基本类型来说是其值不可变，而对于对象变量来说其引用不可再变。其初始化可以在两个地方，一是其定义处，也就是说在final变量定义时直接给其赋值，二是在构造函数中。这两个地方只能选其一，要么在定义时给值，要么在构造函数中给值，不能同时既在定义时给了值，又在构造函数中给另外的值。对象变量不可变是指向对象的地址引用不变，对象内部还是可以变化的。 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 另外方法中的内部类在用到方法中的参变量时，此参变也必须声明为final才可使用 2.final方法如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。使用final方法的原因有二：第一、把方法锁定，防止任何继承类修改它的意义和实现。第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 3.final类final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。 4.final 方法变量为什么需要在方法变量前添加final，使用场景是什么？参考：《Java基础 之 方法参数传递》 static被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用 用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块 1.static变量按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 2.static方法静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。 3.static代码块static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 4、static和final一块用表示什么static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！对于变量，表示一旦给值就不可修改，并且通过类名可以访问。对于方法，表示不可覆盖，并且可以通过类名直接访问。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 序列化与反序列化","slug":"Java/2013-04-29-java-seriailze-and-un","date":"2013-04-28T16:00:00.000Z","updated":"2018-11-09T14:20:48.830Z","comments":true,"path":"2013/04/29/Java/2013-04-29-java-seriailze-and-un/","link":"","permalink":"http://heartaway.cn/2013/04/29/Java/2013-04-29-java-seriailze-and-un/","excerpt":"","text":"为什么需要对象序列化：解决Java对象在网络上传输和Java对象持久化的问题。序列化将对象转换为二进制流，然后在网络上传输，当抵打目的后在反序列化为Java对象。 什么是Java对象序列化 Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存（持久化）指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。 使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。 除了在持久化对象时会用到对象序列化之外，当使用RMI（远程方法调用），或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，在本文的后续章节中将会陆续讲到。 Java对象的序列化和反序列化实践当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。 把 Java 对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为 Java 对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 在网络上传送对象的字节序列。 只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。 Externalizable 接口继承自 Serializable 接口，实现Externalizable 接口的类完全由自身来控制序列化的行为，而仅实现Serializable 接口的类可以采用默认的序列化方式 。 对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的 writeObject() 方法写对象。对象反序列化的步骤如下： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的 readObject() 方法读取对象。下面让我们来看一个对应的例子，类的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.Date;public class ObjectSaver &#123; public static void main(String[] args) throws Exception &#123; ObjectOutputStream out = new ObjectOutputStream (new FileOutputStream(\"D:\"\"objectFile.obj\")); // 序列化对象 Customer customer = new Customer(\" 阿蜜果 \", 24); out.writeObject(\" 你好 !\"); out.writeObject(new Date()); out.writeObject(customer); out.writeInt(123); // 写入基本类型数据 out.close(); // 反序列化对象 ObjectInputStream in = new ObjectInputStream (new FileInputStream(\"D:\"\"objectFile.obj\")); System.out.println(\"obj1=\" + (String)in.readObject()); System.out.println(\"obj2=\" + (Date)in.readObject()); Customer obj3 = (Customer)in.readObject(); System.out.println(\"obj3=\" + obj3); int obj4 = in.readInt(); System.out.println(\"obj4=\" + obj4); in.close(); &#125;&#125;class Customer implements Serializable &#123; private String name; private int age; public Customer(String name, int age) &#123; this.name = name; this.age = age; &#125; public String toString() &#123; return \"name=\" + name + \", age=\" + age; &#125;&#125; 输出结果如下： 1234obj1= 你好 !obj2=Sat Sep 15 22:02:21 CST 2007obj3=name= 阿蜜果 , age=24obj4=123 因此例比较简单，在此不再详述。 实现 Serializable 接口ObjectOutputStream 只能对 Serializable 接口的类的对象进行序列化。默认情况下，ObjectOutputStream 按照默认方式序列化，这种序列化方式仅仅对对象的非 transient 的实例变量进行序列化，而不会序列化对象的 transient 的实例变量，也不会序列化静态变量。 当 ObjectOutputStream 按照默认方式反序列化时，具有如下特点： 如果在内存中对象所属的类还没有被加载，那么会先加载并初始化这个类。如果在 classpath 中不存在相应的类文件，那么会抛出 ClassNotFoundException ； 在反序列化时不会调用类的任何构造方法。如果用户希望控制类的序列化方式，可以在可序列化类中提供以下形式的 writeObject() 和 readObject() 方法。 12private void writeObject(java.io.ObjectOutputStream out) throws IOExceptionprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; 当 ObjectOutputStream 对一个 Customer 对象进行序列化时，如果该对象具有 writeObject() 方法，那么就会执行这一方法，否则就按默认方式序列化。在该对象的 writeObjectt() 方法中，可以先调用ObjectOutputStream 的 defaultWriteObject() 方法，使得对象输出流先执行默认的序列化操作。同理可得出反序列化的情况，不过这次是 defaultReadObject() 方法。 有些对象中包含一些敏感信息，这些信息不宜对外公开。如果按照默认方式对它们序列化，那么它们的序列化数据在网络上传输时，可能会被不法份子窃取。 对于这类信息，可以对它们进行加密后再序列化，在反序列化时则需要解密，再恢复为原来的信息。 默认的序列化方式会序列化整个对象图，这需要递归遍历对象图。如果对象图很复杂，递归遍历操作需要消耗很多的空间和时间，它的内部数据结构为双向列表。 在应用时，如果对某些成员变量都改为 transient 类型，将节省空间和时间，提高序列化的性能。 实现 Externalizable 接口Externalizable 接口继承自 Serializable 接口，如果一个类实现了Externalizable 接口，那么将完全由这个类控制自身的序列化行为。 Externalizable 接口声明了两个方法： 12public void writeExternal(ObjectOutput out) throws IOExceptionpublic void readExternal(ObjectInput in) throws IOException , ClassNotFoundException 前者负责序列化操作，后者负责反序列化操作。 在对实现了 Externalizable 接口的类的对象进行反序列化时，会先调用类的不带参数的构造方法，这是有别于默认反序列方式的。 如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为 private 、默认或 protected 级别，会抛出 java.io.InvalidException: no valid constructor 异常。 可序列化类的不同版本的序列化兼容性凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量：private static final long serialVersionUID;以上 serialVersionUID 的取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的 源代码 作了修改，再重新编译，新生成的类文件的serialVersionUID 的取值有可能也会发生变化。 类的 serialVersionUID 的默认值完全依赖于 Java 编译器的实现，对于同一个类，用不同的 Java 编译器编译，有可能会导致不同的serialVersionUID ，也有可能相同。为了提高哦啊 serialVersionUID 的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID ，为它赋予明确的值。显式地定义 serialVersionUID 有 两种用途： 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 serialVersionUID ； 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 serialVersionUID 。 “transient”——“瞬态适用场景： 不打算序列化某字段的值，节省空间 传递序列化流的时候，不传递该值等一个实现了serializable的单例类，必须有一个readResolve方法，用以返回他的唯一实例。 有可能由于对于一个实现了Serializable的类进行了扩展，或者由于实现了一个扩展自Serializable的接口，使得我们在无意中实现了Serializable。 复杂对象序列化 当父类继承Serializable接口，所有子类都可以被序列化 子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，数据会丢失），但是子类中属性人能正确序列化 如果序列化的属性是对象，这个对象也必须实现Serializable接口，否则会报错 在反序列化时，如果对象的属性有修改或删减，修改的部分属性会丢失，但不会报错 在反序列化时，如果serialVersionUID被修改，那么反序列化时会失败 如果一个父类没有实现Serializable接口，他的内部类如果不是static的，即使实现了序列化接口，也会序列失败。因为非静态内部类会保存一个指向父类的类型this变量，而序列化类的所有属性必须实现序列化接口，所以要将内部类设置成静态类 List或者Map容器中包含的泛型类型也必须实现Serializable接口，否则也会报java.io.NotSerializableException","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 集合","slug":"Java/2013-04-28-java-collection","date":"2013-04-27T16:00:00.000Z","updated":"2018-11-09T14:20:43.486Z","comments":true,"path":"2013/04/28/Java/2013-04-28-java-collection/","link":"","permalink":"http://heartaway.cn/2013/04/28/Java/2013-04-28-java-collection/","excerpt":"","text":"Java 中的广义集合分两大类，Collection 和 Map ; Set : 成员不能重复HashSet: 外部无序地遍历成员；覆盖了equals方法，注意修改hashCode方法。TreeSet：外部有序地遍历成员；成员要求实现caparable接口，或者使用 Comparator构造TreeSet。LinkedHashSet：外部按成员的插入顺序遍历成员。 List：提供基于索引对成员随机访问。LinkedList可以实现 队列(queue)，栈（stack），双向队列（deque）。注意LinkedList没有同步方法。ArrayList 实现了可变大小的数组.ArrayList缺省情况下自动增长原来一倍的50%,Vector非常类似ArrayList，但是Vector是同步的，ArrayList是非同步的。Vector缺省情况下自动增长原来一倍的数组长度。 Map: 提供一组key-value的键值对Hashtable：是同步的。不允许null为key或value。查找value是通过对key进行散列计算，所以确保key对象，要同时复写equals方法和hashCode方法，而不要只写其中一个。Hashtable原理：通过节点的关键码确定节点的位置，即给定的关键码K，通过一定的函数关系H(散列函数)，得到函数值H(K)，将此值解释为这个节点的存储位置。HashMap:非同步的。允许null 为key 或value。WeakHashMap：是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。IdentityHashMap：它在比较键时，使用的是引用等价而不是值等价性 ，而HashMap使用的是值等价性 使用总结： 如果涉及 堆栈，队列等操作，应该考虑使用List，对需要快速插入元素、删除元素的 使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList 如果程序在单线程的环境中，或者访问仅仅在一个线程中心进行，那就可以考虑使用非同步的类，执行效率高，如果在多线程可能同时操作一个类，应该使用 同步的类； 要特别注意哈希表的使用，作为key的对象要正确覆写equals 和 hashcode 方法。 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。 如果一个HashSet ,Hashtable 或 HashMap被序列化，那么请确认他们的内容没有直接或间接地引用他们自身。 在对List进行循环的时候不要在循环体内对List元素进行remove操作； 探究实现原理：ArrayList实现原理：内部维护了一个数组 和 int 型 大小变量 size； 动态扩容原理：没有显示定义容量的时候，默认开辟10个数组大小空间；每次add的时候调用ensureCapacity方法，判断添加一个元素后是否超过现有容量，如果超过，那么新开辟之前容量的1.5倍，然后将之前的数据拷贝的新的数组当中. 总结：可以看出进行动态扩容实际是进行数组拷贝，这个就会花费一定的时间消耗，所以当我们的数据比较大或者能够与之数据大小的时候，做好提前做一次ensureCapacity，或定义时指定。 LinkedList实现原理:底层采用双向循环列表实现。(可以使用LinkedList来实现队列和栈) Entry类数据模型：一个数据element，两个指针，一个指向前一个节点，名为previous，一个指向下一个节点，名为next，形成双向列表，LinkedList的无参构造函数初始化的时候就实现了链表的循环。 1header.next = header.previous = header HashSet实现原理：HashSet的底层采用HashMap来存放数据，在add的时候调用hashMap的put方法，对应hashmap的key是hashSet的值，value是一个常量对象PRESENT 1private static final Object PRESENT = new Object(); 它的原理就是利用 hashMap的key是不可重复的这一特性来用key存储Set的元素值以达到Set的元素不可重复。 HashMap实现原理: 底层采用 数组链表 作为数据存储模型；Entry[] table； Entry类数据模型：一个泛型Key，一个泛型value，一个指向下一个Entry的指针 next，一个 hash int型值。 put操作： 首先判断key是否为null，为null的话就会去table[0]链循环查找key为null的节点Entry，找到则替换value，无则添加；其次对key的hashcode进行hash得到数组下标 i ，遍历 i 链上的所有节点，判断是否有key重复的，有则替换value，并返回，无则继续；最后在 数组中添加 下标为 i 的 Entry链中第一个节点出添加这个节点。Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。 get操作： 首先判断key是否为null，为null的话就去table[0]链循环查找key为null的节点Entry。不为null，就根据key的hashcode进行hash得到数据下标i ，遍历 下标为 i 的链，查找key元素，如果不存在就返回null。 Hashtable实现原理：底层采用 数组链表 作为数据存储模型；Entry[] table；HashTable和HashMap采用相同的存储机制，二者的实现基本一致.在Hashtable中调用put方法时，如果key为null，直接抛出NullPointerExceptionHashtable是线程安全的，内部的方法基本都是synchronized. ConcurrentHashMap实现原理：基于一个叫Segment数组的，其实和Entry类似。 ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。 WeakHashMap实现原理：内部类Entry继承了WeakReference类，且在构造函数中构造了Key的弱引用，当进行put或者get操作时，都会调用一个函数叫expungeStaleEntries()用来判断，如果key存在弱引用，则进行垃圾回收。 WeakHashMap在不考了命中率的情况下，多用于缓存系统，就是说在系统内存紧张的时候可随时进行GC，但是如果内存不紧张则可以用来存放一些缓存数据。因为如果使用HashMap的话，它里面的值基本都是强引用，即使内存不足，它也不会进行GC。 补充： 集合的排序：Comparator &amp; Comparable当需要排序的集合或数组不是纯数字时，通常使用 Comparator 或 Comparable 实现对象排序或者自定义排序一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离； 集合工具类：Collections（一系列算法的集合，里面属性都是static） 生成单元素集合： Collections.singletonList、Collections.singletonMap、Collections.singleton Checked集合：checkedCollection、checkedList、checkedMap、checkedSet、checkedSortedMap、checkedSortedSet 同步集合：为一些非线程安全的集合类提供同步机制。 查找替换：fill、frequency、indexOfSubList、lastIndexOfSubList、max、min、replaceAll 集合排序：reverse、shuffle、sort、swap、rotate hashCode()方法的作用：hashCode() 是用来产生哈希码的，而哈希码是用来在散列存储结构中确定对象的存储地址的。对于Object类的 hashCode方法，会针对不同对象返回不同的整数，这一般是通过将该对象的内部地址转换为一个整数来实现的，当两个对象是一样的时（equals为true），他们的hashCode码也是相同的。String的hashCode返回值是基于String的内容的，内容相同，hashCode就相同。在集合中很多地方使用了hashCode，比如保证hashSet的元素不重复，保证hashMap的key不重复，提高hashMap存取数据的效率。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 枚举类型","slug":"Java/2013-03-21-java-enum","date":"2013-03-20T16:00:00.000Z","updated":"2018-11-09T14:20:37.061Z","comments":true,"path":"2013/03/21/Java/2013-03-21-java-enum/","link":"","permalink":"http://heartaway.cn/2013/03/21/Java/2013-03-21-java-enum/","excerpt":"","text":"枚举类型的常见使用场景： 枚举类型 作为 错误码集合：123456789101112131415public enum ErrorEnum &#123; TFS_ACCESS_ERROR(\"101\", \"TFS连接失败\") /** * 错误代码 */ private String errorCode； /** * 错误消息 */ private String errorMsg; ErrorEnum(String errorCode, String errorMsg)&#123; this.errorCode = errorCode; this.errorMsg = errorMsg; ｝｝ 定义的枚举 属性都是 枚举类型，这个枚举类型每一个错误吗会对应一个 错误信息； 使用 枚举类型enum 构建一个状态机：利用enum可以为枚举实例添加方法的特性,可以构造状态机。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package enumeration;public class Person &#123; //自己有一个状态 private State s; public Person(State s)&#123;this.s = s;&#125; //调用相应状态下的方法 public void smile()&#123; s.smile(); &#125;; public void cry()&#123; s.cry(); &#125;;&#125;//状态enum State &#123; //高兴状态下的方法实现 Happy &#123; @Override public void smile() &#123; System.out.println(\"Happy Smile\"); &#125; @Override public void cry() &#123; System.out.println(\"Happy cry\"); &#125; &#125;, //悲伤状态下的方法实现 Sad &#123; @Override public void smile() &#123; System.out.println(\"Sad Smile\"); &#125; @Override public void cry() &#123; System.out.println(\"Happy cry\"); &#125; &#125;; //需要实现的方法 public abstract void smile(); public abstract void cry();&#125; 使用 枚举类型enum 构建一个职责链：利用enum可以为枚举实例添加方法的特性,可以构造简单的责任链 。人在高兴,悲伤状态下的笑和哭具有不同的意义. 123456789101112131415161718192021222324252627282930313233package enumeration;public class StringHandler &#123; enum handler &#123; Sensitive &#123; @Override String hand(String msg) &#123; return msg.replace(\"敏感\", \"*\"); &#125; &#125;, HTML &#123; @Override String hand(String msg) &#123; return msg.replace(\"&lt;\", \"[\").replace(\"&gt;\", \"]\"); &#125; &#125;; //枚举实例须实现此方法 abstract String hand(String msg); &#125; //遍历枚举实例处理字符串 public static String hand(String msg) &#123; for (handler h : handler.values()) &#123; msg = h.hand(msg); &#125; return msg; &#125; public static void main(String[] args) &#123; String msg = \"敏感字符,&lt;html&gt;\"; System.out.println(StringHandler.hand(msg)); &#125;&#125; enum 的多路并发：也就是使用 switch。 查看enum 字节码：类： 123public enum EnumTest&#123; START,CLOSE,PAUSE&#125; 编译出来的类似字节码Oolong语言： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.source EnumTest.java.class public final super EnumTest.super java/lang/Enum.field public static final START LEnumTest;.field public static final CLOSE LEnumTest;.field public static final PAUSE LEnumTest;.field private static final $VALUES [LEnumTest;.method public static values ()[LEnumTest;.limit stack 1.limit locals 0.line 1l0: getstatic EnumTest/$VALUES [LEnumTest;l3: invokevirtual [LEnumTest;/clone ()Ljava/lang/Object;l6: checkcast [LEnumTest;l9: areturn.end method.method public static valueOf (Ljava/lang/String;)LEnumTest;.limit stack 2.limit locals 1.line 1l0: ldc_wl3: aload_0l4: invokestatic java/lang/Enum/valueOf (Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;l7: checkcast EnumTestl10: areturn.end method.method private &lt;init&gt; (Ljava/lang/String;I)V.limit stack 3.limit locals 3.line 1l0: aload_0l1: aload_1l2: iload_2l3: invokespecial java/lang/Enum/&lt;init&gt; (Ljava/lang/String;I)Vl6: return.end method.method static &lt;clinit&gt; ()V.limit stack 4.limit locals 0.line 2l0: new EnumTestl3: dupl4: ldc \"START\"l6: iconst_0l7: invokespecial EnumTest/&lt;init&gt; (Ljava/lang/String;I)Vl10: putstatic EnumTest/START LEnumTest;l13: new EnumTestl16: dupl17: ldc \"CLOSE\"l19: iconst_1l20: invokespecial EnumTest/&lt;init&gt; (Ljava/lang/String;I)Vl23: putstatic EnumTest/CLOSE LEnumTest;l26: new EnumTestl29: dupl30: ldc \"PAUSE\"l32: iconst_2l33: invokespecial EnumTest/&lt;init&gt; (Ljava/lang/String;I)Vl36: putstatic EnumTest/PAUSE LEnumTest;.line 1l39: iconst_3l40: anewarray EnumTestl43: dupl44: iconst_0l45: getstatic EnumTest/START LEnumTest;l48: aastorel49: dupl50: iconst_1l51: getstatic EnumTest/CLOSE LEnumTest;l54: aastorel55: dupl56: iconst_2l57: getstatic EnumTest/PAUSE LEnumTest;l60: aastorel61: putstatic EnumTest/$VALUES [LEnumTest;l64: return.end method 从类似字节码可以看出，enum被编译为了 常量类，而且父类是Enum，所以enum定义的类不能在继承其它父类，也不能被其它类集成。枚举类型的field都是 public static final 静态常量类型；初始化属性时 会现调用私有的父类(enum)构造器，然后初始化自己的所有field。构造器只是在构造枚举值的时候被调用。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 super 和 this","slug":"Java/2013-03-18-java-super-this","date":"2013-03-17T16:00:00.000Z","updated":"2018-11-09T14:20:32.144Z","comments":true,"path":"2013/03/18/Java/2013-03-18-java-super-this/","link":"","permalink":"http://heartaway.cn/2013/03/18/Java/2013-03-18-java-super-this/","excerpt":"","text":"super的定义： The super keyword enables a subclass to call the methods and fields of its superclass. It is not an instance of the superclass object but a way to tell the compiler which methods or fields to reference. The effect is the same as if the subclass is calling one of its own methods. this 是对自身对象的一个地址引用，调用的是 invokevirtual。 super 是类似引用 但不是引用的调用，因为 super 实际上是 调用invokespecial 。 12C extends B, B extends A;A a = new C(); 那么为C在堆中分配的内存区域中，分为三块，一块是C自己的，一块是B自己的，一块是A的，在C、B、A中都会有连个变量，super 和 this ；this指向当前区域，super指向父类的内存区域； 从内存分配可以看出this和super变量是属于对象的，所以不能在静态块和静态方法中使用。 this使用场景： 通过this调用另一个构造方法，用法是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。 函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字，而不用this，用了也不为错。 在函数中，需要引用该函所属类的当前对象时候，直接用this。 super的用法： 在子类构造方法中要调用父类的构造方法，用“super(参数列表)”的方式调用，参数不是必须的。同时还要注意的一点是：“super(参数列表)”这条语句只能用在子类构造方法体中的第一行。 当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”来引用父类成员变量，不过这是不必要的。 当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），此时，用“super.方法名(参数列表)”的方式访问父类的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 类的加载与对象初始化","slug":"Java/2013-03-05-java-class-load","date":"2013-03-04T16:00:00.000Z","updated":"2018-11-09T14:20:28.145Z","comments":true,"path":"2013/03/05/Java/2013-03-05-java-class-load/","link":"","permalink":"http://heartaway.cn/2013/03/05/Java/2013-03-05-java-class-load/","excerpt":"","text":"类的加载基本原理所有类都由类装载器载入，载入内存中的类对应一个 java.lang.Class 实例。已被加载的类由该类的类加载器实例与该类的全路径名的组合标识。设有 packagename.A Class ，分别被类加载器 CL1 和 CL2 加载，则系统中有两个不同的 java.lang.Class 实例： &lt;CL1, packagename.A&gt; 和 &lt;CL2, packagename.A&gt; 。 Java类加载器存在一个 Bootstrap Loader （以下简称为 BL ），由 C++ 写成，负责在虚拟机启动后一次性加载 Java 基础类库中的所有类。其他的类装载器由 Java 写成，都是 java.lang.ClassLoader 的子类。除 BL 之外的所有类装载器都有一个 parent 属性，指向其父装载器。查阅 java.lang.ClassLoader 的源码，不难发现类装载器的委托装载方式。如果用户没有使用自定义类加载器，那么默认使用系统类加载器SystemClassLoader(SystemClassLoader) Java 加载器的委派模型： 123456789101112131415161718192021222324 --------------- | Bootstrap | | Class Loader | null --------------- ↑ -----parent---- | Extension | ----------→ | Class Loader | | --------------- | ↑ -----parent---- ------parent-----| URL | | AppClassLoader|| Class Loader| | Class Loader | --------------- ----------------- ↑ ------parent----- | System | | Class Loader | ----------------- ----------------------|------------------------- ------parent---- -----parent----- | User-def | | User-def | | Class Loader | | Class Loader | ----------------- ----------------- 同时，上图还说明了类加载器在Java语言中发挥的很重要的2点作用： 1. 类加载器的委派模型：假设AppClassLoader需要加载一个类，它会首先委托其父加载器ExtClassLoader来加载此 类，ExtClassLoader也会递归性的委托其父加载器(而不是Super，不是继承关系)Bootstrap Loader来加载此类，如果Bootstrap Loader在sun.boot.class.path下找到被加载类时即加载，如果无法找到时再依次由子类加载器去加载。查找顺序是：cache→parent→self .委派模型是针对Java安全而 设计的，这也印证了Java语言的设计初衷：面向网络的编程语言。 但是 我们通过 getParent 方法获取当前加载器的加载器时，如果当前加载器是 ExtClassLoader 通过getParent 会得到null，并不意味着他没有parent，而是这个parent就是由C++编写的bootstrap class loader，他并不是classloader的子类，也就无法使用getParent()方法获得返回了。。Initiating class loader是指那些直接被程序要求加载某类的加载器，而defining class loader就是真正加载了某类的加载器。 2. 命名空间由同一个类加载器所加载的类只能引用该加载器和其父加载器所加载的其他类，这也是类加载器的命令空间的作用。 理解 委派加载的原因：为什么要设计的这么复杂呢？其中一个重要原因就是安全性。比如在Applet中，如果编写了一个java.lang.String类并具有破坏性。假如不采用这种委托机制，就会将这个具有破坏性的String加载到了用户机器上，导致破坏用户安全。但采用这种委托机制则不会出现这种情况。因为要加载 java.lang.String类时，系统最终会由Bootstrap进行加载，这个具有破坏性的String永远没有机会加载。 类的加载的三大步骤： 装载 连接 初始化 装载这个过程就是把一个类型的二进制数据解析为方法区中的内部数据结构，并在堆上建立一个 java.lang.Class 对象的过程。 连接验证：确定类型符合java语言的语义； 准备：创建Java类中的静态域（静态域存在常量区），并将这些域的值设为默认值。 解析：在类型的常量池中寻找类，接口，字段和方法的符合引用把这些符号引用替换成直接引用的过程。 初始化初始化静态变量、静态代码块。（这里的初始化是指 类的初始化，只初始化静态变量；非静态变量的初始化是属于对象初始化，是在类被使用时通过构造函数进行初始化的。类初始化并不会在类加载到内存中后自动完成，是需要类主动触发的） 类的初始化操作 是需要触发的,并且只会执行一次，主要使用场景： 调用了类的main方法 通过反射构建了类的对象 调用了类的静态方法 访问了类的静态属性（如果直接访问父类的静态属性，那么只能导致父类被初始化，子类不会被初始化） 通过new关键字直接构建对象 在顶层Java类中执行assert语句 理解初始化：① 类被加载完成后 只是表明这个类在内存中可以进行调用了。 ② 建立的 java.lang.Class对象作用（参考）；Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。一个堆上的class实例：是连接类实例与方法区数据结构的桥梁，通过class实例，类的实例能够知道类本身的详细构成信息。一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。 完成类的加载后，被加载的类在内存中是个什么样子呢 ？ 初始化初始化 分为 类初始化 和 对象初始化（参考）： 类初始化： 类初始化是需要触发，在上面已经讲到；类初始化只会初始化类的静态变量、静态代码块。而且是按照先父类 后子类的顺序；类的初始化一定是在对象初始化之前完成(静态成员初始化先于非静态成员初始化)； 对象初始化： (原则：类的非静态变量在编译为class文件之后，都会被移到构造函数中初始化；)new 一个对象A，首先会寻找类A的构造函数，系统默认在构造函数最前面添加了super();除非显示声明；执行super();前会为对象的成员变量在堆中分配内存，并且声明变量。（注意这里只是声明）执行super();查找父类的构造函数，原则与2相同，一直到object对象。然后从父类到子类依此顺序执行构造函数； 例如： A a = new A(); 备注：类的成员变量，不管程序有没有显式的进行初始化，Java虚拟机都会先自动给它初始化为默认值。但是方法里面的局部变量声明之后，Java虚拟机就不会自动给它初始化为默认值，因此局部变量的使用必须先经过显式的初始化（基本数据类型作为局部变量是放在栈中）。 理解 继承关系：子类会继承父类的所有域和方法。在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。 理解对象在内存中的资源分配：请参考：Java对象内存结构 理解方法重载：初始化子类时，为什么父类中的方法被子类重载后，父类构造函数调用的这个重载方法却是子类中的那个重载方法？ 请参考： Java中的继承分析 和 Java 的动态绑定 12Parent p1 = new Parent();Parent c1 = new Chield(); 通过 p1、c1 调用的属性成员，都会自动到Parent中找（属性绑定到定义的类型），调用的方法，回到new出来的对象中找（方法绑定到对象）原因是：在Java中，属性绑定到类型，方法绑定到对象！备注： 如果方法是private、static、final的，或者是一个构造器，那么编译器能准确地判断应该调用那个方法，这称为静态绑定，而对其他的方法，要调用那个方法只有根据隐式参数的实际类型来决定，并且在运行时使用动态绑定。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java基础 之 类的初始化顺序和陷阱","slug":"Java/2013-03-04-java-init","date":"2013-03-03T16:00:00.000Z","updated":"2018-11-09T14:20:21.238Z","comments":true,"path":"2013/03/04/Java/2013-03-04-java-init/","link":"","permalink":"http://heartaway.cn/2013/03/04/Java/2013-03-04-java-init/","excerpt":"","text":"在阅读之前 建议先了解一下 Java运行原理 和 Java内存分配机制； JAVA类的初始化顺序给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解。 我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。我们也可以通过下面的测试代码来验证这一点: 123456789101112131415161718192021222324public class InitialOrderTest &#123; // 静态变量 public static String staticField = \"静态变量\"; // 变量 public String field = \"变量\"; // 静态初始化块 static &#123; System.out.println(staticField); System.out.println(\"静态初始化块\"); &#125; // 初始化块 &#123; System.out.println(field); System.out.println(\"初始化块\"); &#125; // 构造器 public InitialOrderTest() &#123; System.out.println(\"构造器\"); &#125; public static void main(String[] args) &#123; new InitialOrderTest(); &#125;&#125; 1234567891011121314151617181920public class InitialOrderTest &#123; // 静态变量public static String staticField = \"静态变量\";// 变量public String field = \"变量\";// 静态初始化块static &#123;System.out.println(staticField);System.out.println(\"静态初始化块\");&#125;// 初始化块&#123;System.out.println(field);System.out.println(\"初始化块\");&#125;// 构造器public InitialOrderTest() &#123;System.out.println(\"构造器\");&#125; 运行以上代码，我们会得到如下的输出结果： 12345静态变量静态初始化块变量初始化块构造器 这与上文中说的完全符合。那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Parent &#123; // 静态变量 public static String p_StaticField = \"父类--静态变量\"; // 变量 public String p_Field = \"父类--变量\"; // 静态初始化块 static &#123; System.out.println(p_StaticField); System.out.println(\"父类--静态初始化块\"); &#125; // 初始化块 &#123; System.out.println(p_Field); System.out.println(\"父类--初始化块\"); &#125; // 构造器 public Parent() &#123; System.out.println(\"父类--构造器\"); &#125;&#125; public class SubClass extends Parent &#123; // 静态变量 public static String s_StaticField = \"子类--静态变量\"; // 变量 public String s_Field = \"子类--变量\"; // 静态初始化块 static &#123; System.out.println(s_StaticField); System.out.println(\"子类--静态初始化块\"); &#125; // 初始化块 &#123; System.out.println(s_Field); System.out.println(\"子类--初始化块\"); &#125; // 构造器 public SubClass() &#123; System.out.println(\"子类--构造器\"); &#125; // 程序入口 public static void main(String[] args) &#123; new SubClass(); &#125;&#125; 运行一下上面的代码，结果马上呈现在我们的眼前： 12345678910父类--静态变量父类--静态初始化块子类--静态变量子类--静态初始化块父类--变量父类--初始化块父类--构造器子类--变量子类--初始化块子类--构造器 现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。 那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。 静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。 Java构造时初始化陷阱让我们先来看两个类：Base和Derived类。注意其中的whenAmISet成员变量，和方法preProcess() 123456public class Base&#123; Base() &#123; preProcess(); &#125; void preProcess() &#123;&#125;&#125; 12345678public class Derived extends Base&#123; public String whenAmISet = \"set when declared\"; @Override void preProcess() &#123; whenAmISet = \"set in preProcess()\"; &#125;&#125; 如果我们构造一个子类实例，那么，whenAmISet 的值会是什么呢？ 1234567public class Main &#123; public static void main(String[] args) &#123; Derived d = new Derived(); System.out.println( d.whenAmISet ); &#125;&#125; 再续继往下阅读之前，请先给自己一些时间想一下上面的这段程序的输出是什么？是的，这看起来的确相当简单，甚至不需要编译和运行上面的代码，我们也应该知道其答案，那么，你觉得你知道答案吗？你确定你的答案正确吗？ 很多人都会觉得那段程序的输出应该是“set in preProcess()”，这是因为当子类Derived 的构造函数被调用时，其会隐晦地调用其基类Base的构造函数（通过super()函数），于是基类Base的构造函数会调用preProcess() 函数，因为这个类的实例是Derived的，而且在子类Derived中对这个函数使用了override关键字，所以，实际上调用到的是：Derived.preProcess()，而这个方法设置了whenAmISet 成员变量的值为：“set in preProcess()”。 当然，上面的结论是错误的。如果你编译并运行这个程序，你会发现，程序实际输出的是“set when declared ”。怎么为这样呢？难道是基类Base 的preProcess() 方法被调用啦？也不是！你可以在基类的preProcess中输出点什么看看，你会发现程序运行时，Base.preProcess()并没有被调用到（不然这对于Java所有的应用程序将会是一个极具灾难性的Bug）。 虽然上面的结论是错误的，但推导过程是合理的，只是不完整，下面是整个运行的流程： 进入Derived 构造函数。 Derived 成员变量的内存被分配。 Base 构造函数被隐含调用。 Base 构造函数调用preProcess()。 Derived 的preProcess 设置whenAmISet 值为 “set in preProcess()”。 Derived 的成员变量初始化被调用。 执行Derived 构造函数体。 等一等，这怎么可能？在第6步，Derived 成员的初始化居然在 preProcess() 调用之后？是的，正是这样，我们不能让成员变量的声明和初始化变成一个原子操作，虽然在Java中我们可以把其写在一起，让其看上去像是声明和初始化一体。但这只是假象，我们的错误就在于我们把Java中的声明和初始化看成了一体。 下面是对上面各个步骤的逐条解释。 进入构造函数。 为成员变量分配内存。 除非你显式地调用super()，否则Java 会在子类的构造函数最前面偷偷地插入super() 。 调用父类构造函数。 调用preProcess，因为被子类override，所以调用的是子类的。 于是，初始化发生在了preProcess()之后。这是因为，Java需要保证父类的初始化早于子类的成员初始化，否则，在子类中使用父类的成员变量就会出现问题。 正式执行子类的构造函数（当然这是一个空函数，虽然我们没有声明）。 其实 这些在理解了 Java运行原理 和 Java内存分配 之后就很容易理解了。","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]},{"title":"Java 数据库连接(dataSource)的演进","slug":"Java/2013-02-28-datasource-grouth","date":"2013-02-27T16:00:00.000Z","updated":"2018-11-09T14:18:19.340Z","comments":true,"path":"2013/02/28/Java/2013-02-28-datasource-grouth/","link":"","permalink":"http://heartaway.cn/2013/02/28/Java/2013-02-28-datasource-grouth/","excerpt":"","text":"原生方法 加载JDBC 驱动： 12Class.forName(driver);// mysql 数据库：“com.mysql.jdbc.Driver” 建立数据库连接： 1Connection conn = DriverManager.getConnection(url,userName,password); 创建 statement，用来执行SQL 语句 1Statement statement = conn.createStatement(); 执行 SQL 语句： 1ResultSet rs = statement.executeQuery(sql); 关闭记录集，关闭声明，关闭连接对象 不足： 每次使用都要创建连接，使用完毕后还必须关闭连接，操作繁琐，易出错； 连接数据库资源不便统一管理； 使用Spring的 JDBC 方法： 引入 spring-jdbc.jar 包 添加 dataSource配置 12345678&lt;bean id=\"dataSource\"&gt; &lt;property name=\"driverClassName\" value=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@10.217.3.2:1521:orcl\"&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"*\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"*\"&gt;&lt;/property&gt;&lt;/bean&gt; DriverManagerDataSource 类位于 org.springframework.jdbc.datasource 包下。 当然这里还可以选择 SingleConnectionDataSourceDriverManagerDataSource -&gt; 在每一个连接请求时都新建一个连接；SingleConnectionDataSource -&gt; 在每一个连接请求时都返回同一个连接； 获取dataSource bean对象 12ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");ds = (DataSource)ctx.getBean(\"dataSource\"); 获取连接对象Connection和Statement 12Connection conn = ds.getConnection();Statement sm = conn.createStatement(); 执行向数据库插入记录操作 12String sqlString = \"insert into bryanttesttable values(2,'bryant')\";sm.execute(sqlString); 优势： 更干净的 代码； 更简单的使用； 更好的异常与资源处理； Spring JDBC 介绍：模版设计模式（核心包包含JdbcTemplate），Spring JDBC 异常处理 ；这些会在下一章节来具体介绍Spring JDBC的优雅设计 和 是如何在 原生JDBC 上做封装的。 使用Spring的 数据库连接池 DBCP 方法：（四个流行的Java连接池）需要引入commons-collections.jar、commons-dbcp.jar和commons-pool.jar。 123456789&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;&lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"&gt;&lt;/property&gt;&lt;property name=\"url\" value=\"jdbc:oracle:thin:@192.168.1.35:1521:orcl\"&gt;&lt;/property&gt;&lt;property name=\"username\" value=\"or_meal\"&gt;&lt;/property&gt;&lt;property name=\"password\" value=\"or_meal\"&gt;&lt;/property&gt;&lt;property name=\"maxActive\" value=\"100\"&gt;&lt;/property&gt;&lt;property name=\"maxIdle\" value=\"30\"&gt;&lt;/property&gt;&lt;property name=\"maxWait\" value=\"10\"&gt;&lt;/property&gt;&lt;/bean&gt; 使用 JNDI 连接数据库1、SpringJNDI数据源配置信息： 12345&lt;bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt; &lt;property name=\"jndiName\"&gt; &lt;value&gt;java:comp/env/jcptDataSourceJNDI&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; jcptDataSourceJNDI是tomcat或者其他应用服务器配置的JNDI. 2、关于JNDI的配置(tomcat)： 修改tomcat目录conf/context.xml文件： 1234&lt;Resource name=\"jcptDataSourceJNDI\" auth=\"Container\" type=\"javax.sql.DataSource\" maxActive=\"100\" maxIdle=\"30\" maxWait=\"10\" username=\"tysp\" password=\"12345678\" driverClassName=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin:@192.168.1.35:1521:orcl\"/&gt; 3、通过JNDI获取DataSource: 1234&lt;Resource name=\"jcptDataSourceJNDI\" auth=\"Container\" type=\"javax.sql.DataSource\" maxActive=\"100\" maxIdle=\"30\" maxWait=\"10\" username=\"tysp\" password=\"12345678\" driverClassName=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin:@192.168.1.35:1521:orcl\"/&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://heartaway.cn/categories/Java/"}],"tags":[]}]}