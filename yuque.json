[
  {
    "title": "一次线上系统响应慢的问题定位",
    "description": "---title: 一次线上系统响应慢的问题定位categories: 稳定性tags: [问题定位, 稳定性]date: 2019-03-25---发现问题3月8日收到线上部分区域监控系统报警，提示数据处理服务大批异常报警；登录机器查看系统负载情况：系统CPU占用并不高。同事提示，发现了HS...",
    "created_at": "2019-03-25T09:17:37.000Z",
    "updated_at": "2019-03-25T14:09:12.000Z",
    "published_at": "2019-03-25T14:09:12.000Z",
    "format": "lake",
    "slug": "knnhgm",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 一次线上系统响应慢的问题定位<br />categories: 稳定性<br />tags: [稳定性, 问题定位]<br />date: 2019-03-25<br />---\n\n<a name=\"fa77ab6c\"></a>\n### 发现问题\n3月8日收到线上部分区域监控系统报警，提示数据处理服务大批异常报警；登录机器查看系统负载情况：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553507051995-7cce4dc5-7479-4a82-bf77-a8b48fb4928d.png#align=left&display=inline&height=241&name=image.png&originHeight=245&originWidth=722&size=135506&status=done&width=711)<br />系统CPU占用并不高。\n\n同事提示，发现了HSF日志中输出了HSF连接池满的情况：<br /><!--more--><br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553520952926-7421d58c-8fe0-45ff-a091-5bad1bc04a8f.png#align=left&display=inline&height=288&name=image.png&originHeight=576&originWidth=1428&size=450665&status=done&width=714)\n\n第一反应是后端处理太慢导致，查看了数据处理耗时统计：<br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553520978790-be1d0a79-07eb-408a-b261-b9be01186024.png#align=left&display=inline&height=375&name=image.png&originHeight=750&originWidth=1384&size=331071&status=done&width=692)<br />发现峰值耗时已经超过了160秒；\n\n<a name=\"0aff8430\"></a>\n#### 处理方案：\n暂且为定位根因，先做了服务器重启；重启后恢复，以为是偶发情况；\n\n\n<a name=\"258c8519\"></a>\n### 介入排查\n3月12 ~ 15日之间 线上Dataprocess的报警频次越来越高，且数量越来越大。在3月15日进行系统问题定位于排查；<br />分析代码后，做了一下优化：\n1. 接受日志处理的线程池的队列之前采用的是ArrayBlockingQueue，改用双锁队列LinkedBlockingQueue；\n1. 线程池拒绝策略采用自定义的DiscardPolicy，不再使用DiscardOldestPolicy（会进行队列poll操作，需要竞争锁）；\n1. 增加了线程池监控，监控线程池队列大小、处理任务数、丢弃任务数；\n\n\n<a name=\"722d8e0f\"></a>\n### 具体定位\n<a name=\"52e514c1\"></a>\n#### 指标观察：\n系统发布后，问题并未得到解决，报警依旧，采用tsar 观察系统各项指标：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553507935197-8e95d494-47bf-4d22-97d6-548945fd18ea.png#align=left&display=inline&height=300&name=image.png&originHeight=384&originWidth=956&size=119399&status=done&width=746)<br />（系统load，对于8core cpu，load并不高）<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553507967263-1ff8e52b-aafc-4b58-921d-947f3a7d3125.png#align=left&display=inline&height=244&name=image.png&originHeight=370&originWidth=1130&size=176313&status=done&width=745)<br />（系统剩余内存不足）<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553508026297-6ee1935f-98f8-43f8-83b2-42da9faeeed2.png#align=left&display=inline&height=151&name=image.png&originHeight=368&originWidth=1822&size=168486&status=done&width=746)<br />（系统的io操作并不频繁）\n\n开始怀疑jvm参数配置有错误，查了jvm的堆内存分配，从参数和合理上看并没有太大问题。<br />堆分配如下：<br />启动时堆的初始化大小： 10G（-Xms）<br />堆最大值为： 10G（-Xmx）<br />年轻代空间大小：4G（-Xmn）<br />初始持久代：256m （-XX:MetaspaceSize）<br />最大持久代：512m （-XX:MaxMetaspaceSize）\n\n<a name=\"b5a52648\"></a>\n#### Jstack分析：\n开始对线上系统进行jstack，分析线程栈具体卡在什么地方；<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553510300293-c8173e97-09fd-41a5-ab38-c8c91976834f.png#align=left&display=inline&height=443&name=image.png&originHeight=885&originWidth=2000&size=514798&status=done&width=1000)\n\n发现  69%的线程处于blocked状态；<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553510331156-ccad2748-8d71-4b8a-accc-62d6acdfaaf8.png#align=left&display=inline&height=375&name=image.png&originHeight=749&originWidth=2000&size=462845&status=done&width=1000)<br />从线程分组上看，HSFBizProcessor基本全部处于Blocked状态，log-handler-thread线程所有都处于blocked状态；\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553510391861-aa83d7a9-85af-4980-94e0-0876c73d26ed.png#align=left&display=inline&height=142&name=image.png&originHeight=284&originWidth=2000&size=335659&status=done&width=1000)\n\n查看处于blocked的HSF线程栈信息：\n\n```\nHSFBizProcessor-DEFAULT-12-thread-1673 - priority:10 - threadId:0x0000000006d32000 - nativeId:0x4f72 - nativeId (decimal):20338 - state:BLOCKED\nstackTrace:\njava.lang.Thread.State: BLOCKED (on object monitor)\nat java.util.Arrays.copyOf(Arrays.java:3181)\nat java.text.DateFormatSymbols.getShortMonths(DateFormatSymbols.java:433)\nat java.util.Calendar.getFieldStrings(Calendar.java:2241)\nat java.util.Calendar.getDisplayName(Calendar.java:2111)\nat java.text.SimpleDateFormat.subFormat(SimpleDateFormat.java:1125)\nat java.text.SimpleDateFormat.format(SimpleDateFormat.java:966)\nat java.text.SimpleDateFormat.format(SimpleDateFormat.java:936)\nat java.text.DateFormat.format(DateFormat.java:345)\nat ch.qos.logback.core.util.CachingDateFormatter.format(CachingDateFormatter.java:48)\n- locked <0x00000006223577e8> (a ch.qos.logback.core.util.CachingDateFormatter)\nat ch.qos.logback.classic.pattern.DateConverter.convert(DateConverter.java:61)\nat ch.qos.logback.classic.pattern.DateConverter.convert(DateConverter.java:23)\nat ch.qos.logback.core.pattern.FormattingConverter.write(FormattingConverter.java:36)\nat ch.qos.logback.core.pattern.PatternLayoutBase.writeLoopOnConverters(PatternLayoutBase.java:115)\nat ch.qos.logback.classic.PatternLayout.doLayout(PatternLayout.java:141)\nat ch.qos.logback.classic.PatternLayout.doLayout(PatternLayout.java:39)\nat ch.qos.logback.core.encoder.LayoutWrappingEncoder.encode(LayoutWrappingEncoder.java:115)\nat ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:230)\nat ch.qos.logback.core.rolling.RollingFileAppender.subAppend(RollingFileAppender.java:235)\nat ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:102)\nat ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84)\nat ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppendersForStructLog(AppenderAttachableImpl.java:54)\nat ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:273)\nat ch.qos.logback.classic.Logger.callAppenders(Logger.java:260)\nat ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:424)\nat ch.qos.logback.classic.Logger.filterAndLog_0_Or3Plus(Logger.java:386)\nat ch.qos.logback.classic.Logger.info(Logger.java:582)\n....\nat sun.reflect.GeneratedMethodAccessor134.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.taobao.hsf.remoting.provider.ReflectInvocationHandler.handleRequest0(ReflectInvocationHandler.java:84)\nat com.taobao.hsf.remoting.provider.ReflectInvocationHandler.invoke(ReflectInvocationHandler.java:164)\nat com.taobao.hsf2dubbo.DubboServerFilterAsyncInvocationHandlerInterceptor.invoke(DubboServerFilterAsyncInvocationHandlerInterceptor.java:54)\nat com.taobao.hsf.invocation.filter.RPCFilterBuilder$TailNode.invoke(RPCFilterBuilder.java:280)\nat com.taobao.hsf.debug.DebugServerFilter.invoke(DebugServerFilter.java:25)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.plugins.spas.SpasServerFilter.invoke(SpasServerFilter.java:143)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.edas.tps.component.WhiteListServerFilter.invoke(WhiteListServerFilter.java:67)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.tps.component.TPSServerFilter.invoke(TPSServerFilter.java:68)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.edas.tps.component.TPSServerFilter.invoke(TPSServerFilter.java:67)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.invocation.stats.InvocationStatsServerFilter.invoke(InvocationStatsServerFilter.java:47)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.monitor.log.filter.MonitorLogServerFilter.invoke(MonitorLogServerFilter.java:45)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.profiler.ProfilerServerFilter.invoke(ProfilerServerFilter.java:32)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.plugins.eagleeye.EagleEyeServerFilter.invoke(EagleEyeServerFilter.java:66)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.rpc.server.MethodAbsenceFilter.invoke(MethodAbsenceFilter.java:48)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.rpc.server.EchoFilter.invoke(EchoFilter.java:45)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.rpc.generic.GenericInvocationServerFilter.invoke(GenericInvocationServerFilter.java:106)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf2dubbo.DubboGenericServerFilter.invoke(DubboGenericServerFilter.java:36)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.rpc.server.ServiceAbsenceFilter.invoke(ServiceAbsenceFilter.java:47)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.common.filter.CommonServerFilter.invoke(CommonServerFilter.java:24)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf2dubbo.context.DubboRPCContextServerFilter.invoke(DubboRPCContextServerFilter.java:48)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.context.RPCContextServerFilter.invoke(RPCContextServerFilter.java:39)\nat com.taobao.hsf.invocation.filter.RPCFilterNode.invoke(RPCFilterNode.java:71)\nat com.taobao.hsf.invocation.filter.RPCFilterBuilder$HeadNode.invoke(RPCFilterBuilder.java:246)\nat com.taobao.hsf.invocation.filter.FilterInvocationHandler.invoke(FilterInvocationHandler.java:28)\nat com.taobao.hsf.remoting.provider.ServerContextInvocationHandler.invoke(ServerContextInvocationHandler.java:35)\nat com.taobao.hsf.remoting.provider.ProviderProcessor.handleRequest(ProviderProcessor.java:52)\nat com.taobao.hsf.io.remoting.hsf.message.HSFServerHandler$1.run(HSFServerHandler.java:177)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:627)\nat java.lang.Thread.run(Thread.java:882)\n```\n\n\n发现block在transport-api 包中的hanler方法中，查看代码：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553510475994-942259f9-f93a-4089-8510-1007c06a1cd4.png#align=left&display=inline&height=346&name=image.png&originHeight=692&originWidth=1788&size=680633&status=done&width=894)\n\n发现是日志输出中CachingDateFormatter的SimpleDateFormat 获得的锁未释放。\n\n<a name=\"71b33d03\"></a>\n#### 优化方案：\n* 取消transport-api中的日志输出，认为此没有必要，且输出的日志量巨大；\n* 打印日志优化：日志格式优化-减少不重要信息，降低系统调用，日志采用AsyncAppender包装RollingFileAppender，使用异步日志输出；\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553521107922-304a7a22-3f14-4920-bb2a-0f2f802cc3fe.png#align=left&display=inline&height=374&name=image.png&originHeight=748&originWidth=1478&size=881357&status=done&width=739)\n\n代办事项：排查打日志导致的锁未释放的真正原因。\n\n发布系统后，继续观察，重启后的一段时间，系统表现正常，但是一段时间后，又有报警出来：<br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553520842927-d75f27b2-8d65-4122-838a-637fe8a8f06d.png#align=left&display=inline&height=325&name=image.png&originHeight=650&originWidth=1292&size=232677&status=done&width=646)\n\n初步怀疑跟jstack有关，但是jstack时间是 18点40分左右，报警是在19点整，对不上。\n\n从网关侧看到此区域的qps情况，波动非常大；<br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553520885065-2f331c65-4c83-485a-800e-624cf259b34f.png#align=left&display=inline&height=238&name=image.png&originHeight=476&originWidth=1500&size=331575&status=done&width=750)\n\n<a name=\"9e497c48\"></a>\n#### 初步诊断： \n由于没有限流，北京的量太大，历史堆积太对，导致长时间堆积的数据上来后直接把系统打爆了，agent侧没有做流控，服务侧接受方也没有做流控导致的。\n\n<a name=\"915db64d\"></a>\n#### 解决方案：\n* 采用AHAS 流控降级服务增加限流，对于历史数据直接丢弃，对于新请求增加流控；\n\n\n第二天，从管控后台上看到北京SLA剧烈波动:\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1552975918909-f06b3f7c-0b3e-4b2b-ba67-a95fa643e574.png#align=left&display=inline&height=352&name=image.png&originHeight=704&originWidth=2246&size=340212&status=done&width=1123)\n\n对此区域一台机器进行offline，然后jstack线程栈继续分析：\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1552976809337-e3bdae4a-7539-433a-9dd6-4261c6527c8b.png#align=left&display=inline&height=220&name=image.png&originHeight=440&originWidth=2178&size=332568&status=done&width=1089)<br />提取hsf的jstack，发现，系统中 业务的处理并没有走统一的线程池处理方案；\n\n优化方案：\n* 抽取公共代码，定义日志和业务日志抽象类，分别使用线程池进行处理；\n\n\n<a name=\"4a1602db\"></a>\n#### GC分析：\n对系统的GC日志进行了分析：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553510944011-8128b5a2-5a3e-4452-a559-a33651c2fde4.png#align=left&display=inline&height=494&name=image.png&originHeight=987&originWidth=2000&size=383029&status=done&width=1000)<br />发现频繁触发fgc，且fgc失败，old区 非常大，gc无法回收，怀疑存在大对象导致的内存无法回收。<br /><br />通过jmap查看进程占用的大对象；<br /><br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553521339182-edde4ea1-1868-4c42-b641-da11d0b9341c.png#align=left&display=inline&height=368&name=image.png&originHeight=736&originWidth=1480&size=589499&status=done&width=740)<br /><br />发现系统内存中ots对象数据占用超过3G；与OTS同学沟通后，发现是client的使用问题。\n\n<a name=\"9a39e603\"></a>\n#### 问题解决：\nOTS写入优化，改用tablestoreWrite代替AyncClient，增加线程数控制、内存buffer控制等；\n1. AyncClient处理时，当线程池满之后，会把新进来的数据全部堆在内存中，会导致内存占满；\n1. tablestoreWrite采用了RingBuffer无锁写入，当线程池满且队列满之后，会阻塞调用线程；\n\n\n<a name=\"216c0e94\"></a>\n#### 新问题出现：\n系统灰度上线后，OTS写数据出现hang住；出现数据洪峰，导致处理线程block；<br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553521398649-dfe5511c-8d94-4f44-a50f-c15f86e35fb5.png#align=left&display=inline&height=265&name=image.png&originHeight=530&originWidth=1538&size=378791&status=done&width=769)\n\n此时 jstack数据如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553076983556-e1aa1249-0711-4f7c-9986-27dc6a52cf54.png#align=left&display=inline&height=346&name=image.png&originHeight=692&originWidth=1284&size=281191&status=done&width=642)\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553521506624-1e2cd35c-105f-4237-b2f0-9aff7fdab0a0.png#align=left&display=inline&height=252&name=image.png&originHeight=504&originWidth=1476&size=492669&status=done&width=738)\n\n解决方案：\n* 拆分线程池； 不能因为写监控数据而导致进程数据无法写入；进程的数据量与监控指标的数据量 不再一个数量级上。\n* 针对ots数据写入增加限流保护，并进行block数据统计；\n* 进一步定位导致TableStoreWriter写数据卡主的问题；\n\n\n对系统进行offline，观察线程池队列处于满状态，预期是不再有新流量进来时，线程池队列数据会被消费，但是观察了二十分钟后，线程池队列数据依然处于慢状态，说明线程hang住了。\n\n\n升级到OTS新版本后，持续观察，一段时间后，问题继续浮现。在仔细review代码，发现消费RingBuffer的线程池的拒绝策略采用了DiscardPolicy丢弃，也就是当系统处理不过来时进行丢弃，但是请求丢弃了会导致外层的线程hang住；<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/104361/1553154377682-13135f96-d88e-49fb-8eb6-07508cc6559f.png#align=left&display=inline&height=136&name=image.png&originHeight=271&originWidth=1558&size=336841&status=done&width=779)<br />具体为什么这里的线程池采用discard策略后会导致线程hang住，OTS同学给出的解释是“RingBuffer的数据会丢到线程池里处理，通过Semaphore来协同，如果executor丢弃了请求，那外层就会hang住”，此设计缺失不优雅，算是OTS Client的一个bug。\n\n<a name=\"83616992\"></a>\n#### 最终解决：\n* 修改线程池的拒绝策略后，灰度部分机器持续观察（上一次线上出现问题的时间周期大约为1小时，并且在一个波峰请求之后）。\n* 线上丢弃的日志量恢复为0，且写ots正常。\n\n<a name=\"8c9d507e\"></a>\n### 总结：\n我们时刻需要对线上系统的容量和现状有清晰的了解，知道系统内存当前的水位，内存中那些线程在运行，什么数据对象会占用大量内存，系统还能接受多大的量，系统的极限负载是多少等。其次，对于线上稳定性问题定位，我们还需要熟练使用一套排查工具，辅助定位问题。\n\n<a name=\"1917fd08\"></a>\n### 常用命令：\ntop ； # 查看系统CPU、Mem占用；<br />top -Hp pid； #查看具体进程下线程的cpu占用统计， pid到nid转换：printf '0x%x'；<br />iostat -d -k 1 10； # 统计磁盘IO；<br />tsar --cpu  --mem --traffic  --io ； #利用tsar来统计各项监控指标；<br />jmap -histo:live pid | head -20  #查看进程占用内存前20个对象；<br />jstack pid > jstack.log # 打印对应进程线程栈信息，常配合fastthread.io使用；<br />jstat –gcutil [pid] 1000 10 # 查看进程gc信息；\n\n\n<a name=\"1b3b6b96\"></a>\n### 常用工具：\n[https://gceasy.io/](https://gceasy.io/)         用于分析gc日志；<br />[https://fastthread.io/](https://fastthread.io/)    用于分析线程栈；<br />[https://github.com/alibaba/arthas](https://github.com/alibaba/arthas)  Arthas;\n\n"
  },
  {
    "title": "微服务架构可视化平台实践",
    "description": "---title: 微服务架构可视化平台实践categories: 架构tags: [架构, 可视化, AHAS]date: 2018-11-22---为什么需要架构可视化随着企业进行微服务架构改造，系统架构复杂度越来越高，架构变化日益频繁，微服务改造后的实际架构模型可能与预期已经产生了巨大差...",
    "created_at": "2018-11-22T08:32:28.000Z",
    "updated_at": "2018-11-29T04:28:53.000Z",
    "published_at": "2018-11-29T04:28:53.000Z",
    "format": "asl",
    "slug": "xeop0w",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 微服务架构可视化平台实践<br />categories: 架构<br />tags: [架构, 可视化, AHAS]<br />date: 2018-11-22<br />---\n\n<a name=\"g230wm\"></a>\n### 为什么需要架构可视化\n随着企业进行微服务架构改造，系统架构复杂度越来越高，架构变化日益频繁，微服务改造后的实际架构模型可能与预期已经产生了巨大差异，架构师或系统运维人员很难准确记忆所有资源实例的构成和交互情况；其次，系统架构在动态演化过程中可能引入了一些不可靠的因素，比如弱依赖变强依赖、局部容量不足、系统耦合过重等，给系统的稳定性带了极大的安全隐患。所以我们每次在面对系统改造、业务大促以及稳定性治理工作之前，都会通过梳理架构图的方式，呈现系统架构中个组件之间的交互方式，架构可视化能够清晰的协助我们识别架构中存在的问题以及建立高可用的系统。<!--more-->\n\n\n![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542956362235-c47820c3-d1a6-4470-8be3-343ed710ceb7.png#width=638)<br />（_Daniel Woods 在讲微服务时时的一张架构图）_\n\n架构可视化后，可以给我们带来以下几点但不局限于此的优势：\n* 确定系统边界\n\n\n一张好的架构图，应该明确系统所包含的各个组件以及各个组件之间的核心调用关系，这些组件的集合就是系统的处理边界，系统架构的边界在一定程度上也反映了业务域的边界。\n* 架构问题识别\n\n\n基于高可用的架构准则，结合可视化的架构图，可以评估架构可能存在的安全风险，比如系统在容灾、隔离以及自愈维度下的健壮性。其次，一些架构链路可视化工具(比如鹰眼)在实际工作中确实大大提高了开发者排查与定位问题的效率。\n* 提高系统可用性\n\n\n有了系统架构的上下游依赖关系图，在故障发生时，开发人员可以借助依赖数据快速定位到问题的来源，极大缩短问题修复时间（MTTR）。借助架构图，我们还可以梳理出系统中存在的强弱依赖，在业务高峰期对弱依赖进行降级，或者针对系统依赖的各个组件进行故障模拟，以评测系统整体在面对局部故障的可靠性。\n\n<a name=\"x8wvqr\"></a>\n### 常见架构可视化的做法\n我们熟知的架构图是静态的停留在PPT上的，很多时候我们的架构已经发生了非常大的变化，但是我们还在使用那张看上去很经典却早已过时的架构图。长时间使用与实际架构不符的架构图对线上架构的认知的危害是巨大的，我们需要在脑海中不断更新对系统架构的视图，以保持对系统架构的敏感度。每年的大促或者重大系统改造成为我们梳理系统架构、对架构进行重新认知的机会，此刻我们需要通过各种工具查看系统的各个组件分布以及不同组件的内部与外部的依赖关系，这种梳理架构图的方法是最常用的方式，权且称之为“**手工绘制法**”。\n\n手工经常干的事情，就有追求效率的同学使用计算机系统带来的自动化手段帮助自己做这件事情，比如我们常常看到的基于数据埋点的微服务可视化解决方案，这类架构可视化手段通常在分布式追踪、APM等监控领域使用较多，下图为某APM产品提供的应用维度架构可视化方案：<br />![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542964309773-458512d9-ae12-464b-a562-33df8342ac54.png#width=747)<br />我们称这种可视化方式为“**埋点式感知法**”，架构组件的识别是依赖关键的核心类检测与埋点，此种方案存在以下弊端：\n* 语言相关性：只要是系统埋点，与语言相关的特征基本就拜托不了，需要针对不同语言提供不同的依赖包；\n\n* 不易维护：因为是对核心类的检测，当组件包做了重大变更时，需要同步变更；\n\n* 不易扩展：因为是客户端识别方案，客户端一旦开放出去，新组件的支持只能等待用户更新组件；\n\n* 规模受限：客户端识别的另一个缺点是算法受限，服务端进行识别，可以借助大数据分析等手段更有效准确的识别；\n\n\n还有一种自动化架构感可视化方法，我们称之为“**无界架构感知**”，是一种语言无关性的架构识别方案，其采用采集用户主机上的进程和容器的元数据、监控数以及网路数据的最最基础的数据，在服务端构建架构图。\n\n<a name=\"sak3aa\"></a>\n### 我们设计架构可视化的理念\n为了最大限度上降低用户进行架构可视化的成本，我们采用了无界架构感知-应用无侵入的方式微服务进行可视化，通过采集进程数据与网络调用数据，构建进程间的网络调用关系，构建微服务的架构信息。用户只需要安装我们AHAS Agent探针，即可完成架构可视化操作；对于阿里云云原生系统，我们提供了自动化安装方式，而无需登录机器。\n\n<a name=\"ow5ucr\"></a>\n#### 核心本质\n软件架构可视化的核心点是寻找在软件体系结构中有意义和有效的元素视图以及这些元素之间的关系。我们认为一款优秀的软件架构可视化产品应该帮助用户排除掉不重要的信息，给用户呈现出对他们有价值的视图，特别是在微服务架构下庞大而复杂的调用关系链场景中。这里面的核心点是**有意义**和**有效**，要做到这两点，首先需要识别什么是有意义和有效的元素和关系，我们在此领域做的事情归纳起来就是“**识别**”，识别机器上的每个进程是什么，发生的网络调用远端是什么，唯有知晓了这些元素是什么我们才有理由和依据来判断是否对用户有意义以及其在用户架构中的重要程度。\n\n在梳理了大量架构图，我们发现用户关心的架构元素主要分为三类：\n1. 自己的应用服务；\n\n1. 应用对外部的资源依赖；\n\n1. 服务器本身的信息。 \n\n\n应用对外部资源的依赖通常以其它应用和通用中间件或者存储服务两种形式存在。故我们将需要识别的进程分为：应用服务和常见的组件服务（比如redis、mysql等），这些组件服务又分为用户自建的服务和使用公有云提供的服务，特别是对于Cloud Native应用来说，云服务的识别显得格外重要。<br />目前，我们提供了20种阿里云云服务的识别以及包含mysql、redis、Tomcat等常见的21种三方服务组件，此组件库还在不断扩张中，目的就是最大限度的知晓架构中的元素到底是什么。\n\n![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542958237398-de68d1b7-ef29-46b7-879b-41cb37b3c8a5.png#width=747)<br />     （图中展示了 通过识别服务识别出来的nginx、redis组件以及阿里云中的Mysql服务和AHAS服务）\n\n![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542958281395-8bb05ff4-0958-474d-8f04-546cbf8a0456.png#width=747)<br />（图中展示了节点详情的请求流向以及节点的监控等基本信息）\n\n![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542963012342-42798fda-e169-4f2a-aaa8-481b1ff6d98b.png#width=747)<br />(图中展示了识别的主机上的部分进程信息)\n<a name=\"xwhcne\"></a>\n#### 架构分层\n我们同样认为架构可视化的有效性跟人的认知层次有关，架构可视化的重点是确定该工具是否更好的支持自顶向下方法、自下而上方法或者两者的结合。开发者更关心应用维度上的架构，架构师或者管理者更关心整体系统架构。所以需要针对不用的使用者提供不同层次的架构可视化视角。理想的架构图需要支持宏观维度以及不断下钻下的微观视角，我们对架构进行了分层设计，目前分为进程层、容器层和主机层，后期我们可能会继续上扩或者下钻支持地域层或者服务层。\n\n<a name=\"cvcnys\"></a>\n#### 架构回溯\n没有哪个系统的架构是一成不变的，系统架构会随着系统的版本迭代不断进行演化。所以对架构可视化操作，还需要具备随着时间的推移可对架构信息进行自动更新已经回溯的能力。在我们提供的[架构感知](https://www.aliyun.com/product/ahas)产品中默认架构图会随着时间自动刷新，同时支持对历史的回溯，你可以选择历史中的某一刻查看架构信息，比如，重大版本的变更时，发布前与发布后的系统架构是否发生了违背一些高可用原则的问题，抑或排查是否出现了不该有的依赖问题。<br />![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542960362139-534dd303-c1b7-493a-8685-ac502e356028.png#width=747)\n\n<a name=\"l3b8al\"></a>\n#### 可见可得\n架构可视化解决了可见的问题，但当我们从架构图中发现了问题需要解决时，架构图还应该给我们提供便利的可交互操作入口，让我们可以完成问题发现与解决的闭环。比如通过架构感知监控到了某个应用的流量非常大，我们需要对应用进行限流或者预案，那么通过架构图，我们应该是可以完成我们期望执行的操作。在架构图中融入可以交互的运维操作，让我们从看到到操作，再到问题恢复后体现在图中，这就像计算机发展史上从命令行视图到窗口视图的转变。\n\n<a name=\"mtfgyk\"></a>\n### 我们对架构可视化的定位\n**架构可视化不是目的，只是实现系统高可用性的手段**。借助架构感知采集到的架构数据，在识别了用户使用的组件（我们对mysql、redis、mq等的统称)后，我们借助这些组件以及与组件匹配的故障库，可以给用户自动推荐这些组件可能遇到的故障，配合我们提供的[评测服务](https://www.aliyun.com/product/ahas)让用户更方便地对组件进行各种故障的模拟与演练，以提高系统的健壮性。其次，通过架构感知识别Java Application 应用，如果发现其负载较高，配合我们提供的[限流降级](https://www.aliyun.com/product/ahas)（阿里巴巴开源的Sentinel商业版）功能，为服务的持续可用性保驾护航。\n\n\n![](https://cdn.nlark.com/yuque/0/2018/gif/104361/1542969119301-c0372346-6922-4537-a611-1e772bee351f.gif#width=747)<br />（白屏化安装AHAS探针）<br />\n<br />![](https://cdn.nlark.com/yuque/0/2018/gif/104361/1542971799291-1e0987da-79c4-4e2d-b9d3-4e847a9c82eb.gif#width=747)<br />（如何借助架构感知进行系统限流配置）<br />我们对AHAS的定位是一款数据分析型的高可用保障产品，帮助云原生架构系统实现高可用能力的提升。架构可视化是我们给用户提供的高效运维和管控的窗口，我们期望通过丰富的云原生数据体系配合架构图的可视化以及可操作性，建立起以应用为中心的运维一体化平台。在未来，我们会加强与其它云服务的集成，比如监控、容器服务，以丰富架构感知的数据维度；其次，会在数据的深度挖掘和智能化消费上投入更多精力，真正让数据成为企业的核心价值，让数据成为保障业务的稳定性的利器。\n\n产品体验连接：[https://www.aliyun.com/product/ahas](https://www.aliyun.com/product/ahas)\n\n\n\n"
  },
  {
    "title": "本地缓存的数据变更",
    "description": "---title: 本地缓存的数据变更categories: 编程tags: [共享变量,缓存]date: 2018-11-16---背景业务上有一个需求使用基线数据中拷贝出内容，分发到不同用户集合的存储实例中，使用模型标识就是B-&gt;(u1,u2,u3...uN)，初始代码逻辑是，每个用...",
    "created_at": "2018-11-16T06:29:59.000Z",
    "updated_at": "2018-11-16T07:02:19.000Z",
    "published_at": "2018-11-16T07:02:19.000Z",
    "format": "asl",
    "slug": "dzrk19",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 本地缓存的数据变更<br />categories: 编程<br />tags: [共享变量,缓存]<br />date: 2018-11-16<br />---\n\n<a name=\"d4zzse\"></a>\n### 背景\n业务上有一个需求使用基线数据中拷贝出内容，分发到不同用户集合的存储实例中，使用模型标识就是B->(u1,u2,u3...uN)，初始代码逻辑是，每个用户都有单独的定时器触发来执行B->uN的拷贝，执行这个过程需要首先从基线B中取出数据，然后替换为uN的用户信息，在写入uN的数据存储中（用户之间逻辑隔离非物理隔离），期初此流程没什么问题，后来考虑到每个用户读取的基线可能相同，可以对基线数据做local cache，以此来优化程序的执行性能， local cache 变量为全局共享变量，多线程可访问。\n\n\n<a name=\"isplgh\"></a>\n### 问题\n在做性能优化使用local cache的时候，会先查询缓存是否存在，如果不存在，则查询基线数据，如果查询的基线存在的话，则回写到缓存中，并向目标用户实例中写入基线数据，整体流程如下：<!-- more -->\n\n```\n//首先查本地缓存\nList<ProcessEntity> processEntities = processCache.getIfPresent(cacheKey);\n        if (processEntities == null) {\n            //查询存储\n            processEntities = processSourceClient.readProcessEntitiesByTimeGrid(\n                demoDataRequest.getSourceUserId(), demoDataRequest.getSourceNamespace(),\n                demoDataRequest.getSourceTimeGrid());\n        }\n\n        if (CollectionUtils.isNotEmpty(processEntities)) {\n            //回写数据到缓存（存在多次写问题）\n            processCache.put(cacheKey, processEntities);\n            processEntities.forEach(item -> {\n                //替换用户属性，问题就在这里\n                item.setUserId(demoDataRequest.getTargetUserId());\n                item.setNamespace(demoDataRequest.getTargetNamespace());\n                item.setTimeGrid(demoDataRequest.getTargetTimeGrid());\n            });\n            \n            //写目标用户数据\n            processTargetClient.batchWriteProcessLog(processEntities);\n        }\n```\n\n增加了缓存后，我们在编码的时候，很容易认为数据我已经写到缓存中了，再对数据做处理不会影响缓存，但是我们忽略了这里的缓存是本地缓存，且是对象引用下的本地缓存，是共享数据；如果使用分布式缓存，通过数据的序列化和反序列化，相当于对象做了拷贝，不会有问题，如果使用本地缓存，存储数据的副本的话，也不会有问题；但是这里偏偏使用了本地变量，并对数据做了变更，没有引起编码时的注意，导致了错误。这个错误在单元测试的时候，也没测出来，发到生产环境上才对发现存储层在数据写入时大量报写入冲突。\n\n<a name=\"bgu6rd\"></a>\n### 解决\n使用本地缓存时，如果有数据变更的需求，则需要使用副本，这也是共享变量在多线程中容易导致的一个容易发生的错误。<br />![](https://cdn.nlark.com/yuque/0/2018/png/104361/1542351217947-009a8e54-41ed-4409-a896-9bad779f631c.png#width=747)\n\n<a name=\"q71zsp\"></a>\n### 反思\n期初线上打印出了冲突的问题，总以为是存储这边分批写的问题，后来发现这个问题的发生频次是间歇性的，且无规律，更像是具备随机性，所以决定深入排查，最后发现了编码上的一个很低级的错误。我们不要放过线上任何一个异常，除非我们把问题弄清楚了，否则“墨菲定律”告诉我们，担心出问题的地方，一定会出问题。\n"
  },
  {
    "title": "无标题",
    "description": "",
    "created_at": "2018-11-16T06:29:01.000Z",
    "updated_at": "2018-11-16T06:29:01.000Z",
    "published_at": null,
    "format": "asl",
    "slug": "ttogb2",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": ""
  },
  {
    "title": "我为什么会在这",
    "description": "---title: 我为什么会在这categories: 思考tags: [工作, 目标]date: 2018-11-16---思考对于我们个人来说,要问自己的问题是:我为什么在这里?我如何才能帮助公司解决顾客问题？速度快效率高还不够，我们还希望更有成效。",
    "created_at": "2018-11-11T16:41:21.000Z",
    "updated_at": "2018-11-16T06:29:46.000Z",
    "published_at": "2018-11-16T06:29:45.000Z",
    "format": "asl",
    "slug": "qzi3m3",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 我为什么会在这<br />categories: 思考<br />tags: [工作, 目标]<br />date: 2018-11-16<br />---\n\n<a name=\"d4zzse\"></a>\n### 思考\n对于我们个人来说,要问自己的问题是:我为什么在这里?我如何才能帮助公司解决顾客问题？速度快效率高还不够，我们还希望更有成效。\n"
  },
  {
    "title": "建立人生准则",
    "description": "---title: 建立人生准则categories: 思考tags: [目标, 人生, 感悟]date: 2018-11-10---前段时间百无聊赖之际无意翻阅到一部日漫《十二国记》，看之前我先翻了翻豆瓣评价（下意识的去评估投入产出比），评价的人不多，但是很多评价说儿时的这部日漫奠定了自己的...",
    "created_at": "2018-11-10T09:27:20.000Z",
    "updated_at": "2018-11-11T13:09:48.000Z",
    "published_at": "2018-11-11T13:09:47.000Z",
    "format": "asl",
    "slug": "gvvbva",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 建立人生准则<br />categories: 思考<br />tags: [目标, 人生, 感悟]<br />date: 2018-11-10<br />---\n\n前段时间百无聊赖之际无意翻阅到一部日漫《十二国记》，看之前我先翻了翻豆瓣评价（下意识的去评估投入产出比），评价的人不多，但是很多评价说儿时的这部日漫奠定了自己的人生价值观以及世界观，我随之着了迷，到底是一部什么动画有这么大的魔力？\n\n在看了前几集的略显拖沓的情节后，越发后面越来越精彩。看到女主从一个柔弱的女高中生，在不断面对自己内心的批判与挣扎中变得越发强大，看到了活在自己痛苦之中的铃，看到也不知道为什么而存在的浅野，其中有很多让人深思的对白，从这部动漫的各个人物角色中，总能找到那个似曾相识的自己。\n\n<a name=\"wgbkts\"></a>\n### 活出自我\n我从小就是那种乖乖孩，周边几乎所有的亲朋好友对我的评价基本都是“听话、懂事”，无论是在学校与老师、同学的关系，还是在家与父母亲人的关系，我都处理的很融洽。我曾一度认为这是自己处事得体的结果，看到了阳子面对自我的时候，才知道了原因。阳子像画出来一样的优等生，私生活和家庭都很踏实，和同学的关系十分友好，老师们也很喜欢她，不过一般来说这种事是不可能的，对老师来说都额好孩子，在同学间就会被梳疏远，在朋友心中受欢迎的话，在父母看来就像是走上了歪路一样，**每个人眼中看起来都好的孩子，往往只是为了让别人认同自己而丧失了自我，一味地迎合别人而已**。<!--more-->\n\n反观自己又何尝不是呢，以前都在按照别人的眼色与期望生活着，活成了别人期望的样子，反而丢失了自己。以前父母任何的决定，我几乎都是顺从，老板的任何安排与要求我也是全盘收纳，知道有一天，我觉得我应该有自己的思想以及对事物的价值判断了，我开始尝试的去独立思考，对父母意见的反驳让他们很是意外，让他们让为一向很乖的儿子变了，变得不再听话了；对老板也提出了自己不同的观点，即便是双方都没能很好的控制好情绪。此刻，我觉得我才是我，之前接近三十年似乎都活在一个皮囊之下。\n\n最近延禧攻略比较火，魏璎珞得到皇后的格外恩宠，究其原因，竟然是：璎珞就像当年的自己，所以保护璎珞就像保护当初的自己。魏英璐是在为自己而活，而其他人都是在为别人而活，活成了别人期望的样子，以至于自己都不认识自己了。 ​​​​\n\n<a name=\"2lv6tr\"></a>\n### 投资回报\n有人说“成年人的世界没有永远不变的友谊，只有不变的利益”，单这句话我是赞同的，毕竟这个世界运行的基础就是以经济发展为基本规律，一切利益化，也不是我们能改变的社会规则。职场上，大家成为相互的朋友的前提是在能力圈范围差不多的时候，你有的东西正好是我要的，如果不在一个朋友圈内，这种关系也很难维持。生活中，人每隔七年的交际圈会发生一次改变，不是因为友谊不在了，而是因为我们在考虑投资收益比的思维习惯影响下，那些低价值的社交被我们主动过滤掉了。成熟的我们做任何事情之前都会开始思考，对我有什么好处，我能得到什么，即便是爱一个人，也会去衡量我是不是爱他比他爱我多一点点。其实，计较的太多，让我们过的异常疲惫，社会其实不负责，复杂的是人心。<br />阳子曾说：就算被人背叛，那也只是背叛别人的人变得卑鄙！因为不是出于善意就不相信人吗？如果对方不亲切对我就不能对他亲切吗？我相信对方，和对方是否背叛我，没有任何关系！我只是一个人，这就是为什么所有有关我的事有我自己决定！就算没有任何人对我好，就算怎样被其他人被背叛，我也不会成为一个不相信任何人的卑鄙小人！跟世界各他人无关，**因为我想对人亲切所以亲切，因为我想相信别人所以相信！**\n\n<a name=\"lyw4kr\"></a>\n### 比惨心理\n因“蚀”被卷入十二国的大木铃，一度认为自己是世界上最不幸的人，无论在什么地方都会跟别人比不幸。有时人在说‘我好不幸’时也许与说‘我好幸福’时一样充满了自豪！人一般都不愿承认自己是这个世上最幸福的人，倒是拼命与别人争夺‘我是世上最不幸的人'，至少‘在某一方面我就是这个世上最不幸的人！’从而给自己自怜的理由，从而认为大家都应该同情我，顺从我，这其实是奢望更多幸福的一种心理！\n\n若一个人实在是无法忍受时，他必定会逃，如果他没有这样做，不管是什么理由，那必定是还可以忍受，并潜意识地把自己置于这种悲惨的地步，一面在自怜：‘我为何如此不幸？’一面在自欺：‘一定会有人给我幸福！’。\n\n祥琼曾说：只是在炫耀自己比别人更不幸，不是吗？说什么那家伙很可怜，自己更可怜什么的，只不过是在刻意让自己觉得不幸而已。有痛苦的事很伟大吗？能够忍受痛苦很伟大吗？我的话就想办法让自己不那么痛苦。说什么一个人比另一个人更痛苦根本是假话,每个人其实都有同样多的痛苦.真的痛苦的话,人就会拼了命想办法从那种情况下逃脱出来.没有逃走,是因为姐姐只是喜欢把自己置身于不幸的感觉里不是吗?对这样的人为什么要同情?\n\n这个世界上的人，**每个人的人生都是一半幸福，一半痛苦**。遇到痛苦的事情，不要以为是社会独对自己的不公，应尽全力突破困难，化危机为机遇，让困难成为自己成长的助力器。\n\n<a name=\"227krc\"></a>\n### 为行为负责\n以前我从来没有意识到我们做任何事情一旦决定了，就需要为结果埋单这件事。没有谁提醒过这个是现实世界的生存法则之一；也许我看到或听到别人说过，但是没有体感，丝毫不认为这条可以成为人生原则之一。直到去年在看《画江湖之不良人》中张子凡的九叔的情节，让我有所领悟。  张子凡九叔叫李存忠，奉老大李嗣源的命令找回张子凡，在找到张子凡之后，按理说任务完成了，就该回去了，但子凡请求其救出李星云，其明知要在汴州营中捞人按期的武力就是以卵击石，又考虑到如果如果能顺便把李星云带回通文馆的话，又是立功一件，此时摆在李存忠面前的是一个选择题，要不要做这个风险与收益并存的支线任务呢！结果如大家预料的一样，任务失败，害的十二叔李存孝惨死汴州，自己也深受重伤，张子凡也没能如愿带回，在回到通文馆向李克用请罪时，迫于压力被李嗣源的射杀，当场毙命。\n\n我们在小的时候不需要为行为负责或者没有被教育要为行为负责，是因为父母是我们的庇护伞，我们在外面闯祸犯错了，父母总是说会想办法摆平，我们反而逃避了惩罚，这就导致了缺乏对自己行为负责的思考。小孩子的世界与成年人的世界不同，需要按照成年人的游戏规则生成。**我们在做任何事情之前，都需要谨慎考虑清楚自己是否有能力承担其结果，如果不能或者不愿，那就不要做这个决定，不要要让自己成为巨婴，做了事情又不远承担结果的人。**\n\n无论生活还是工作当中，也是如此，你要想有所成绩，就必须做好因成绩不佳而可能带来的不良影响。比如因做阿里云而苦守多年受尽激讽的王坚博士，比如因推进阿里做社交软件来玩的前CEO陆兆禧，做成了一代功臣高高在上，做失败了，退出历史舞台。人生中的机会并不多，做好每一次的决断，不要事后为你改承担的结果而啧啧不休。\n\n无论你听过再多的道理，当你没有经历过一些事情或者心智没有达到这个境界的时候，你是不会理解这个道理的，所以人们会常常说“道理我都懂，然后并没有什么乱用”，那是因为你经历的还是太少，痛了你就明白了。\n\n<a name=\"lgmxum\"></a>\n### 人生信仰\n以前我是不太相信信仰的，这可能跟中国大环境下缺乏信仰有关。从小到大，没有任何教育说要建立个人信仰，要建立个人人生准则与道德底线，也不知道成为一个什么样的人才算是一个合格的人。那时候大人们只会问，你长大了想当什么，我们会回到当医生或者警察亦或者老师，但是也说不清楚为什么相当。直到从《十二国记》中看到了乐俊，我觉得，他就是我想要找的那个人生导师。真诚待人，而不是怀有功利心；即便整个社会都不接纳自己，自己也要努力拼搏，活出自我；强大的包容心，对过失的包容，对不公的包容，对人心阴暗面的包容；乐观积极向上，睿智而博学。\n\n在我们面对教条主义式的价值观灌输时，我们往往都是怀有抵触心理的，像动漫这种以动人的故事来告诉你什么是好的，什么是值得推崇与坚守的，更能让人信服。有了人生导师，就应该在生活中践行，做到知行合一。公共场合不大声喧哗，主动让座，主动拾起垃圾，以力所能及的方式帮助需要帮助的人。多以有爱的眼光看到这个世界，你会发现，有底线、有准则、有信仰、有关爱的人就在你我身边。\n<a name=\"gznzgi\"></a>\n### \n\n"
  },
  {
    "title": "博客内容模板",
    "description": "---title: 博客内容模板categories: 分类tags: [标签1, 标签2]date: 2000-01-01---博客三级标题",
    "created_at": "2018-11-10T08:46:43.000Z",
    "updated_at": "2018-11-10T08:53:20.000Z",
    "published_at": "2018-11-10T08:53:20.000Z",
    "format": "asl",
    "slug": "ggecw8",
    "last_editor": {
      "id": 104361,
      "type": "User",
      "login": "xinyuan",
      "name": "心远",
      "description": "个人博主，关注高可用、微服务、故障注入、Chaos Enginering等领域，阿里云产品AHAS（应用高可用服务）技术负责人。",
      "avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg",
      "large_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.yuque.com/yuque/0/2018/jpeg/104361/1524454029057-avatar/d41b9efd-63b4-47f9-be3e-6ea6ffc5d9c2.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 3,
      "following_count": 1,
      "created_at": "2018-04-23T03:20:49.000Z",
      "updated_at": "2019-03-20T18:08:18.000Z",
      "_serializer": "v2.user"
    },
    "body": "---<br />title: 博客内容模板<br />categories: 分类<br />tags: [标签1, 标签2]<br />date: 2000-01-01<br />---\n\n<a name=\"d4zzse\"></a>\n### 博客三级标题\n\n"
  }
]