---
layout: post
title: Java基础 之 类的初始化顺序和陷阱
categories: Java
description:
keywords: init 初始化顺序
date: 2013-03-04
---
在阅读之前 建议先了解一下  [Java运行原理](http://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html)  和 [Java内存分配机制](http://blog.csdn.net/shimiso/article/details/8595564)；

#### JAVA类的初始化顺序

给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解。

我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）>（变量、初始化块）>构造器。我们也可以通过下面的测试代码来验证这一点:


```java
public class InitialOrderTest {
    // 静态变量
    public static String staticField = "静态变量";
    // 变量
    public String field = "变量";   

    // 静态初始化块
    static {
        System.out.println(staticField);
        System.out.println("静态初始化块");
    }
    // 初始化块
    {
        System.out.println(field);
        System.out.println("初始化块");
    }
    // 构造器
    public InitialOrderTest() {
        System.out.println("构造器");
    }
    public static void main(String[] args) {
        new InitialOrderTest();
    }
}
```


```java
public class InitialOrderTest { 

// 静态变量
public static String staticField = "静态变量";
// 变量
public String field = "变量";
// 静态初始化块
static {
System.out.println(staticField);
System.out.println("静态初始化块");
}
// 初始化块
{
System.out.println(field);
System.out.println("初始化块");
}
// 构造器
public InitialOrderTest() {
System.out.println("构造器");
}
```

运行以上代码，我们会得到如下的输出结果：


```java
静态变量
静态初始化块
变量
初始化块
构造器
```

这与上文中说的完全符合。那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果：


```java
class Parent {
    // 静态变量
    public static String p_StaticField = "父类--静态变量";
    // 变量
    public String p_Field = "父类--变量";
    // 静态初始化块
    static {
        System.out.println(p_StaticField);
        System.out.println("父类--静态初始化块");
    }   

    // 初始化块
    {
        System.out.println(p_Field);
        System.out.println("父类--初始化块");
    }   

    // 构造器
    public Parent() {
        System.out.println("父类--构造器");
    }
}   

public class SubClass extends Parent {
    // 静态变量
    public static String s_StaticField = "子类--静态变量";
    // 变量
    public String s_Field = "子类--变量";
    // 静态初始化块
    static {
        System.out.println(s_StaticField);
        System.out.println("子类--静态初始化块");
    }
    // 初始化块
    {
        System.out.println(s_Field);
        System.out.println("子类--初始化块");
    }
    // 构造器
    public SubClass() {
        System.out.println("子类--构造器");
    }
    // 程序入口
    public static void main(String[] args) {
        new SubClass();
    }
}
```

运行一下上面的代码，结果马上呈现在我们的眼前：


```java
父类--静态变量
父类--静态初始化块
子类--静态变量
子类--静态初始化块
父类--变量
父类--初始化块
父类--构造器
子类--变量
子类--初始化块
子类--构造器
```

现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。

那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。

静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。

#### Java构造时初始化陷阱
让我们先来看两个类：Base和Derived类。注意其中的whenAmISet成员变量，和方法preProcess()


```java
public class Base{
    Base() {
        preProcess();
    }
    void preProcess() {}
}
```


```java
public class Derived extends Base
{
    public String whenAmISet = "set when declared";
    @Override void preProcess()
    {
        whenAmISet = "set in preProcess()";
    }
}
```

如果我们构造一个子类实例，那么，whenAmISet 的值会是什么呢？


```java
public class Main {
    public static void main(String[] args)
    {
        Derived d = new Derived();
        System.out.println( d.whenAmISet );
    }
}
```

再续继往下阅读之前，请先给自己一些时间想一下上面的这段程序的输出是什么？是的，这看起来的确相当简单，甚至不需要编译和运行上面的代码，我们也应该知道其答案，那么，你觉得你知道答案吗？你确定你的答案正确吗？

很多人都会觉得那段程序的输出应该是“set in preProcess()”，这是因为当子类Derived 的构造函数被调用时，其会隐晦地调用其基类Base的构造函数（通过super()函数），于是基类Base的构造函数会调用preProcess() 函数，因为这个类的实例是Derived的，而且在子类Derived中对这个函数使用了override关键字，所以，实际上调用到的是：Derived.preProcess()，而这个方法设置了whenAmISet 成员变量的值为：“set in preProcess()”。

当然，上面的结论是错误的。如果你编译并运行这个程序，你会发现，程序实际输出的是“set when declared ”。怎么为这样呢？难道是基类Base 的preProcess() 方法被调用啦？也不是！你可以在基类的preProcess中输出点什么看看，你会发现程序运行时，Base.preProcess()并没有被调用到（不然这对于Java所有的应用程序将会是一个极具灾难性的Bug）。

虽然上面的结论是错误的，但推导过程是合理的，只是不完整，下面是整个运行的流程：

1. 进入Derived 构造函数。
2. Derived 成员变量的内存被分配。
3. Base 构造函数被隐含调用。
4. Base 构造函数调用preProcess()。
5. Derived 的preProcess 设置whenAmISet 值为 “set in preProcess()”。
6. Derived 的成员变量初始化被调用。
7. 执行Derived 构造函数体。

等一等，这怎么可能？在第6步，Derived 成员的初始化居然在 preProcess() 调用之后？是的，正是这样，我们不能让成员变量的声明和初始化变成一个原子操作，虽然在Java中我们可以把其写在一起，让其看上去像是声明和初始化一体。但这只是假象，**我们的错误就在于我们把Java中的声明和初始化看成了一体。**

下面是对上面各个步骤的逐条解释。

1. 进入构造函数。
2. 为成员变量分配内存。
3. 除非你显式地调用super()，否则Java 会在子类的构造函数最前面偷偷地插入super() 。
4. 调用父类构造函数。
5. 调用preProcess，因为被子类override，所以调用的是子类的。
6. 于是，初始化发生在了preProcess()之后。这是因为，Java需要保证父类的初始化早于子类的成员初始化，否则，在子类中使用父类的成员变量就会出现问题。
7. 正式执行子类的构造函数（当然这是一个空函数，虽然我们没有声明）。

其实 这些在理解了  [Java运行原理](http://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html)  和  [Java内存分配](http://blog.csdn.net/shimiso/article/details/8595564)  之后就很容易理解了。

