---
layout: post
title: CAS 操作的实现原理
categories: Java
description:
keywords: cas
date: 2016-07-07
---
### CAS原子操作原理：

#### 1. 在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段（多处理器）
CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。
```java
inline bool CAS2(pointer_t *addr, pointer_t &old_value, pointer_t &new_value)
{
bool ret;
__asm__ __volatile__(
"lock cmpxchg16b %1;n"
"sete %0;n"
:"=m"(ret),"+m" (*(volatile pointer_t *) (addr))
:"a" (old_value.ptr), "d" (old_value.tag), "b" (new_value.ptr), "c" (new_value.tag));
return ret;
}
```
解锁来保证原子性只是保证原子性的其中一种手段而已，X86CPU保证原子性的手段有以下三种：
① 处理器自动保证基本内存操作的原子性。
一些基本的内存读写操作是本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；

②使用总线锁保证原子性。
一些需要保证原子性但是没有被第①条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性。

③使用缓存锁保证原子性。

总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。
因为很多内存数据是已经存放在L1/L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值。
所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效.
但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。


那么哪些操作是非原子的呢？
>ACCESSES TO CACHEABLE MEMORY THAT ARE SPLIT ACROSS BUS WIDTHS, CACHE LINES, AND PAGE BOUNDARIES ARE NOT GUARANTEED TO BE ATOMIC BY THE INTEL CORE 2 DUO, INTEL® ATOM™, INTEL CORE DUO, PENTIUM M, PENTIUM 4, INTEL XEON, P6 FAMILY, PENTIUM, AND INTEL486 PROCESSORS.

（说点简单点，那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的，你如果想保证这些操作是原子的，你就得求助于机制②，对总线发出相应的控制信号才行）。

#### 2.对于linux而言，内核提供了两组原子操作接口
一组是针对整数进行操作；另一组是针对单独的位进行操作。
①原子整数操作：针对整数的原子操作只能对atomic_t类型的数据处理，Linux支持的所有机器上的整型数据都是32位，但是使用atomic_t的代码只能将该类型的数据当作24位来使用。这个限制完全是因为在SPARC体系结构上，原子操作的实现不同于其它体系结构：32位int类型的低8位嵌入了一个锁，因为SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。
②原子位操作：原子位操作定义在文件中。令人感到奇怪的是位操作函数是对普通的内存地址进行操作的。原子位操作在多数情况下是对一个字长的内存访问，因而位号该位于0-31之间(在64位机器上是0-63之间),但是对位号的范围没有限制。


### 为什么关注原子操作？
1）在确认一个操作是原子的情况下，多线程环境里面，我们可以避免仅仅为保护这个操作在外围加上性能开销昂贵的锁。
2）借助于原子操作，我们可以实现互斥锁。
3）借助于互斥锁，我们可以把一些列操作变为原子操作。


### CAS带来的问题：
#### 1). ABA问题；
CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。在Java中提供了AtomicStampedReference解决ABA问题。
#### 2). 循环时间长，开销大；
![](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/731405bbc5b0122b43c21a44dddcbedc.png)
自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
#### 3). 只能保证一个共享变量的原子操作；
当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。


### 参考连接：
https://software.intel.com/zh-cn/blogs/2010/01/14/cpucpu
http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html
http://www.infoq.com/cn/articles/atomic-operation
http://www.infoq.com/cn/articles/java-memory-model-5
http://www.docin.com/p-92508695.html%E3%80%82

