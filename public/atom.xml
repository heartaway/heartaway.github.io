<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心静志远</title>
  
  <subtitle>技术终究会淘汰，思想却永存于世   技术才是硬通货，探求思想与本质</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heartaway.cn/"/>
  <updated>2018-11-30T12:23:15.704Z</updated>
  <id>http://heartaway.cn/</id>
  
  <author>
    <name>心静志远</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://heartaway.cn/2018/11/30/Blog/Untitled/"/>
    <id>http://heartaway.cn/2018/11/30/Blog/Untitled/</id>
    <published>2018-11-30T12:21:24.127Z</published>
    <updated>2018-11-30T12:23:15.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心摘要"><a href="#核心摘要" class="headerlink" title="核心摘要"></a><span data-type="color" style="color:rgb(51, 51, 51)">核心摘要</span></h3><hr><ul><li><p>AHAS Agent在线数突破100；</p></li><li><p>AHAS 上线功能特征1个，修复问题 6个；</p></li><li>AHAS 公网VIP申请处于安全评审流程中，预计下周一出结论；</li></ul><h3 id="本周思考"><a href="#本周思考" class="headerlink" title="本周思考"></a>本周思考</h3><hr><p>上周看完了吴军的《见识》，收获颇多，他从金钱观、婚姻观、职业观、世界观等等层面进行了个人习惯的介绍，很多道理我们都有所耳闻，但自己却未能落实下来，还是缺乏响应思维的训练，没能养成这种思维习惯。其中有一点关于日常工作的，“少做事甚至不做事”，意思是我们不要陷入盲目的忙碌工作当中，而忽略了哪些重要的事情。每周只定下一周中最重要的三件事情，其它不重要的事情需要挑选着做。 之前自己的认知是如何让自己每周的效率再高一些，再做多一些事情，其实不然，一个人的效率无论怎么配合先进的GTD工具，都是存在上线的，如果主动画出重要的三件事，一周的心思都放在这三件事情上，反而会让这三件事情的产出更好并且自己的工作跟轻松。</p><p>本周接着休假阅读了部分《人类简史》，作者在前几张讲到的“认知革命”，让我觉得刷新了对人的认识，人类存在了200多万年，实际上爆发是在7万年左右由于基因突变带来的张立行走以及语言的能力，再加上有了想象的能力（包括国家、企业、品牌都是想象出来的），让人能从食物链的中段爬向了顶端。人类看似驯化了小麦、稻谷、牛羊等动植物，实则是这些生物训化了人类，让人类成为其物种繁衍生息的工具。作者这种多时间看问题的角度很特别，其次作者综合生物学、历史学、经济学、数学、物理学等多学科讲述，对我们多角度看问题的思维是一种引导和训练。</p><h3 id="产品运营"><a href="#产品运营" class="headerlink" title="产品运营"></a>产品运营</h3><hr><ul><li><p>本周新开通用户数：84（上周 37)，保有量：363</p></li><li><p>本周新安装AHAS Agent数：42 (上周 37），保有量：101</p></li><li>本周新挂在Java Agent数：6（上周 2），保有量：13</li><li>本周新增演练数：2（上周 10），总量：127；</li><li>详细链接地址：<a href="https://quark.alibaba-inc.com/dashboard/view/page.htm?id=214434" target="_blank" rel="noopener">https://quark.alibaba-inc.com/dashboard/view/page.htm?id=214434</a></li><li>时间范围：上周四~本周四</li></ul><h3 id="应用高可用服务"><a href="#应用高可用服务" class="headerlink" title="应用高可用服务"></a>应用高可用服务</h3><hr><ol><li>AHAS功能迭代：<ul><li>架构感知的表格展示支持按照优先级排序；</li><li>修复部分阿里云ecs接口获取osType为空导致window系统可交互的bug；</li><li>修复部分场景架构感知中进程是否开启防护的错误判断；</li><li>ots数据写操作新增指数退避重试算法，避免由于ots分裂导致的数据写失败问题；</li><li>解决ahas agent一次上报容器数过多导致服务侧超时的问题，变更为批量写等待；</li><li>整理并解决ahas agent上报的各种数据落库时字段超过mysql字段限制的问题；</li><li>排查与定位demo数据部分场景下导致用户白屏问题，原因：前端部分判空逻辑未覆盖；</li></ul></li><li>服务侧支持非非阿里云ECS VPC环境：<ul><li>公网VIP需要安全进行代码级别审核，本周材料已提交，等待安全同学下周一给结论；</li><li>review ahas-proxy 中新增的黑白名单功能feature；</li></ul></li><li>AHAS 质量&amp;稳定性建设：<ul><li>预约孤弋探讨edas agent的稳定性运维方案，由于时间几次错位，预约到下周进行讨论。</li><li>用户反馈ahas agent自动离线，经过排查未发现具体原因（排查记录见aone），此问题需要提高优先级，不能因为接入进来的用户由于功能原因流式。</li></ul></li><li>AHAS 产品推广软文《一分钟进行微服务架构可视化》各大博客论坛推广；</li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>请年假3天</li></ul><h3 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h3><ul><li>AHAS 支持非阿里云ecs vpc测试；</li><li>AHAS Sentinel改造；</li><li>AHAS 产品问题修复以及新feature支持；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;核心摘要&quot;&gt;&lt;a href=&quot;#核心摘要&quot; class=&quot;headerlink&quot; title=&quot;核心摘要&quot;&gt;&lt;/a&gt;&lt;span data-type=&quot;color&quot; style=&quot;color:rgb(51, 51, 51)&quot;&gt;核心摘要&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微服务架构可视化平台实践</title>
    <link href="http://heartaway.cn/2018/11/22/Blog/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://heartaway.cn/2018/11/22/Blog/微服务架构可视化平台实践/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2018-11-29T04:29:05.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要架构可视化"><a href="#为什么需要架构可视化" class="headerlink" title="为什么需要架构可视化"></a><a name="g230wm"></a>为什么需要架构可视化</h3><p>随着企业进行微服务架构改造，系统架构复杂度越来越高，架构变化日益频繁，微服务改造后的实际架构模型可能与预期已经产生了巨大差异，架构师或系统运维人员很难准确记忆所有资源实例的构成和交互情况；其次，系统架构在动态演化过程中可能引入了一些不可靠的因素，比如弱依赖变强依赖、局部容量不足、系统耦合过重等，给系统的稳定性带了极大的安全隐患。所以我们每次在面对系统改造、业务大促以及稳定性治理工作之前，都会通过梳理架构图的方式，呈现系统架构中个组件之间的交互方式，架构可视化能够清晰的协助我们识别架构中存在的问题以及建立高可用的系统。<a id="more"></a></p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542956362235-c47820c3-d1a6-4470-8be3-343ed710ceb7.png" alt="image.png | left | 638x479"></p><div data-type="alignment" data-value="center" style="text-align:center"><br>  <div data-type="p">（<em>Daniel Woods 在讲微服务时时的一张架构图）</em></div><br></div><p>架构可视化后，可以给我们带来以下几点但不局限于此的优势：</p><ul><li>确定系统边界<br>一张好的架构图，应该明确系统所包含的各个组件以及各个组件之间的核心调用关系，这些组件的集合就是系统的处理边界，系统架构的边界在一定程度上也反映了业务域的边界。</li><li>架构问题识别<br>基于高可用的架构准则，结合可视化的架构图，可以评估架构可能存在的安全风险，比如系统在容灾、隔离以及自愈维度下的健壮性。其次，一些架构链路可视化工具(比如鹰眼)在实际工作中确实大大提高了开发者排查与定位问题的效率。</li><li>提高系统可用性<br>有了系统架构的上下游依赖关系图，在故障发生时，开发人员可以借助依赖数据快速定位到问题的来源，极大缩短问题修复时间（MTTR）。借助架构图，我们还可以梳理出系统中存在的强弱依赖，在业务高峰期对弱依赖进行降级，或者针对系统依赖的各个组件进行故障模拟，以评测系统整体在面对局部故障的可靠性。</li></ul><h3 id="常见架构可视化的做法"><a href="#常见架构可视化的做法" class="headerlink" title="常见架构可视化的做法"></a><a name="x8wvqr"></a>常见架构可视化的做法</h3><p>我们熟知的架构图是静态的停留在PPT上的，很多时候我们的架构已经发生了非常大的变化，但是我们还在使用那张看上去很经典却早已过时的架构图。长时间使用与实际架构不符的架构图对线上架构的认知的危害是巨大的，我们需要在脑海中不断更新对系统架构的视图，以保持对系统架构的敏感度。每年的大促或者重大系统改造成为我们梳理系统架构、对架构进行重新认知的机会，此刻我们需要通过各种工具查看系统的各个组件分布以及不同组件的内部与外部的依赖关系，这种梳理架构图的方法是最常用的方式，权且称之为“<strong>手工绘制法</strong>”。</p><p>手工经常干的事情，就有追求效率的同学使用计算机系统带来的自动化手段帮助自己做这件事情，比如我们常常看到的基于数据埋点的微服务可视化解决方案，这类架构可视化手段通常在分布式追踪、APM等监控领域使用较多，下图为某APM产品提供的应用维度架构可视化方案：</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542964309773-458512d9-ae12-464b-a562-33df8342ac54.png" alt="image.png | left | 747x376"></p><p>我们称这种可视化方式为“<strong>埋点式感知法</strong>”，架构组件的识别是依赖关键的核心类检测与埋点，此种方案存在以下弊端：</p><ul><li>语言相关性：只要是系统埋点，与语言相关的特征基本就拜托不了，需要针对不同语言提供不同的依赖包；</li><li>不易维护：因为是对核心类的检测，当组件包做了重大变更时，需要同步变更；</li><li>不易扩展：因为是客户端识别方案，客户端一旦开放出去，新组件的支持只能等待用户更新组件；</li><li>规模受限：客户端识别的另一个缺点是算法受限，服务端进行识别，可以借助大数据分析等手段更有效准确的识别；</li></ul><p>还有一种自动化架构感可视化方法，我们称之为“<strong>无界架构感知</strong>”，是一种语言无关性的架构识别方案，其采用采集用户主机上的进程和容器的元数据、监控数以及网路数据的最最基础的数据，在服务端构建架构图。</p><h3 id="我们设计架构可视化的理念"><a href="#我们设计架构可视化的理念" class="headerlink" title="我们设计架构可视化的理念"></a><a name="sak3aa"></a>我们设计架构可视化的理念</h3><p>为了最大限度上降低用户进行架构可视化的成本，我们采用了无界架构感知-应用无侵入的方式微服务进行可视化，通过采集进程数据与网络调用数据，构建进程间的网络调用关系，构建微服务的架构信息。用户只需要安装我们AHAS Agent探针，即可完成架构可视化操作；对于阿里云云原生系统，我们提供了自动化安装方式，而无需登录机器。</p><h4 id="核心本质"><a href="#核心本质" class="headerlink" title="核心本质"></a><a name="ow5ucr"></a>核心本质</h4><p>软件架构可视化的核心点是寻找在软件体系结构中有意义和有效的元素视图以及这些元素之间的关系。我们认为一款优秀的软件架构可视化产品应该帮助用户排除掉不重要的信息，给用户呈现出对他们有价值的视图，特别是在微服务架构下庞大而复杂的调用关系链场景中。这里面的核心点是<strong>有意义</strong>和<strong>有效</strong>，要做到这两点，首先需要识别什么是有意义和有效的元素和关系，我们在此领域做的事情归纳起来就是“<strong>识别</strong>”，识别机器上的每个进程是什么，发生的网络调用远端是什么，唯有知晓了这些元素是什么我们才有理由和依据来判断是否对用户有意义以及其在用户架构中的重要程度。</p><p>在梳理了大量架构图，我们发现用户关心的架构元素主要分为三类：</p><ol><li>自己的应用服务；</li><li>应用对外部的资源依赖；</li><li>服务器本身的信息。<br>应用对外部资源的依赖通常以其它应用和通用中间件或者存储服务两种形式存在。故我们将需要识别的进程分为：应用服务和常见的组件服务（比如redis、mysql等），这些组件服务又分为用户自建的服务和使用公有云提供的服务，特别是对于Cloud Native应用来说，云服务的识别显得格外重要。<br>目前，我们提供了20种阿里云云服务的识别以及包含mysql、redis、Tomcat等常见的21种三方服务组件，此组件库还在不断扩张中，目的就是最大限度的知晓架构中的元素到底是什么。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542958237398-de68d1b7-ef29-46b7-879b-41cb37b3c8a5.png" alt="image.png | left | 747x377"></p><div data-type="alignment" data-value="center" style="text-align:center"><br>  <div data-type="p">     （图中展示了 通过识别服务识别出来的nginx、redis组件以及阿里云中的Mysql服务和AHAS服务）</div><br></div><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542958281395-8bb05ff4-0958-474d-8f04-546cbf8a0456.png" alt="image.png | left | 747x385"></p><p>（图中展示了节点详情的请求流向以及节点的监控等基本信息）</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542963012342-42798fda-e169-4f2a-aaa8-481b1ff6d98b.png" alt="image.png | left | 747x304"></p><div data-type="alignment" data-value="center" style="text-align:center"><br>  <div data-type="p">(图中展示了识别的主机上的部分进程信息)</div><br></div><h4 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a><a name="xwhcne"></a>架构分层</h4><p>我们同样认为架构可视化的有效性跟人的认知层次有关，架构可视化的重点是确定该工具是否更好的支持自顶向下方法、自下而上方法或者两者的结合。开发者更关心应用维度上的架构，架构师或者管理者更关心整体系统架构。所以需要针对不用的使用者提供不同层次的架构可视化视角。理想的架构图需要支持宏观维度以及不断下钻下的微观视角，我们对架构进行了分层设计，目前分为进程层、容器层和主机层，后期我们可能会继续上扩或者下钻支持地域层或者服务层。</p><h4 id="架构回溯"><a href="#架构回溯" class="headerlink" title="架构回溯"></a><a name="cvcnys"></a>架构回溯</h4><p>没有哪个系统的架构是一成不变的，系统架构会随着系统的版本迭代不断进行演化。所以对架构可视化操作，还需要具备随着时间的推移可对架构信息进行自动更新已经回溯的能力。在我们提供的<a href="https://www.aliyun.com/product/ahas" target="_blank" rel="noopener">架构感知</a>产品中默认架构图会随着时间自动刷新，同时支持对历史的回溯，你可以选择历史中的某一刻查看架构信息，比如，重大版本的变更时，发布前与发布后的系统架构是否发生了违背一些高可用原则的问题，抑或排查是否出现了不该有的依赖问题。</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542960362139-534dd303-c1b7-493a-8685-ac502e356028.png" alt="image.png | left | 747x363"></p><h4 id="可见可得"><a href="#可见可得" class="headerlink" title="可见可得"></a><a name="l3b8al"></a>可见可得</h4><p>架构可视化解决了可见的问题，但当我们从架构图中发现了问题需要解决时，架构图还应该给我们提供便利的可交互操作入口，让我们可以完成问题发现与解决的闭环。比如通过架构感知监控到了某个应用的流量非常大，我们需要对应用进行限流或者预案，那么通过架构图，我们应该是可以完成我们期望执行的操作。在架构图中融入可以交互的运维操作，让我们从看到到操作，再到问题恢复后体现在图中，这就像计算机发展史上从命令行视图到窗口视图的转变。</p><h3 id="我们对架构可视化的定位"><a href="#我们对架构可视化的定位" class="headerlink" title="我们对架构可视化的定位"></a><a name="mtfgyk"></a>我们对架构可视化的定位</h3><p><strong>架构可视化不是目的，只是实现系统高可用性的手段</strong>。借助架构感知采集到的架构数据，在识别了用户使用的组件（我们对mysql、redis、mq等的统称)后，我们借助这些组件以及与组件匹配的故障库，可以给用户自动推荐这些组件可能遇到的故障，配合我们提供的<a href="https://www.aliyun.com/product/ahas" target="_blank" rel="noopener">评测服务</a>让用户更方便地对组件进行各种故障的模拟与演练，以提高系统的健壮性。其次，通过架构感知识别Java Application 应用，如果发现其负载较高，配合我们提供的<a href="https://www.aliyun.com/product/ahas" target="_blank" rel="noopener">限流降级</a>（阿里巴巴开源的Sentinel商业版）功能，为服务的持续可用性保驾护航。</p><p><img src="https://cdn.nlark.com/yuque/0/2018/gif/104361/1542969119301-c0372346-6922-4537-a611-1e772bee351f.gif" alt="ahas-install.gif | center | 747x420"></p><div data-type="alignment" data-value="center" style="text-align:center"><br>  <div data-type="p">（白屏化安装AHAS探针）</div><br>  <div data-type="p"></div><br></div><p><img src="https://cdn.nlark.com/yuque/0/2018/gif/104361/1542971799291-1e0987da-79c4-4e2d-b9d3-4e847a9c82eb.gif" alt="ahas-sentinel.gif | center | 747x420"></p><div data-type="alignment" data-value="center" style="text-align:center"><br>  <div data-type="p">（如何借助架构感知进行系统限流配置）</div><br></div><p>我们对AHAS的定位是一款数据分析型的高可用保障产品，帮助云原生架构系统实现高可用能力的提升。架构可视化是我们给用户提供的高效运维和管控的窗口，我们期望通过丰富的云原生数据体系配合架构图的可视化以及可操作性，建立起以应用为中心的运维一体化平台。在未来，我们会加强与其它云服务的集成，比如监控、容器服务，以丰富架构感知的数据维度；其次，会在数据的深度挖掘和智能化消费上投入更多精力，真正让数据成为企业的核心价值，让数据成为保障业务的稳定性的利器。</p><p>产品体验连接：<a href="https://www.aliyun.com/product/ahas" target="_blank" rel="noopener">https://www.aliyun.com/product/ahas</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要架构可视化&quot;&gt;&lt;a href=&quot;#为什么需要架构可视化&quot; class=&quot;headerlink&quot; title=&quot;为什么需要架构可视化&quot;&gt;&lt;/a&gt;&lt;a name=&quot;g230wm&quot;&gt;&lt;/a&gt;为什么需要架构可视化&lt;/h3&gt;&lt;p&gt;随着企业进行微服务架构改造，系统架构复杂度越来越高，架构变化日益频繁，微服务改造后的实际架构模型可能与预期已经产生了巨大差异，架构师或系统运维人员很难准确记忆所有资源实例的构成和交互情况；其次，系统架构在动态演化过程中可能引入了一些不可靠的因素，比如弱依赖变强依赖、局部容量不足、系统耦合过重等，给系统的稳定性带了极大的安全隐患。所以我们每次在面对系统改造、业务大促以及稳定性治理工作之前，都会通过梳理架构图的方式，呈现系统架构中个组件之间的交互方式，架构可视化能够清晰的协助我们识别架构中存在的问题以及建立高可用的系统。
    
    </summary>
    
      <category term="架构" scheme="http://heartaway.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://heartaway.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="可视化" scheme="http://heartaway.cn/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="AHAS" scheme="http://heartaway.cn/tags/AHAS/"/>
    
  </entry>
  
  <entry>
    <title>我为什么会在这</title>
    <link href="http://heartaway.cn/2018/11/16/Blog/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%9C%A8%E8%BF%99/"/>
    <id>http://heartaway.cn/2018/11/16/Blog/我为什么会在这/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-11-29T04:29:05.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a><a name="d4zzse"></a>思考</h3><p>对于我们个人来说,要问自己的问题是:我为什么在这里?我如何才能帮助公司解决顾客问题？速度快效率高还不够，我们还希望更有成效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;&lt;a name=&quot;d4zzse&quot;&gt;&lt;/a&gt;思考&lt;/h3&gt;&lt;p&gt;对于我们个人来说,要问自己的问题是:我为什么在这里?我如何才能帮助公司解决顾客问题？速度快效率高还
      
    
    </summary>
    
      <category term="思考" scheme="http://heartaway.cn/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="工作" scheme="http://heartaway.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="目标" scheme="http://heartaway.cn/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>本地缓存的数据变更</title>
    <link href="http://heartaway.cn/2018/11/16/Blog/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4/"/>
    <id>http://heartaway.cn/2018/11/16/Blog/本地缓存的数据变更/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-11-29T04:29:05.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><a name="d4zzse"></a>背景</h3><p>业务上有一个需求使用基线数据中拷贝出内容，分发到不同用户集合的存储实例中，使用模型标识就是B-&gt;(u1,u2,u3…uN)，初始代码逻辑是，每个用户都有单独的定时器触发来执行B-&gt;uN的拷贝，执行这个过程需要首先从基线B中取出数据，然后替换为uN的用户信息，在写入uN的数据存储中（用户之间逻辑隔离非物理隔离），期初此流程没什么问题，后来考虑到每个用户读取的基线可能相同，可以对基线数据做local cache，以此来优化程序的执行性能， local cache 变量为全局共享变量，多线程可访问。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a name="isplgh"></a>问题</h3><p>在做性能优化使用local cache的时候，会先查询缓存是否存在，如果不存在，则查询基线数据，如果查询的基线存在的话，则回写到缓存中，并向目标用户实例中写入基线数据，整体流程如下：<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//首先查本地缓存</span><br><span class="line">List&lt;ProcessEntity&gt; processEntities = processCache.getIfPresent(cacheKey);</span><br><span class="line">        if (processEntities == null) &#123;</span><br><span class="line">            //查询存储</span><br><span class="line">            processEntities = processSourceClient.readProcessEntitiesByTimeGrid(</span><br><span class="line">                demoDataRequest.getSourceUserId(), demoDataRequest.getSourceNamespace(),</span><br><span class="line">                demoDataRequest.getSourceTimeGrid());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (CollectionUtils.isNotEmpty(processEntities)) &#123;</span><br><span class="line">            //回写数据到缓存（存在多次写问题）</span><br><span class="line">            processCache.put(cacheKey, processEntities);</span><br><span class="line">            processEntities.forEach(item -&gt; &#123;</span><br><span class="line">                //替换用户属性，问题就在这里</span><br><span class="line">                item.setUserId(demoDataRequest.getTargetUserId());</span><br><span class="line">                item.setNamespace(demoDataRequest.getTargetNamespace());</span><br><span class="line">                item.setTimeGrid(demoDataRequest.getTargetTimeGrid());</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            //写目标用户数据</span><br><span class="line">            processTargetClient.batchWriteProcessLog(processEntities);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>增加了缓存后，我们在编码的时候，很容易认为数据我已经写到缓存中了，再对数据做处理不会影响缓存，但是我们忽略了这里的缓存是本地缓存，且是对象引用下的本地缓存，是共享数据；如果使用分布式缓存，通过数据的序列化和反序列化，相当于对象做了拷贝，不会有问题，如果使用本地缓存，存储数据的副本的话，也不会有问题；但是这里偏偏使用了本地变量，并对数据做了变更，没有引起编码时的注意，导致了错误。这个错误在单元测试的时候，也没测出来，发到生产环境上才对发现存储层在数据写入时大量报写入冲突。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a><a name="bgu6rd"></a>解决</h3><p>使用本地缓存时，如果有数据变更的需求，则需要使用副本，这也是共享变量在多线程中容易导致的一个容易发生的错误。</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/104361/1542351217947-009a8e54-41ed-4409-a896-9bad779f631c.png" alt="image.png | left | 747x300"></p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a><a name="q71zsp"></a>反思</h3><p>期初线上打印出了冲突的问题，总以为是存储这边分批写的问题，后来发现这个问题的发生频次是间歇性的，且无规律，更像是具备随机性，所以决定深入排查，最后发现了编码上的一个很低级的错误。我们不要放过线上任何一个异常，除非我们把问题弄清楚了，否则“墨菲定律”告诉我们，担心出问题的地方，一定会出问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;a name=&quot;d4zzse&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;业务上有一个需求使用基线数据中拷贝出内容，分发到不同用户集合的存储实例中，使用模型标识就是B-&amp;gt;(u1,u2,u3…uN)，初始代码逻辑是，每个用户都有单独的定时器触发来执行B-&amp;gt;uN的拷贝，执行这个过程需要首先从基线B中取出数据，然后替换为uN的用户信息，在写入uN的数据存储中（用户之间逻辑隔离非物理隔离），期初此流程没什么问题，后来考虑到每个用户读取的基线可能相同，可以对基线数据做local cache，以此来优化程序的执行性能， local cache 变量为全局共享变量，多线程可访问。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;&lt;a name=&quot;isplgh&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在做性能优化使用local cache的时候，会先查询缓存是否存在，如果不存在，则查询基线数据，如果查询的基线存在的话，则回写到缓存中，并向目标用户实例中写入基线数据，整体流程如下：
    
    </summary>
    
      <category term="编程" scheme="http://heartaway.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="共享变量" scheme="http://heartaway.cn/tags/%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F/"/>
    
      <category term="缓存" scheme="http://heartaway.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>建立人生准则</title>
    <link href="http://heartaway.cn/2018/11/10/Blog/%E5%BB%BA%E7%AB%8B%E4%BA%BA%E7%94%9F%E5%87%86%E5%88%99/"/>
    <id>http://heartaway.cn/2018/11/10/Blog/建立人生准则/</id>
    <published>2018-11-09T16:00:00.000Z</published>
    <updated>2018-11-29T04:29:05.215Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间百无聊赖之际无意翻阅到一部日漫《十二国记》，看之前我先翻了翻豆瓣评价（下意识的去评估投入产出比），评价的人不多，但是很多评价说儿时的这部日漫奠定了自己的人生价值观以及世界观，我随之着了迷，到底是一部什么动画有这么大的魔力？</p><p>在看了前几集的略显拖沓的情节后，越发后面越来越精彩。看到女主从一个柔弱的女高中生，在不断面对自己内心的批判与挣扎中变得越发强大，看到了活在自己痛苦之中的铃，看到也不知道为什么而存在的浅野，其中有很多让人深思的对白，从这部动漫的各个人物角色中，总能找到那个似曾相识的自己。</p><h3 id="活出自我"><a href="#活出自我" class="headerlink" title="活出自我"></a><a name="wgbkts"></a>活出自我</h3><p>我从小就是那种乖乖孩，周边几乎所有的亲朋好友对我的评价基本都是“听话、懂事”，无论是在学校与老师、同学的关系，还是在家与父母亲人的关系，我都处理的很融洽。我曾一度认为这是自己处事得体的结果，看到了阳子面对自我的时候，才知道了原因。阳子像画出来一样的优等生，私生活和家庭都很踏实，和同学的关系十分友好，老师们也很喜欢她，不过一般来说这种事是不可能的，对老师来说都额好孩子，在同学间就会被梳疏远，在朋友心中受欢迎的话，在父母看来就像是走上了歪路一样，<strong>每个人眼中看起来都好的孩子，往往只是为了让别人认同自己而丧失了自我，一味地迎合别人而已</strong>。<a id="more"></a></p><p>反观自己又何尝不是呢，以前都在按照别人的眼色与期望生活着，活成了别人期望的样子，反而丢失了自己。以前父母任何的决定，我几乎都是顺从，老板的任何安排与要求我也是全盘收纳，知道有一天，我觉得我应该有自己的思想以及对事物的价值判断了，我开始尝试的去独立思考，对父母意见的反驳让他们很是意外，让他们让为一向很乖的儿子变了，变得不再听话了；对老板也提出了自己不同的观点，即便是双方都没能很好的控制好情绪。此刻，我觉得我才是我，之前接近三十年似乎都活在一个皮囊之下。</p><p>最近延禧攻略比较火，魏璎珞得到皇后的格外恩宠，究其原因，竟然是：璎珞就像当年的自己，所以保护璎珞就像保护当初的自己。魏英璐是在为自己而活，而其他人都是在为别人而活，活成了别人期望的样子，以至于自己都不认识自己了。 ​​​​</p><h3 id="投资回报"><a href="#投资回报" class="headerlink" title="投资回报"></a><a name="2lv6tr"></a>投资回报</h3><p>有人说“成年人的世界没有永远不变的友谊，只有不变的利益”，单这句话我是赞同的，毕竟这个世界运行的基础就是以经济发展为基本规律，一切利益化，也不是我们能改变的社会规则。职场上，大家成为相互的朋友的前提是在能力圈范围差不多的时候，你有的东西正好是我要的，如果不在一个朋友圈内，这种关系也很难维持。生活中，人每隔七年的交际圈会发生一次改变，不是因为友谊不在了，而是因为我们在考虑投资收益比的思维习惯影响下，那些低价值的社交被我们主动过滤掉了。成熟的我们做任何事情之前都会开始思考，对我有什么好处，我能得到什么，即便是爱一个人，也会去衡量我是不是爱他比他爱我多一点点。其实，计较的太多，让我们过的异常疲惫，社会其实不负责，复杂的是人心。<br>阳子曾说：就算被人背叛，那也只是背叛别人的人变得卑鄙！因为不是出于善意就不相信人吗？如果对方不亲切对我就不能对他亲切吗？我相信对方，和对方是否背叛我，没有任何关系！我只是一个人，这就是为什么所有有关我的事有我自己决定！就算没有任何人对我好，就算怎样被其他人被背叛，我也不会成为一个不相信任何人的卑鄙小人！跟世界各他人无关，<strong>因为我想对人亲切所以亲切，因为我想相信别人所以相信！</strong></p><h3 id="比惨心理"><a href="#比惨心理" class="headerlink" title="比惨心理"></a><a name="lyw4kr"></a>比惨心理</h3><p>因“蚀”被卷入十二国的大木铃，一度认为自己是世界上最不幸的人，无论在什么地方都会跟别人比不幸。有时人在说‘我好不幸’时也许与说‘我好幸福’时一样充满了自豪！人一般都不愿承认自己是这个世上最幸福的人，倒是拼命与别人争夺‘我是世上最不幸的人’，至少‘在某一方面我就是这个世上最不幸的人！’从而给自己自怜的理由，从而认为大家都应该同情我，顺从我，这其实是奢望更多幸福的一种心理！</p><p>若一个人实在是无法忍受时，他必定会逃，如果他没有这样做，不管是什么理由，那必定是还可以忍受，并潜意识地把自己置于这种悲惨的地步，一面在自怜：‘我为何如此不幸？’一面在自欺：‘一定会有人给我幸福！’。</p><p>祥琼曾说：只是在炫耀自己比别人更不幸，不是吗？说什么那家伙很可怜，自己更可怜什么的，只不过是在刻意让自己觉得不幸而已。有痛苦的事很伟大吗？能够忍受痛苦很伟大吗？我的话就想办法让自己不那么痛苦。说什么一个人比另一个人更痛苦根本是假话,每个人其实都有同样多的痛苦.真的痛苦的话,人就会拼了命想办法从那种情况下逃脱出来.没有逃走,是因为姐姐只是喜欢把自己置身于不幸的感觉里不是吗?对这样的人为什么要同情?</p><p>这个世界上的人，<strong>每个人的人生都是一半幸福，一半痛苦</strong>。遇到痛苦的事情，不要以为是社会独对自己的不公，应尽全力突破困难，化危机为机遇，让困难成为自己成长的助力器。</p><h3 id="为行为负责"><a href="#为行为负责" class="headerlink" title="为行为负责"></a><a name="227krc"></a>为行为负责</h3><p>以前我从来没有意识到我们做任何事情一旦决定了，就需要为结果埋单这件事。没有谁提醒过这个是现实世界的生存法则之一；也许我看到或听到别人说过，但是没有体感，丝毫不认为这条可以成为人生原则之一。直到去年在看《画江湖之不良人》中张子凡的九叔的情节，让我有所领悟。  张子凡九叔叫李存忠，奉老大李嗣源的命令找回张子凡，在找到张子凡之后，按理说任务完成了，就该回去了，但子凡请求其救出李星云，其明知要在汴州营中捞人按期的武力就是以卵击石，又考虑到如果如果能顺便把李星云带回通文馆的话，又是立功一件，此时摆在李存忠面前的是一个选择题，要不要做这个风险与收益并存的支线任务呢！结果如大家预料的一样，任务失败，害的十二叔李存孝惨死汴州，自己也深受重伤，张子凡也没能如愿带回，在回到通文馆向李克用请罪时，迫于压力被李嗣源的射杀，当场毙命。</p><p>我们在小的时候不需要为行为负责或者没有被教育要为行为负责，是因为父母是我们的庇护伞，我们在外面闯祸犯错了，父母总是说会想办法摆平，我们反而逃避了惩罚，这就导致了缺乏对自己行为负责的思考。小孩子的世界与成年人的世界不同，需要按照成年人的游戏规则生成。<strong>我们在做任何事情之前，都需要谨慎考虑清楚自己是否有能力承担其结果，如果不能或者不愿，那就不要做这个决定，不要要让自己成为巨婴，做了事情又不远承担结果的人。</strong></p><p>无论生活还是工作当中，也是如此，你要想有所成绩，就必须做好因成绩不佳而可能带来的不良影响。比如因做阿里云而苦守多年受尽激讽的王坚博士，比如因推进阿里做社交软件来玩的前CEO陆兆禧，做成了一代功臣高高在上，做失败了，退出历史舞台。人生中的机会并不多，做好每一次的决断，不要事后为你改承担的结果而啧啧不休。</p><p>无论你听过再多的道理，当你没有经历过一些事情或者心智没有达到这个境界的时候，你是不会理解这个道理的，所以人们会常常说“道理我都懂，然后并没有什么乱用”，那是因为你经历的还是太少，痛了你就明白了。</p><h3 id="人生信仰"><a href="#人生信仰" class="headerlink" title="人生信仰"></a><a name="lgmxum"></a>人生信仰</h3><p>以前我是不太相信信仰的，这可能跟中国大环境下缺乏信仰有关。从小到大，没有任何教育说要建立个人信仰，要建立个人人生准则与道德底线，也不知道成为一个什么样的人才算是一个合格的人。那时候大人们只会问，你长大了想当什么，我们会回到当医生或者警察亦或者老师，但是也说不清楚为什么相当。直到从《十二国记》中看到了乐俊，我觉得，他就是我想要找的那个人生导师。真诚待人，而不是怀有功利心；即便整个社会都不接纳自己，自己也要努力拼搏，活出自我；强大的包容心，对过失的包容，对不公的包容，对人心阴暗面的包容；乐观积极向上，睿智而博学。</p><p>在我们面对教条主义式的价值观灌输时，我们往往都是怀有抵触心理的，像动漫这种以动人的故事来告诉你什么是好的，什么是值得推崇与坚守的，更能让人信服。有了人生导师，就应该在生活中践行，做到知行合一。公共场合不大声喧哗，主动让座，主动拾起垃圾，以力所能及的方式帮助需要帮助的人。多以有爱的眼光看到这个世界，你会发现，有底线、有准则、有信仰、有关爱的人就在你我身边。</p><h3 id=""><a href="#" class="headerlink" title=""></a><a name="gznzgi"></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间百无聊赖之际无意翻阅到一部日漫《十二国记》，看之前我先翻了翻豆瓣评价（下意识的去评估投入产出比），评价的人不多，但是很多评价说儿时的这部日漫奠定了自己的人生价值观以及世界观，我随之着了迷，到底是一部什么动画有这么大的魔力？&lt;/p&gt;
&lt;p&gt;在看了前几集的略显拖沓的情节后，越发后面越来越精彩。看到女主从一个柔弱的女高中生，在不断面对自己内心的批判与挣扎中变得越发强大，看到了活在自己痛苦之中的铃，看到也不知道为什么而存在的浅野，其中有很多让人深思的对白，从这部动漫的各个人物角色中，总能找到那个似曾相识的自己。&lt;/p&gt;
&lt;h3 id=&quot;活出自我&quot;&gt;&lt;a href=&quot;#活出自我&quot; class=&quot;headerlink&quot; title=&quot;活出自我&quot;&gt;&lt;/a&gt;&lt;a name=&quot;wgbkts&quot;&gt;&lt;/a&gt;活出自我&lt;/h3&gt;&lt;p&gt;我从小就是那种乖乖孩，周边几乎所有的亲朋好友对我的评价基本都是“听话、懂事”，无论是在学校与老师、同学的关系，还是在家与父母亲人的关系，我都处理的很融洽。我曾一度认为这是自己处事得体的结果，看到了阳子面对自我的时候，才知道了原因。阳子像画出来一样的优等生，私生活和家庭都很踏实，和同学的关系十分友好，老师们也很喜欢她，不过一般来说这种事是不可能的，对老师来说都额好孩子，在同学间就会被梳疏远，在朋友心中受欢迎的话，在父母看来就像是走上了歪路一样，&lt;strong&gt;每个人眼中看起来都好的孩子，往往只是为了让别人认同自己而丧失了自我，一味地迎合别人而已&lt;/strong&gt;。
    
    </summary>
    
      <category term="思考" scheme="http://heartaway.cn/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="目标" scheme="http://heartaway.cn/tags/%E7%9B%AE%E6%A0%87/"/>
    
      <category term="人生" scheme="http://heartaway.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="感悟" scheme="http://heartaway.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>他人经受的，我必经受</title>
    <link href="http://heartaway.cn/2018/10/06/Think/2018-10-06-marriage-quarrel/"/>
    <id>http://heartaway.cn/2018/10/06/Think/2018-10-06-marriage-quarrel/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.811Z</updated>
    
    <content type="html"><![CDATA[<p>早上起床后，悠然自得地在阳台上晒着太阳看着柴静的《看见》这本书。突然楼上吵架吵的甚是厉害，这已经不是第一次听到楼上吵架了，每次都是伴随着咕咕嘟嘟的物品跌落到地板上声音、妇女歇斯底里的呼喊声、小孩声嘶力竭的哇哇哭闹声、间歇性的愤怒的男性咆哮声。</p><p>这一次吵闹的比之前几次都要凶，我感觉不太对劲，打开门，走上楼梯，准备去帮他们和解一下，心想：毕竟是一家人，没必要闹到这个份上。当我走到楼上时，女主站在门外，朝着门内哭喊道“你为什么打我，我出来没有打过你，你为什么打我”，他们的门没关，我看到他们玄关的台面上堆满了书籍，放不下的书籍已经被实实在在的塞在了竖立起来的书层上面，想必也是一定程度上的知识分子，我刚准备去拦架，就听到女主对着门外吼道：“我是在受不了你了，你给我走”，听到这些，我的脚步迈不开了，感觉自己想好的劝解的话不一定能凑效，反而可能让他们觉得不堪的场面，此刻他们需要的是冷静，然后控制住自己的情绪。</p><p>我重新回到阳台，继续翻看书籍《看见》，正好看到讲述十几位女性因为无法忍受自己的丈夫而杀害丈夫的故事，调查中的大部分女性都是在无数次沉默忍耐之后才爆发了最后的还击。我从小也经历过父亲喝醉酒，发了疯似的，拿着砍刀要杀人，当时母亲哭泣着抱着我躲在房间的角落里，我至今还清晰的记得那门框旁边残留的被刀砍下的凹痕；母亲的性格是那种凡事都隐忍，不主动把事情摊开来说的那种，我之前还嘲笑母亲懦弱的性格，后来我才明白这是“恐惧留下的阴影”，一个没有当过弱者的人，不会体会到这种恐惧。那些女犯人之所以环击，正是因为恐惧的一层层积累，积累到一定程度后，就会以暴力的方式爆发。</p><p>“叮咚，叮咚”，一阵门铃响声打断了我的思绪，我打开门，看到是天猫超市的配送员，他说打我手机没人接，担心我家的东西又丢了，现在都不敢放门口了，听到楼上的吵闹神，他说：“我也是离过婚的人，一个人来到异地杭州，无依无靠”。我不知道该说回答他，脑子中对婚姻这件事有了缕缕疑惑。</p><p>楼上的声音渐渐消停了下来，我也看到这篇报道的结尾了，结尾处柴静写到“他人经受的，我必经受”。在最近的几年里，我愈发的明白一个道理，那就是：<strong>不要随意地站在自我的立场上使用自己那有限的人生经历去揣测与评判别人的人生，我们不曾经历过的一切都让我们的评论显得格外肤浅。</strong></p><p>此时，老婆问我，“我们如果吵架了，你会怎么样？”，我笑了笑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上起床后，悠然自得地在阳台上晒着太阳看着柴静的《看见》这本书。突然楼上吵架吵的甚是厉害，这已经不是第一次听到楼上吵架了，每次都是伴随着咕咕嘟嘟的物品跌落到地板上声音、妇女歇斯底里的呼喊声、小孩声嘶力竭的哇哇哭闹声、间歇性的愤怒的男性咆哮声。&lt;/p&gt;
&lt;p&gt;这一次吵闹的比之
      
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>如何解决技术焦虑</title>
    <link href="http://heartaway.cn/2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/"/>
    <id>http://heartaway.cn/2018/04/13/Think/2018-04-13-how-to-resolve-tech-anxious/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.811Z</updated>
    
    <content type="html"><![CDATA[<p>从事软件编程已经长达8年之后，曾经中间有很长一段时间感觉自己的技术能力没有得到根本性提升，与那些优秀的同龄人相比，技术自卑油然而生，面对日新月息的技术变更和时不我待的岁月流逝，步入中年的我不得不变的焦虑起来。回顾自己的编程生涯，刚毕业的头几年，通过自主学习实现了编程语言的基本掌握，紧接着使用学到的技术完成各种项目，然后日复一日，有时候也会看看技术书籍，但是终究未能突破语言层而知晓技术背后的本质。而后通过长时间的摸索与交流，寻找到了一些解决技术人技术焦虑的方法，这些问题和方法更多的是一种思维方式，一种看问题的视角，希望这些建议能够让我们有所收获和思考。</p><h2 id="技术焦虑的起因"><a href="#技术焦虑的起因" class="headerlink" title="技术焦虑的起因"></a>技术焦虑的起因</h2><h4 id="技术热情变低"><a href="#技术热情变低" class="headerlink" title="技术热情变低"></a>技术热情变低</h4><p>有人说：职业倦怠是做了大量重复劳动缺乏调整，或者努力完成高风险问题最后却以失败告终而导致的。在软件行业，接触了很多人，发现一开始大家对技术都非常热情，当把它编程职业后，时间一长，就索然无味了，但是又不得不从事这个行业，毕竟还要养家糊口。缺乏热情，可能是我们进入了瓶颈期，在大量重复劳动当中，自然提不起什么兴趣。我们可以有两种方法破局：1. 主要要求承担自己感兴趣又没做过的事情。阿里有一句老话，“今天最好的表现是明天最低的要求”，我们要时刻突破自己所在的“舒适区”，让自己跳跃到“学习区”。2. 为自己而工作。为别人工作就很容易消耗的我们的热情，如果我们转变思路，把学习工作转变为为自己工作，就会有所动力。我过观察到的是，那些在专业领域上付出了极大热情的人，往往因为这个工作领域的投入而成就了自己的影响力，难道这不是在为自己工作，为自己打造信用背书，为自己打造个人品牌吗。<a id="more"></a></p><h4 id="新技术层出不穷"><a href="#新技术层出不穷" class="headerlink" title="新技术层出不穷"></a>新技术层出不穷</h4><p>新技术的迭代更新速度远远超过了我们获取新知识的速度，然而我们并没有过多时间去深入学习每一门技术。当我们还没有把Java并发包下的每一个核心类的原理弄清楚的时候，Java库已经从7升级到了10，我们还在谈服务化的时候，微服务、ServiceMesh、Serverless、FaaS这些新技术迎面而来，让我们应接不暇。工作多年的你，想一想，自己多久没有利用业余时间系统性的学习一门新技术了，我们往往以为通过多看微信朋友圈中的技术转发帖就能获取精华知识，以为我们自己在学习，其实这只是我们在安慰我们那颗想学习有不想付出太多精力的心而已。</p><h4 id="加班太多，没时间学习"><a href="#加班太多，没时间学习" class="headerlink" title="加班太多，没时间学习"></a>加班太多，没时间学习</h4><p>在之前离开阿里出去创业的几年时间里，几乎把能用的时间都用在了做业务系统，有很长一段时间，每天工作12小时以上，一周工作6天，深切能体会到长时间做业务系统的研发那种迫不得已。在面对各种Deadline时，我们做技术调研、技术方案也就马马虎虎过去了，恨不得一拿到需求就开始编码，每天拼命加班完成那些似乎并不那么重要的需求，反而搁浅了那些更重要的事情。一接到任务就开始 Coding 的程序员，通常就是加班最多的程序员，<strong>切记积极工作和勤于思考都要占时间</strong>。加班占用了我们太多的精气神，即便是有一时的闲暇，也想着让疲惫的身心得到一丝舒缓，哪再有学习的动力，我们似乎陷入已经坠入了加班与没有时间学习带来的焦虑陷阱。</p><p>有一些团队文化中，非常推崇加班文化，甚至开始攀比谁加班多，似乎谁加班多谁付出就多绩效就好。我曾经竟然可笑的认为通过加班付出的越多，自己的价值也就越大，团队也就越信任你，其实这是非常错误的思维，<strong>常态加班只能证明我们不会选择或者效率低下</strong>。考核一个人对业务和团队付出多少是拿业务结果来说话的，并不是那加班。认真想一想通过加班透支太多个人时间这件事情，我们为什么要加班？<strong>我们之所以加班，是因对之前承诺的内疚</strong>；加班让我们成为了一个只会低头做事情的人，让我们缺少了抽身看全局的机会。从时间投资的角度讲，常态加班，也是对我们自身时间的极大浪费，我们应该学会选择，学会拒绝，学会借力，做最重要的事情，给自己预留空闲时间，用来做自己喜欢做的事情。</p><h2 id="解决技术焦虑"><a href="#解决技术焦虑" class="headerlink" title="解决技术焦虑"></a>解决技术焦虑</h2><p>在意识在自我对技术的焦虑后，开始关注如何解决这种焦虑感，解铃还须系铃人，那些往往让我们害怕或者恐慌的东西才是我们需要去弥补的。技术焦虑也是一样，是一种技术不自信，是自己技术上有很多短板和盲区，伴随着中年危机的到来，害怕因为专业性的不成熟而被整个行业淘汰。去年华为去大龄码农，去的正是那些不能提供技术专业性的员工。解决办法自然是通过沉下心来，慢慢的把基础中的短板不起来，拓宽自己知识宽度的同时，挖掘技术深度。在整个学习过程中，一些几点也许能让我们跟轻松跟高效的来面对技术的学习以及技术焦虑的消除。</p><h4 id="寻找兴趣点"><a href="#寻找兴趣点" class="headerlink" title="寻找兴趣点"></a>寻找兴趣点</h4><p>很多时候，技术之所以对我们的吸引力不够，不能让我们为之废寝忘食的一个原因，那就是我们没有找到一个自己感兴趣的点。比如，我之前有一段时间对技术几乎麻木了，没有任何动力去翻看技术文章，遇到大家都转载的博文，也就是顺手收藏起来，明知道自己不会再看，还是自我安慰到兴许后续会有时间学习，一年下来技术基本没什么积累，我甚至开始怀疑自己是否适合程序员的岗位。直到有一天，朋友向我推荐了一本书《编码·隐匿在计算机背后的语言》，这本书从手电筒开合讲到继电器编解码，再讲到计算机的构造，让我大跌眼镜，以前觉得计算机非常高深莫测，看完这本书之后才觉得原来如此，我竟然有了在淘宝上购买继电器回家自己一台计算机的冲动。应用举一反三以及类比的方法，把“编码”、“解码”的思维应用在生活的各个细节当中，发现很多道理都是想通的。有人对它的评价是“这本书花两个半天读上一般的内容，你的人生就赚到了”。</p><p>自此，我似乎重新拾起了对计算机的兴趣。然后重新找回一些计算机理论知识中的经典书籍，一本一本开始看，以前觉得深不可测、遥不可及的知识点，掌握其理念之后，觉得也就那么回事。所谓技术自信，就是自身具备盖世武功，面对对手的花样进攻，坦然处之了的心态。</p><h4 id="调整学习方式"><a href="#调整学习方式" class="headerlink" title="调整学习方式"></a>调整学习方式</h4><p>作为一名技术从业者，“终身学习”的道理自然不必多讲。那如何学习呢，学习有哪些方式呢？这个问题我出来没有认真考虑过，难道还有人不会学习吗？引发我对学习方式的思考，是源于跟同事的一次闲聊。同事说“我喜欢<strong>整体性学习</strong>，对一门新技术，势必先全部通读一遍，然后知晓其原理在开始编码，防坑，可控性更强”，我想了想我的学习方式，说“我自己属于<strong>模仿性学习</strong>，现学现用，不懂就查”；为什么会有这两种学习方式呢？他们之间有什么区别，哪一种效率更高呢？带着这些疑问，我查阅了《如何高效学习》、李善友老师的《混沌大学》、许岑老师的《如何成为有效学习的高手》、小马宋的《朋友圈的尖子生》等多本有关学习方法的书，最后得出一个结论：一切事情都有方法论或套路，我们需要看清楚变化事物背后不变的本质。所谓<strong>套路</strong>，就是大家从历史中总结出来的可复制的经验，我们每一个个体按照套路行事，也能学会的东西。比如围棋的定式、程序中的算法、设计模式、菜谱等等，这些都称得上是套路。</p><p>那学习方式目前主要分为两类，一类是自然主义学习；一类是结构主义学习。自然主义学习是基于模仿，通过向他人学习然后进行自我实践，比如我们学习说话、绘画、溜冰、弹钢琴等；而结构主义学习是系统性的构建并创造新的知识晶体，比如数学、物理、编程。针对学习任务的不同，采用合适的学习方法能让我们学习效率事半功倍。在回过来看看自己过往在软件编程上的学习策略，一直是在是在基于点的模仿性学习，而非像结构主义学习那样，讲究面，讲究整体性和系统性。只知道各个点的弊端是让我们看不到面的边界，不知道还有多少我们看不到，这不仅给我让我们对技术产生焦虑，也让自己的视野变得越来越窄；看似每天很努力的工作和学习，其实效率不高、结果不好正是这个原因。所以，面对编程技术的学习，做好的做法是结构化学习，拿整块的时间来学、系统的学，学习技术的历史背景、技术的核心思想、技术的使用范围以及边界，然后再通过自然主义学习策略下的模仿进行逐步实践，方能让我们更快更好的获取到知识。</p><h4 id="看清事情本质"><a href="#看清事情本质" class="headerlink" title="看清事情本质"></a>看清事情本质</h4><p>我们重复编码了多年，还是不得要领，就像学习了各种武功，还是无法突破招数的局限一样，这可能就是我们只知道使用技术，而忽略了技术背后真正的核心思想。在过去一年中，我面试了很多的同学，发现很多技术从业者都有一个共性，那就是只会基本使用，不知其实现原理，即便有一些知晓原理，稍微变通一下后，就无法应答，说明还是理解不深。其实计算机技术知识跟其它门类的只是也是一样的，总有一个核心思想在里面，比如《论语》的核心就是“仁”和“礼”，《孙子兵法》中的借刀杀人的核心就是“敌已明,友未定,引友杀敌,不自出力”。</p><p>那么计算机编程的核心思想是什么呢？是那些变化多端的设计模式，是不断演化的架构形式？这些都不是，我查阅多本资料，发现其本质是 “程序 = 算法 + 结构”，然后拿着这个本质在去看spring 源码、Mybatis源码，寻找他们实现的核心数据结构是什么，算法又是什么，使用了什么套路(设计模式)，在横向上跟其它技术做一下比对。比如spring中有缓存、Mybatis中有两段缓存、数据库有缓存、Redis分布式缓存、操作系统有缓存、CPU有缓存，为什么要使用缓存，这些缓存实现之间有什么共同之处？这还只是局限在编程里面，在现实世界中是不是到处都有缓存的实例呢，比如我们背诵各种诗词歌赋或者数据乘法表，以便在大脑中缓存这些知识，要得就是在最短的时间提取出答案，即便是占用大脑的一些记忆空间。再比如我们去食堂吃饭排队，这个队列是FIFO还是具有优先级的队列，如果队列为空了，打饭的是否是不是处于阻塞状态，如果队列满了，后来的人怎么办？当我们从学习的事情中进行抽象化，看到事情的本质后，在进行举一反三，多领域多维度验证，我们就会觉得“大道至简”，很多道理都是相同的，即便复杂如计算机系统也是一样。</p><p>当然除了看清楚技术的本质，我们在团队沟通协作当中也是需要应用这一思维，比如一个人发表了一个观点，那我们就应该想一想他说出这个观点的本意是什么，他是怎么想的，为什么会提出这样观点，这个观点的核心理念是什么，如果我们要说服他改变观点，我们要怎么做。在日常生活当中多刻意练习这一思维习惯，并通过与当事人的正面沟通寻求其真实本意的想法来及时矫正自己的思维模式（及时反馈），时间一长，习惯就培养出来了，这个时候，我们说话办事就不会再冲动和肤浅了。</p><h4 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h4><p>伴随着长大，让我们逐渐养成了“趋利避害”的行为习惯，原本自身上的各种棱角也被残酷的现实社会磨得异常圆滑，在各种决策中，我们似乎养成了随大流的习惯；学习技术，我们跟大流，别人学什么，我们也学什么；离职创业，在我们还没有想清楚自己是不是合适的时候，总理说“万众创业、大众创新” ，我们就投入到了创业的大潮当中；我们似乎活在了别人的思维模式下。那我们自己也有大脑，为什么就不能好好想一想自己目前的处境，未来的规划呢？ 思考本身就是一件苦差事，我们身体的本能就是尽量大脑降低负荷，能不动脑就不动脑，我们要克服这种情况，如果大脑长时间不用，就会退化，让我们成为独立个体的正式我们透过独立思考展示出来的人格魅力。</p><p>我之前老板有一个习惯，就是每天吃完晚饭后，回到工作岗位上，给自己预留半个小时，让自己处于冥想状态，思考自己当前在做什么，为什么做，需求本质是什么，能不能不做，做的怎么样，是不是有更高效的做法，同行业是怎么做的，整个市场是怎么样的，未来三到五年会有什么变化。 他建议我也尝试此方法，我在尝试此方法之前，就感觉每天忙忙碌碌，也不知道为什么忙，做日常工作似乎只是为了生计或者不得不做，通过这样的训练，发现自己成为了这件事情的主人，看到了很多之前不曾看到的东西，之前只能这低头走路，看路好不好走，而忽略了路的方向以及路边精彩的风景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从事软件编程已经长达8年之后，曾经中间有很长一段时间感觉自己的技术能力没有得到根本性提升，与那些优秀的同龄人相比，技术自卑油然而生，面对日新月息的技术变更和时不我待的岁月流逝，步入中年的我不得不变的焦虑起来。回顾自己的编程生涯，刚毕业的头几年，通过自主学习实现了编程语言的基本掌握，紧接着使用学到的技术完成各种项目，然后日复一日，有时候也会看看技术书籍，但是终究未能突破语言层而知晓技术背后的本质。而后通过长时间的摸索与交流，寻找到了一些解决技术人技术焦虑的方法，这些问题和方法更多的是一种思维方式，一种看问题的视角，希望这些建议能够让我们有所收获和思考。&lt;/p&gt;
&lt;h2 id=&quot;技术焦虑的起因&quot;&gt;&lt;a href=&quot;#技术焦虑的起因&quot; class=&quot;headerlink&quot; title=&quot;技术焦虑的起因&quot;&gt;&lt;/a&gt;技术焦虑的起因&lt;/h2&gt;&lt;h4 id=&quot;技术热情变低&quot;&gt;&lt;a href=&quot;#技术热情变低&quot; class=&quot;headerlink&quot; title=&quot;技术热情变低&quot;&gt;&lt;/a&gt;技术热情变低&lt;/h4&gt;&lt;p&gt;有人说：职业倦怠是做了大量重复劳动缺乏调整，或者努力完成高风险问题最后却以失败告终而导致的。在软件行业，接触了很多人，发现一开始大家对技术都非常热情，当把它编程职业后，时间一长，就索然无味了，但是又不得不从事这个行业，毕竟还要养家糊口。缺乏热情，可能是我们进入了瓶颈期，在大量重复劳动当中，自然提不起什么兴趣。我们可以有两种方法破局：1. 主要要求承担自己感兴趣又没做过的事情。阿里有一句老话，“今天最好的表现是明天最低的要求”，我们要时刻突破自己所在的“舒适区”，让自己跳跃到“学习区”。2. 为自己而工作。为别人工作就很容易消耗的我们的热情，如果我们转变思路，把学习工作转变为为自己工作，就会有所动力。我过观察到的是，那些在专业领域上付出了极大热情的人，往往因为这个工作领域的投入而成就了自己的影响力，难道这不是在为自己工作，为自己打造信用背书，为自己打造个人品牌吗。
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis 核心理念</title>
    <link href="http://heartaway.cn/2018/04/09/Java/2018-04-09-mybatis-core-thought/"/>
    <id>http://heartaway.cn/2018/04/09/Java/2018-04-09-mybatis-core-thought/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.803Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mybatis的本质：混合型Java对象持久化工具；</p></blockquote><h3 id="前置说明："><a href="#前置说明：" class="headerlink" title="前置说明："></a>前置说明：</h3><p>需要提前具备SQL、JDBC、RDBMS、XML、OOP等知识；</p><h3 id="什么是Mybatis："><a href="#什么是Mybatis：" class="headerlink" title="什么是Mybatis："></a>什么是Mybatis：</h3><p>核心点：</p><ul><li>支持了SQL、存储过程、对象/关系映射的持久化框架；</li><li>消除了几乎所有的JDBC代码和需要手工处理的参数和结果；</li><li>支持XML和注解两种方式来配置sqlmap、mapper、pojo三者之间的关系。</li></ul><p>Mybatis理念：坚信SQL、RDBMS将继续使用<strong>30年</strong>；</p><h3 id="Mybatis-核心概念"><a href="#Mybatis-核心概念" class="headerlink" title="Mybatis 核心概念"></a>Mybatis 核心概念</h3><p>数据模型：</p><ul><li>Configuration</li><li>SqlSessionFactory</li><li>SqlSession</li><li>MappedStatement</li></ul><p>运行期四大组件：</p><ul><li>Executor </li><li>StatementHandler </li><li>ParameterHandler </li><li>ResultSetHandler</li></ul><p>算法：</p><ul><li>Java静态&amp;动态代理</li><li>待补充</li></ul><h3 id="Mybatis-发展历程"><a href="#Mybatis-发展历程" class="headerlink" title="Mybatis 发展历程"></a>Mybatis 发展历程</h3><p>ibatis → mybatis</p><p>ibatis 于2002年由 Clinton Begin创建；<br>ibatis 于2010年暂停维护，专有apache维护，改名为mybatis，版本定位mybatis 3；</p><h3 id="Mybatis-工作流程"><a href="#Mybatis-工作流程" class="headerlink" title="Mybatis 工作流程"></a>Mybatis 工作流程</h3><p><img src="/images/posts/20180409/mybatis-work-flow.jpg" alt=""><br>​    （选自CSDN：亦山）</p><h3 id="Mybatis-中的设计思想"><a href="#Mybatis-中的设计思想" class="headerlink" title="Mybatis 中的设计思想"></a>Mybatis 中的设计思想</h3><ol><li>外部化SQL&amp;参数配置化，将设置与运行策略分离；</li><li>采用配置化原因：降低编码复杂度，提高可读性和可维护性；</li><li>封装SQL；基于接口编程，屏蔽SQL对外部的具体实现；</li><li>随处可见的工厂模式、builder模式、Proxy模式、装饰器模式；</li><li>将大系统设计为多个子系统，每个子系统的功能相对集中，尽可能将那些需要由不同的开发角色处理的任务分离开来。</li><li>Cache的实现模式：链式静态代理，原始对象PerpetualCache；<ul><li>代理模式三要素：共同接口，真实对象、代理对象（装饰器模式）；</li><li>我们可以采用对象工程屏蔽代理类的生成；</li><li>静态代理的本质：不侵入代码的情况下，扩展原对象功能；</li></ul></li><li>Plugin实现采用Java动态代理方式，责任链模式实现；</li><li>基于注解或者路径的自动扫描；</li></ol><h3 id="Mybatis主要功能"><a href="#Mybatis主要功能" class="headerlink" title="Mybatis主要功能"></a>Mybatis主要功能</h3><ul><li>使用XML或Java API配置Mybatis</li><li>使用XML或注解配置SQL映射器（Mapper）</li><li>基于OGNL表达式的动态SQL构建</li><li>事务支持</li></ul><h5 id="Executor层次"><a href="#Executor层次" class="headerlink" title="Executor层次"></a>Executor层次</h5><p><img src="/images/posts/20180409/mybatis-executor-topo.jpg" alt=""></p><p>CachingExecutor 是正式Executor实现类的一个代理wrapper。</p><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>4个核心关键词:</p><ol><li>if </li><li>choise(when,otherwise)</li><li>trim（where,set）</li><li>foreach</li></ol><h5 id="缓存体系"><a href="#缓存体系" class="headerlink" title="缓存体系"></a>缓存体系</h5><ol><li><p>本地缓存；<br> 作用域：SqlSession内数据本地缓存；<br> 数据结构：PerpetualCache （HashMap）<br> 作用：利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。<br> 配置： localCacheScope=STATEMENT|SESSION设置作用域，建议使用STATEMENT，防止分布式环境下导致的脏读；</p></li><li><p>二级缓存<br> 作用域：namespace；SqlSession间数据缓存；<br> 默认底层缓存结构：LruCache包装的PerpetualCache<br> 选择：在分布式环境下，建议使用外部分布式缓存系统，而非Mybatis的本地缓存；</p></li></ol><h5 id="作用域：scope"><a href="#作用域：scope" class="headerlink" title="作用域：scope"></a>作用域：scope</h5><ul><li>SqlSessionFactory 建议应用级别；   </li><li>SqlSession 请求或方法级别（非线程安全）；</li><li>Mapper Instance 方法级别；</li></ul><h4 id="与Spring集成"><a href="#与Spring集成" class="headerlink" title="与Spring集成"></a>与Spring集成</h4><p>下回详解；</p><p>官方文档:<a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><p>版本说明：<a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><h4 id="工程示例："><a href="#工程示例：" class="headerlink" title="工程示例："></a>工程示例：</h4><p>大家可以基于测试工程自行联系相关设计理念以及工作原理：</p><p><a href="https://github.com/heartaway/mybatis-study-demo" target="_blank" rel="noopener">https://github.com/heartaway/mybatis-study-demo</a></p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档:"></a>参考文档:</h4><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html</a></p><p><a href="http://www.mybatis.org/spring/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/index.html</a></p><p><a href="https://blog.csdn.net/column/details/mybatis-principle.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/mybatis-principle.html</a></p><p>《iBatis实战》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Mybatis的本质：混合型Java对象持久化工具；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前置说明：&quot;&gt;&lt;a href=&quot;#前置说明：&quot; class=&quot;headerlink&quot; title=&quot;前置说明：&quot;&gt;&lt;/a&gt;前置说明：&lt;/h3&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云多机房部署网络架构</title>
    <link href="http://heartaway.cn/2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/"/>
    <id>http://heartaway.cn/2018/03/29/HighAvailability/2018-03-29-aliyun-mutil-region/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/posts/20180329/aliyun-mutil-region.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/posts/20180329/aliyun-mutil-region.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>POJO 对象setter 方法是否合适return &quot;this&quot;</title>
    <link href="http://heartaway.cn/2018/03/22/Java/2018-03-22-java-bean-setter-return/"/>
    <id>http://heartaway.cn/2018/03/22/Java/2018-03-22-java-bean-setter-return/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.803Z</updated>
    
    <content type="html"><![CDATA[<p>通常的POJO对象setter方法return 为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是面对对象属性填充时，一堆的set方法让代码看起来很臃肿，部分同学采用类build模式，对setter方法进行改造，改造后就可以使用链式处理简化属性设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流式编码风格如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Employee().setName(<span class="string">"Xin yuan"</span>).setHeight(<span class="number">178</span>);</span><br></pre></td></tr></table></figure><p>有人认为这让pojo方法设置变得更加便捷，有其使用之处，但是也有人认为<code>return this</code>打破了<a href="https://docstore.mik.ua/orelly/java-ent/jnut/ch06_02.htm" target="_blank" rel="noopener">Java Bean</a>的规约，破坏了每个函数单一职责的原则，也可能会破坏一些工具库的使用，或组织JVM做一些优化。而且在IDE中getter&amp;setter的自动生成内容中并没有“return this”。综其所述，setter方法“return this”并不建议。</p><p>当然还有其它选择方案：</p><p><strong>方法一：</strong></p><p>采用java内置语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Employee()</span><br><span class="line">&#123;&#123;</span><br><span class="line">    setName(<span class="string">"Jack Sparrow"</span>);</span><br><span class="line">    setId(<span class="number">1</span>);</span><br><span class="line">    setFoo(<span class="string">"bacon!"</span>);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>采用更加复杂的内部类builder模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(Strig name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>造者模式(Builder Pattern)：将一个<strong>复杂对象</strong>的<strong>构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。但是一般POJO 类都比较简单，非复杂对象，所以采用builder模式并不会让代码变得简洁，反而会显得更加臃肿。</p><p><strong>方法三：</strong></p><p>属性新增withXxx方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">withName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    setName(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="keyword">new</span> Employee().withName(<span class="string">"Xin yuan"</span>).withHeight(<span class="number">178</span>);</span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>不建议在POJO： Java Bean的setter方法中添加‘return this’，我们遵循Java规范，如果期望简化Java Bean的属性设置，可以采用with或build方法。</p><p><strong>参考：</strong></p><p><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Plain_old_Java_object</a></p><p><a href="https://stackoverflow.com/questions/1345001/is-it-bad-practice-to-make-a-setter-return-this" target="_blank" rel="noopener">https://stackoverflow.com/questions/1345001/is-it-bad-practice-to-make-a-setter-return-this</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常的POJO对象setter方法return 为void&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS应用自动发现服务</title>
    <link href="http://heartaway.cn/2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/"/>
    <id>http://heartaway.cn/2018/03/15/HighAvailability/2018-03-15-aws-application-discovery/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：AWS Application Discovery Service 收集并呈现数据，以使企业客户能了解其本地环境中服务器的配置、使用和行为。</p></blockquote><h2 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h2><h3 id="无代理自动发现"><a href="#无代理自动发现" class="headerlink" title="无代理自动发现"></a>无代理自动发现</h3><p>原理：基于 VMware vCenter Server 的环境的数据上报；</p><p>弊端：</p><ul><li>采用VMware 方式在国内并不常用；</li><li>采集到的数据有限，只是系统层面的静态数据与CPU、MEM的指标数据；</li></ul><h3 id="基于代理-Agent-的发现模式："><a href="#基于代理-Agent-的发现模式：" class="headerlink" title="基于代理(Agent)的发现模式："></a>基于代理(Agent)的发现模式：</h3><p>通过Agent可以采集更加丰富的数据集合，比如系统进程，系统间的网络连接；这里重点了解Agent模式。</p><h2 id="采集的数据："><a href="#采集的数据：" class="headerlink" title="采集的数据："></a>采集的数据：</h2><ul><li>静态配置数据： <ul><li>系统标识信息：主机名、IP地址、MAC地址、操作系统名称、操作系统版本号，cpuType；</li><li>运行中的进程数据；</li><li>系统间的网络调用（TCP/IP v4 和 v6）；<ul><li>sourceIP、sourceProcess、destinationIp、destinationPort、dstProcess，ipVersion；</li></ul></li></ul></li><li>性能指标数据：<ul><li>操作系统层面：<ul><li>参考之前的OS监控采集项；</li></ul></li><li>进程层面：<ul><li>%CPU</li><li>%MEM</li><li>%DISK  </li></ul></li><li>网络层面：<ul><li>待补充  </li></ul></li></ul></li></ul><h3 id="数据安全性："><a href="#数据安全性：" class="headerlink" title="数据安全性："></a>数据安全性：</h3><p>采用SSL协议进行数据传输；<br>数据存储采用AWS KMS静态加密；</p><h2 id="Agent模式下的自动发现"><a href="#Agent模式下的自动发现" class="headerlink" title="Agent模式下的自动发现"></a>Agent模式下的自动发现</h2><p>Agent启动时，自动注册到Arsenal中，并频繁对该服务执行 ping 操作以获取配置信息。<br><img src="https://gw.alipayobjects.com/zos/skylark/2a647cf5-d9b2-42f6-bcab-39a16b5ead2b/2018/png/179f1e58-a729-4ab0-8dea-b604269d0ad9.png" alt=""></p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>数据的收集需要自动显示开启；</p><h4 id="数据采集状态："><a href="#数据采集状态：" class="headerlink" title="数据采集状态："></a>数据采集状态：</h4><ul><li>STARTED – 收集工具已开始收集和发送数据到 Discovery Service。</li><li>START_SCHEDULED – 已计划数据收集开始时间。下次收集工具联系 AWS 时，它将开始将数据发送到 Discovery Service，并且收集状态将更改为 STARTED。</li><li>STOPPED – 收集工具已停止发送数据到 Discovery Service。</li><li>STOP_SCHEDULED – 已计划数据收集停止时间。下次收集工具联系 AWS 时，它将停止向 DiscoveryService 发送数据，并且收集状态将更改为 STOPPED。</li></ul><h3 id="组件分类"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类</h3><p>DiscoveryService识别组件后，通过TAG标签的方式，对资源进行标记；用户也可以同通过控制台进行自定义TAG标记；</p><p><strong>进程数据分类方法：</strong> 通过采集到的进程数据，可以推测出aws判断进程属于哪一类基础设施应该是通过进程名称与commondLine来判断的。</p><h3 id="Agent模式自动发现不足："><a href="#Agent模式自动发现不足：" class="headerlink" title="Agent模式自动发现不足："></a>Agent模式自动发现不足：</h3><ul><li>不能保存资源组件快照或跟踪资源变更；</li><li>收集的性能数据不是通用的运行状况监控解决方案；</li></ul><h2 id="自动发现API"><a href="#自动发现API" class="headerlink" title="自动发现API"></a>自动发现API</h2><ol><li>Agent相关API<ul><li>Agent的启动、停止数据采集操作；</li><li>Agent的描述信息；</li><li>Agent的运行状态；</li></ul></li><li>配置相关API<ul><li>server、application、process、connection 的指标查询、过滤与配置；</li></ul></li><li>标签相关API<ul><li>TAG的增删改查； </li></ul></li></ol><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>产品链接：<a href="https://aws.amazon.com/cn/documentation/application-discovery/" target="_blank" rel="noopener">https://aws.amazon.com/cn/documentation/application-discovery/</a></p><p>API地址：<a href="https://docs.aws.amazon.com/zh_cn/application-discovery/latest/APIReference/discovery-api.pdf#discovery-api-queries" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/application-discovery/latest/APIReference/discovery-api.pdf#discovery-api-queries</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义：AWS Application Discovery Service 收集并呈现数据，以使企业客户能了解其本地环境中服务器的配置、使用和行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工作模式：&quot;&gt;&lt;a href=&quot;#工作模式：&quot; 
      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>《基于中间件的基础设施自动发现》</title>
    <link href="http://heartaway.cn/2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/"/>
    <id>http://heartaway.cn/2018/03/14/Paper/2018-03-14-infrastructure-auto-discovery/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>论文地址：<br><a href="https://patents.google.com/patent/US7912749B2/en" target="_blank" rel="noopener">https://patents.google.com/patent/US7912749B2/en</a></p></blockquote><h4 id="论文主体内容："><a href="#论文主体内容：" class="headerlink" title="论文主体内容："></a>论文主体内容：</h4><p>通过分析中间件网络数据，建立信息模型；从网络数据中判断组件性能阈值、基础设施组件之间的依赖关系以及业务流程与基础设施的映射关系；</p><p>建议采用分层（图层）模型；（比如Dynatrace中的5层模型）</p><h4 id="架构基线特征"><a href="#架构基线特征" class="headerlink" title="架构基线特征"></a>架构基线特征</h4><ol><li>基于对象的；<ul><li>对象也就是架构实体或者信息模型的组合；</li></ul></li><li>策略驱动的；</li><li>安全的；</li><li>自我管理的；</li><li>自我描述；<ul><li>自我描述有利于新组件加入后的关系挖掘，而不依赖人工的定义与配置；</li></ul></li><li>能够提供信息透明度；</li></ol><p>架构基线是简化系统主要部分的识别和结构化组织的催化剂。</p><p>架构发现本质上是对信息的识别和分类过程，识别和分类过程最好与任何特定的知识库，上下文，协议或平台 无关。</p><h4 id="模型划分"><a href="#模型划分" class="headerlink" title="模型划分"></a>模型划分</h4><p>可以提供元模型来定义用于在业务管理环境中指定模型的语言。元模型可以具有描述动态语义的能力。元模型图层中的一些对象示例包括类，属性，操作，关联，组件等</p><p>可以提根据核心模型来定义抽象类的集合，核心模型是分析师确定如何扩展核心模型以创建领域模型的起点。抽象类的一些例子，比如交易、客户等；</p><p>按照信息的抽象程度划分：<br>元模型 &gt; 信息模型 &gt; 核心模型 &gt; 领域模型；</p><p>信息模型和核心模型通常更稳定，这两个模型是定义域模型的来源，这些模型也提供了跨不同领域的元素视图，可发现有价值的业务相关数据。</p><h4 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h4><p>从多个数据源创建有用的信息非常关键。但是，业务相关性需要适当、一致且相关的信息，而不是分散的数据。<strong>信息透明度服务</strong>可以将离散的实时或历史数据源分离出来，作为有用的信息源。该过程涉及通过使用明确定义的‘聚合’和‘转换规则’以及信息模型作为信息交换的基础来聚合和转换数据源。</p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>软件模块存储在数据库中。库中的各个模块称为模式，而库本身称为模式目录。模式可以根据其规模和抽象进一步分类为</p><ul><li>架构模式</li><li>设计模式</li><li>语言模式</li></ul><p>架构模式：表达了软件系统的基本结构组织模式。它提供了一组预定义的子系统，指定了他们的职责，并包括组织它们之间关系的规则和准则。</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>基础设施的自动发现，可衍生出通过诊断分析进行故障定位或影响分析等功能。可以提供自我修复程序，并且可以通过动态资源管理和嵌入式服务意识来解决基础结构优化问题。比如Dynatrace的故障定位；</p><h4 id="扩展产品了解："><a href="#扩展产品了解：" class="headerlink" title="扩展产品了解："></a>扩展产品了解：</h4><p><a href="https://www.dynatrace.com/capabilities/application-topology-discovery/smartscape/" target="_blank" rel="noopener">dynatrace</a><br><a href="https://docs.aws.amazon.com/application-discovery/latest/APIReference/discovery-api-queries.html" target="_blank" rel="noopener">amazon-application-discovery</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;论文地址：&lt;br&gt;&lt;a href=&quot;https://patents.google.com/patent/US7912749B2/en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://patents.google.co
      
    
    </summary>
    
      <category term="Paper" scheme="http://heartaway.cn/categories/Paper/"/>
    
    
  </entry>
  
  <entry>
    <title>自用型监控系统方案</title>
    <link href="http://heartaway.cn/2018/03/14/HighAvailability/2018-03-14-monitor-system/"/>
    <id>http://heartaway.cn/2018/03/14/HighAvailability/2018-03-14-monitor-system/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、监控系统整体概述"><a href="#一、监控系统整体概述" class="headerlink" title="一、监控系统整体概述"></a>一、监控系统整体概述</h2><blockquote><p>系统背景：<br>在当前项目中，当我们对特定流程注入故障后，如何评估故障的效果以及系统应对故障的表现？传统方式是用户需要登录线上机器或者各种监控系统去查看具体的指标信息，然后通过人工判断，来判断故障的影响范围，产品使用上不够自动化，且没有闭环。我们期望引入监控系统，把之前需要人来做的事情交给系统来做，为故障注入后的影响进行量化分析。</p></blockquote><p>整个监控系统对数据处理的四个步骤：<br><img src="https://gw.alicdn.com/tfscom/TB1nArGof2H8KJjy0FcXXaDlFXa.png" alt=""></p><p>系统架构图：<br><img src="https://gw.alipayobjects.com/zos/skylark/155aa3d2-3444-4bd5-9588-ae9dfa39a0b2/2018/png/c59df181-ff42-4f6d-be01-3314a92f5e03.png" alt=""></p><p><strong>组件说明：</strong></p><p><strong>API Gateway</strong>：agent 与 Server 所有交互都会通过API Gateway，统一由API Gateway进行管控，为整个MK提供一致的数据门面接口，实现之前约定的数据总线的方案。</p><p><strong>Data Collector</strong>：为数据采集器，接受来自客户端推送上来的监控数据 或 拉去外部监控数据；</p><p><strong>Data Transfer</strong>： 数据转换器，把采集到的非一致性架构的数据转换为统一的数据模型；</p><p><strong>Config</strong>： 此模块主要提供一些Agent、Collector、Analyzer需要的一些元数据；</p><p><strong>Schedule</strong>： 依赖Schedule，主要是期望能把周期性数据拉取采集任务转换为 schedule任务，降低重复编写分布式任务调度的复杂度，其次，借助schedule实现周期任务分发的负载均衡；</p><p><strong>Diamond</strong>：采用Diamond作为数据采集规则的动态配置中心。</p><p><strong>MQ</strong>： 把数据采集器采集到的数据转换为统一的消息格式，解耦数据采集与数据分析对数据使用差异性；其次，当数据分析器Data Analyzer集群宕机或处理性能下降时，MQ能起到数据缓存池的作用，一定程度上防止采集上来的数据未能处理而导致的数据丢失。</p><p><strong>Data Analyzer</strong>： 数据分析器，对收集到的监控数据进行一定程度上的计算转换，并根据关注点规则，进行事件监控处理；</p><p>自研监控系统，需要面临一系列的抉择：<br><img src="https://gw.alipayobjects.com/zos/skylark/03a23023-065f-4333-a11a-86afff4f770f/2018/png/f2c31281-de0d-49e7-830d-49c2474b6ddb.png" alt=""></p><h2 id="二、行业监控系统架构："><a href="#二、行业监控系统架构：" class="headerlink" title="二、行业监控系统架构："></a>二、行业监控系统架构：</h2><h4 id="OneAPM"><a href="#OneAPM" class="headerlink" title="OneAPM"></a>OneAPM</h4><p><img src="https://gw.alipayobjects.com/zos/skylark/1c75fc4a-de85-408c-a859-d943a7bccec3/2018/png/2e24513f-0c46-4f25-acd2-0aa293962b01.png" alt=""></p><h4 id="CAT"><a href="#CAT" class="headerlink" title="CAT"></a>CAT</h4><p><img src="https://gw.alipayobjects.com/zos/skylark/33fb5a1d-2b4a-45dd-a94b-f0b660b47339/2018/png/e956684e-e5ce-4e10-b424-6d51b2949502.png" alt=""></p><p>参考：<a href="https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html" target="_blank" rel="noopener">https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html</a></p><h2 id="三、数据采集方案"><a href="#三、数据采集方案" class="headerlink" title="三、数据采集方案"></a>三、数据采集方案</h2><p>数据采集面的的挑战：</p><ul><li>数据源多种多样 </li><li>数据量大 </li><li>变化快 </li><li>如何保证数据采集的可靠性的性能 </li><li>如何避免重复数据 </li><li>如何保证数据的质量</li></ul><h3 id="3-1-采集方案"><a href="#3-1-采集方案" class="headerlink" title="3.1 采集方案"></a>3.1 采集方案</h3><p>目前常用的数据采集方式有两种：</p><ol><li>主动监控（客户端推模式-Push）；<ul><li>优势：<ul><li>实时性好；</li><li>对服务端的压力相对较小；</li><li>插件化支持用户自定义采集脚本；</li><li>监控自动发现；</li></ul></li><li>劣势：<ul><li>数据聚合与异常处理复杂；</li></ul></li></ul></li><li>被动监控（服务端拉模式-Pull）；<ul><li>优势：<ul><li>数据处理方便；</li><li>数据准确性、完备性更好；</li><li>Edas已经存在根据staragent进行数据拉去的实践方案；</li></ul></li><li>劣势：<ul><li>集群规模大时，服务器压力大，任务分发易积压，分发线程忙，带来一定数据延迟；</li><li>数据拉取时服务隔离难(twitter)；</li><li>无法区分服务失效和代理失效(twitter)；</li></ul></li></ul></li></ol><p>现有监控系统采集方案：</p><table><thead><tr><th>系统</th><th>采集方式</th><th>备注</th></tr></thead><tbody><tr><td>AliMonitor</td><td>Push</td><td></td></tr><tr><td>Ali-Sunfire</td><td>Pull</td><td></td></tr><tr><td>TLog</td><td>Pull</td><td></td></tr><tr><td>aliyun-sls-ilogtail</td><td>Push</td><td></td></tr><tr><td>Zabbix</td><td>push+pull</td><td></td></tr><tr><td>Open-falcon</td><td>Push</td><td></td></tr><tr><td>OneAPM</td><td>Push</td><td></td></tr><tr><td>Cacti</td><td>Pull</td></tr></tbody></table><p><strong>主动监控示意图（Push）：</strong><br><img src="https://gw.alicdn.com/tfscom/TB1MJZKonvI8KJjSspjXXcgjXXa.png" alt=""></p><p>服务端提供一个接受数据请求的域名地址，客户端把数据推送到服务端，服务端负责数据解析与存储；</p><p><strong>被动监控示意图（Pull）：</strong><br><img src="https://gw.alicdn.com/tfscom/TB19cEKonvI8KJjSspjXXcgjXXa.png" alt=""></p><p><strong>Agent一般具备的功能:</strong></p><ol><li>LogFinder: 能够根据请求的时间区间返回区间内的监控数据；</li><li>LogQuery: 能够根据偏移量定位到日志位置；</li><li>LogCompression： 支持日志数据压缩；</li></ol><p>此部分可以参考LogAgent的实现逻辑。</p><p><strong>我们的需求：</strong></p><ul><li>轻量级；</li><li>可扩展；</li><li>支持系统监控（OS）、业务监控（Agent）</li><li>支持Agent自动注册以及静态数据主动上报；</li><li>监控项受控开启与关闭，具备开关功能（非常态化挂载）；</li><li>需要具备数据堆积能力；</li><li>需要具备多数据源扩展能力；</li></ul><p><strong>方案结论：</strong></p><blockquote><p>客户端通过写本地磁盘日志的方式写指标数据，服务端通过 主动拉的方式到客户端上进行拉去数据；</p></blockquote><h3 id="3-2-分布式任务调度"><a href="#3-2-分布式任务调度" class="headerlink" title="3.2 分布式任务调度"></a>3.2 分布式任务调度</h3><p>我们采用服务端拉去日志的方式，所以需要一套对多个节点进行周期性调度拉取日志的框架。目前分布式定时调度服务阿里集团内有scheduleX以及开源的Quartz，考虑到服务单独输出减少依赖组件的需求，对Quartz的分布式持久化任务整合工作量评估后， 我们选择了使用quartz的方式。目前spring有对quartz进行整合，简化对quartz的使用。<br>不仅在监控数据采集上需要调度，在演练定时触发、演练监控定时开启等场景下都需要分布式任务调度服务，所以提供一套通用型的与业务无关的分布式调度服务API很有必要。<br>基于spring-quartz进行接口封装出统一的分布式调度服务接口服务SchedulerService， 这部分是单独的一个模块。</p><h3 id="3-3-数据Metric指标"><a href="#3-3-数据Metric指标" class="headerlink" title="3.3 数据Metric指标"></a>3.3 数据Metric指标</h3><p>客户端打印的日志非Metric格式，通过日志数据采集上来的数据需要通过转换器Transfer进行转换为统一的Metric格式；</p><p>当前监控系统采集的数据指标分为两类：</p><ul><li>系统OS监控指标；</li><li>应用性能指标；</li></ul><p>系统监控指标Metric含义：</p><table><thead><tr><th>category</th><th>Metric</th><th>Type</th><th>Tag</th><th>Description</th></tr></thead><tbody><tr><td>cpu</td><td>system.cpu.idle</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.system</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.user</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.cpu.util</td><td>GAUGE</td><td>host</td><td>cpu使用率</td></tr><tr><td>load</td><td>system.load.1min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.load.5min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.load.15min</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>mem</td><td>system.mem.buffers</td><td>GAUGE</td><td>host</td><td>当前系统的buffer cache的内存数(单位kb)</td></tr><tr><td></td><td>system.mem.cached</td><td>GAUGE</td><td>host</td><td>当前系统的pagecache里的内存数(单位kb)</td></tr><tr><td></td><td>system.mem.free</td><td>GAUGE</td><td>host</td><td>当前系统的空闲内存(单位kb)</td></tr><tr><td></td><td>system.mem.total</td><td>GAUGE</td><td>host</td><td>当前系统的总内存(单位kb)</td></tr><tr><td></td><td>system.mem.used</td><td>GAUGE</td><td>host</td><td>当前系统的已经使用的内存(单位kb)</td></tr><tr><td></td><td>system.mem.util</td><td>GAUGE</td><td>host</td><td>当前系统的已经使用的内存占比</td></tr><tr><td>disk.partition</td><td>system.disk.partition.total</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘总字节数</td></tr><tr><td></td><td>system.disk.partition.free</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘空闲字节数</td></tr><tr><td></td><td>system.disk.partition.used</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘使用字节数</td></tr><tr><td></td><td>system.disk.partition.used_ratio</td><td>GAUGE</td><td>host、device</td><td>当前系统的磁盘使用率</td></tr><tr><td>disk.io</td><td>system.disk.io.read_merge</td><td>GAUGE</td><td>host、device</td><td>每秒合并读完成次数</td></tr><tr><td></td><td>system.disk.io.write_merge</td><td>GAUGE</td><td>host、device</td><td>每秒合并写完成次数</td></tr><tr><td></td><td>system.disk.io.read</td><td>GAUGE</td><td>host、device</td><td>每秒读完成次</td></tr><tr><td></td><td>system.disk.io.write</td><td>GAUGE</td><td>host、device</td><td>每秒写完成次数</td></tr><tr><td></td><td>system.disk.io.util</td><td>GAUGE</td><td>host、device</td><td>io占比</td></tr><tr><td>processs</td><td>system.process.switches</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.process.total</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>traffic</td><td>system.net.in.bytes</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.out.bytes</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.in.packets</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.out.packets</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.packet.errs</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td></td><td>system.net.packet.dropped</td><td>GAUGE</td><td>host</td><td></td></tr><tr><td>tcp</td><td>system.tcp.active_opens</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒主动建连的连接数</td></tr><tr><td></td><td>system.tcp.passive_opens</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒被动建连的连接数</td></tr><tr><td></td><td>system.tcp.current_estab</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒处于ESTABLISHED和CLOSE-WAIT状态的TCP连接数</td></tr><tr><td></td><td>system.tcp.estab_resets</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒reset次数</td></tr><tr><td></td><td>system.tcp.out_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒发送的tcp包数量</td></tr><tr><td></td><td>system.tcp.in_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒接收到的tcp包数量</td></tr><tr><td></td><td>system.tcp.attempt_fails</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒建连失败次数</td></tr><tr><td></td><td>system.tcp.retran_segs</td><td>GAUGE</td><td>host</td><td>最近1min平均每秒重传的包数量</td></tr><tr><td>udp</td><td>system.udp.in_dgm</td><td>GAUGE</td><td>host</td><td>收到的udp报数目</td></tr><tr><td></td><td>system.udp.out_dgm</td><td>GAUGE</td><td>host</td><td>发送的udp报数目</td></tr><tr><td></td><td>system.udp.noport</td><td>GAUGE</td><td>host</td><td>udp协议层接收到目的地址或目的端口不存在的数据包</td></tr><tr><td></td><td>system.udp.in_errs</td><td>GAUGE</td><td>host</td><td>udp层接收到的无效数据包的个数</td></tr></tbody></table><p>应用性能监控指标Metric含义：</p><table><thead><tr><th>category</th><th>Metric</th><th>Type</th><th>Tag</th><th>Description</th></tr></thead><tbody><tr><td>servlet</td><td>app.servlet.request.count</td><td>COUNTER</td><td>host、transaction，device</td><td>时间区间内，请求总次数</td></tr><tr><td></td><td>app.servlet.request.durations</td><td>COUNTER</td><td>host、transaction，device</td><td>时间区间内，请求总时间</td></tr><tr><td></td><td>app.servlet.request.rt.mean</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的平均rt</td></tr><tr><td></td><td>app.servlet.request.rt.max</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的最大rt</td></tr><tr><td></td><td>app.servlet.request.rt.min</td><td>GAUGE</td><td>host、transaction，device</td><td>请求的最小rt</td></tr><tr><td></td><td>app.servlet.request.error_count</td><td>COUNTER</td><td>host、transaction，device</td></tr></tbody></table><p>其中device存储agentId，transaction存储请求名称；</p><p><strong>Metric命名规范</strong></p><p>key和tag只支持：[a-z][A-Z][0-9][-_./], 不能有空格, 大小写敏感, key原则上不包含大写。<br>格式为xxx.category[.sub_category]*, category和sub_category里面如果有多个单词，用下划线’_’连接， 不要用’.’连接。<br>需要动态聚合的维度， 放在tag里面， 同时在tagKey也在key中体现。 不需要聚合的维度， 放在key里面。</p><h3 id="3-4-数据转换transfer"><a href="#3-4-数据转换transfer" class="headerlink" title="3.4 数据转换transfer"></a>3.4 数据转换transfer</h3><p>针对不同类型的类型，采用工厂方法提供自适配的解析器。针对system系统监控，继续拆分为领域适配器，比如针对CPU域、mem域提供不同的处理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetricTransfer</span> <span class="keyword">extends</span> <span class="title">Transfer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * format  data to metric list</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;MetricObject&gt; <span class="title">format</span><span class="params">(MetricMeta metricMeta, String sourceData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、数据分析方案"><a href="#四、数据分析方案" class="headerlink" title="四、数据分析方案"></a>四、数据分析方案</h2><h3 id="4-1-分析方案："><a href="#4-1-分析方案：" class="headerlink" title="4.1 分析方案："></a>4.1 分析方案：</h3><p>现有的监控系统数据分析模块主要分为两类：</p><ul><li>批处理模型；</li><li>流处理模型（Spark Streaming、Storm、Flink）；<br><img src="https://gw.alicdn.com/tfscom/TB1kLTkodbJ8KJjy1zjXXaqapXa.png" alt=""></li></ul><p>结论：考虑到我们要求部署节点少、拓扑简单以及本期研发周期时间紧，我们采暂且不采用流式处理方案，数据获取到后，直接给到后端进行分析处理；</p><h3 id="4-2-监控点分析："><a href="#4-2-监控点分析：" class="headerlink" title="4.2 监控点分析："></a>4.2 监控点分析：</h3><p>用户可以通过配置监控指标，来对关心的系统指标进行阈值判断，比如选择一批机器，关注CPU利用率超过90%，那么监控系统就需要把这批机器在演练期间CPU利用率超过90%的指标都找出来，并转换为Event事件。这点类似于监控系统中的报警系统模型。</p><p>数据分析器中处理监控指标的流程如下：<br><img src="https://gw.alicdn.com/tfscom/TB1sQtXov2H8KJjy1zkXXXr7pXa.png" alt=""></p><p><strong>流程分析：</strong></p><p>每一个Data Analyzer模块中都会包含一个Rule Set集合，Rule Set集合存放着生效后的关注点规则，在监控数据到达分析引擎中后，分析引擎通过filter机制，判断是否命中规则，如果命中规则，则根据规则与数据形成一条Event 事件数据，用于描述某次监控指标命中了监控指标阈值。后续复盘时，可以对Event 库中的指标事件进行聚合分析，形成需要的结论报告。</p><p><strong>规则注册与更新机制：</strong></p><p>关注点规则为内存数据集，当用户在界面是哪个新增了规则或者变更了规则的时候，都需要对内存中维护的这份规则集合进行修改操作。</p><p><strong>规则存储：</strong></p><p>当前规则为内存存储方式，在系统启动时从数据库中进行load全量有效关注点指标；带来的影响每一台机器都需要在内存中维护一份数据，如果某台机器数据更新失败，会带来数据的一致性问题，后续会考虑这部分数据移动到公共的外部快速存储设备中，比如Redis中。</p><p><strong>数据模型：</strong></p><p>我们把用户配置的关注点在系统指标上的阈值简称为“告警”，告警条件的判断以及存储流程中，主要涉及的领域模型为：Hosts、Metrics、triggers、functions、items、events、actions；</p><ul><li>hosts： 存储被监控的主机信息；</li><li>metrics：存储监控到的数据指标；</li><li>items： 存储支持的监控项配置信息。</li><li>triggers：存储触发器的相关信息；</li><li>events： 存储事件数据；</li><li>actions：存储当触发器触发时，需要采取的动作（不再本期研发范围内）；</li></ul><p><strong>触发器计算模型：</strong></p><p>我们的需求是：监控某个关注对象下的某类监控指标下的特定聚合函数值 是否超过(也可能是其它运算符)某个固定阈值；那么我们把需求中拆解出几个对象出来，分别是：监控对象、监控指标、聚合函数、运算符、固定阈值，我们通过这几个对象的组合，可以对我们的意图进行对象化描述，表达式函数格式如下：<br>{<host>:<metric>.<function>(<parameter>)}<operator><constant></constant></operator></parameter></function></metric></host></p><p><strong>计算模型举例：</strong></p><p>关注点描述为： 11.23.45.67  这台机器的 最近十分钟 load 指标 大于2   ， 那么 表达式函数为：<br>{11.23.45.67:system.cpu.load.last(10m)}  &gt; 2</p><p><strong>触发器中的聚合函数：</strong></p><ul><li>max    最大值    </li><li>min    最小值    </li><li>avg    平均值    </li></ul><p><strong>数据模型：</strong></p><p>在监控指标分析域中涉及到的领域模型对象为：</p><ul><li>items</li><li>triggers</li><li>events</li><li>actions</li></ul><p>数据模型以及关联关系如下：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/5ec4918f-2d14-4c92-a637-cc5457c828a8/2018/png/f1dffd57-4a0e-4f98-a295-b39db045a6e2.png" alt=""></p><p>资源组与触发器为1：n的关系，监控项与触发器为1:1关系，触发器与事件为1:1关系；</p><h2 id="五、数据存储方案"><a href="#五、数据存储方案" class="headerlink" title="五、数据存储方案"></a>五、数据存储方案</h2><h3 id="5-1-数据分类："><a href="#5-1-数据分类：" class="headerlink" title="5.1 数据分类："></a>5.1 数据分类：</h3><p>我们把数据类型分为五类：</p><ol><li>Metric指标数据（分为服务器和容器）<ul><li>定义：metric描述一个指标在某个时间点的值是多少，可以使用tag来进行元数据标记划分；比如OS的系统监控指标；</li></ul></li><li>Event  事件数据（包括：系统、Docker数据采集）<ul><li>定义：event记录系统在特定时刻下发生的具体信息，比如规则下发、故障启停、MkKit安装与卸载、Metric触发规则配置产生的事件等；</li></ul></li><li>Log 运行时日志数据<ul><li>定义：event数据可以根据业务需求打上tag便于分析时筛选，统计，text中记录事件丰富上下文信</li></ul></li><li>Heartbeat 心跳数据<ul><li>定义：定期执行的状态汇报，比如agent的心跳信息，进程的状态等；</li></ul></li><li>Trace 数据<ul><li>定义：记录故障注入请求trace的信息；</li></ul></li></ol><h3 id="5-2-数据存储方案："><a href="#5-2-数据存储方案：" class="headerlink" title="5.2 数据存储方案："></a>5.2 数据存储方案：</h3><p>监控数据是时间序列的数据，由于监控的对象数量巨大，所以存储的介质需要支持高的写入吞吐量，良好的扩充性，读取最近的数据速度要快，支持多数据类型，支持多种扫描方式等特点，目前主要的存储方式有SQL和NoSQL两种。通过对比，NoSQL在数据存储吞吐量，扩充性等方面具有优势，SQL在数据类型的支持，扫描多样性具有优势。</p><p>总而言之，监控数据更适合采用时序性存储媒介，比如OpenTSDB、HiTSDB等；考虑到种种原因，我们临时使用 Mysql，Mysql 能在一定程度上简化我们架构，让业务跑的更快一些。</p><p>不压缩的情况下：100台机器同时采集长达30天，占用空间49G；（单条1kb计算，5秒存储一次）。</p><h4 id="5-3-行业常用存储方案"><a href="#5-3-行业常用存储方案" class="headerlink" title="5.3 行业常用存储方案"></a>5.3 行业常用存储方案</h4><p>Cassandra<br>InfluxDB<br>MongoDB<br>OpenTSDB<br>KairosDB<br>HBase</p><h3 id="5-4-监控指标存储规范"><a href="#5-4-监控指标存储规范" class="headerlink" title="5.4 监控指标存储规范"></a>5.4 监控指标存储规范</h3><p>遵循metric规范；<br><a href="https://gw.alipayobjects.com/zos/skylark/02b7d493-9e02-490d-8f0c-243309a66ad5/2018/png/edcf8730-7203-48da-961b-1858d60a372c.png" target="_blank" rel="noopener"></a></p><p>一个metric由两部分组成，metric key和metric tag：</p><ol><li>metric key：它是用英文点号分隔的字符串，用来表征这个指标的含义</li><li>metric tag：它定义了这个指标的不同切分维度，可以是单个，也可以是多个<ul><li>tag key: 用于描述维度的名称</li><li>tag value: 用于描述维度的值</li></ul></li></ol><p>Metric的数据格式如下：<br><img src="https://gw.alicdn.com/tfscom/TB1Ey9PeAfb_uJkSne1XXbE4XXa.png" alt=""></p><ul><li>metric key：存储当前指标的key</li><li>metric tag：存储当前指标的tag</li><li>metric value：存储当前指标的值</li><li>timestamp：存储当前的时间戳</li><li>metadata：存储当前指标的一些元信息</li></ul><p>在Metric规范下，针对云上的多租户设计，我们增加了两个字段namespace、scope，用来对metric进行分类，一个是从用户角度进行划分，一个是从功能集角度划分，形成 MetricObject 对象属性描述如下：</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>是否必填</th></tr></thead><tbody><tr><td>namespace</td><td>​String</td><td>命名空间，用于区分不同租户，存储userId</td><td>必填</td></tr><tr><td>scope</td><td>String</td><td>范围，比如system、jvm、hsf、servlet等</td><td>必填</td></tr><tr><td>metric</td><td>String</td><td>指标Key</td><td>必填</td></tr><tr><td>metricType</td><td>MetricType</td><td>指标类型</td><td>必填</td></tr><tr><td>tags</td><td>map&lt;string,string&gt;</td><td>附加信息，当前只支持内置tag，不支持用户自定义tag（原因是采用mysql而不是nosql）</td><td>必填，遵循OpenTSDB规范，至少要求有一个Tag</td></tr><tr><td>timestamp</td><td>Long</td><td>时间戳</td><td>必填</td></tr><tr><td>value</td><td>Double</td><td>指标值</td><td>必填</td></tr></tbody></table><p>举例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"namespace"</span>: <span class="string">"1114805108664848"</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"system"</span>,</span><br><span class="line">    <span class="attr">"metric"</span>: <span class="string">"sys.memory.total"</span>,</span><br><span class="line">    <span class="attr">"metricType"</span>: <span class="string">"COUNTER"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: &#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1470298287916</span>,</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">1167126</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetricType 指标类型(参考：<a href="http://metrics.dropwizard.io/4.0.0/getting-started.html)：" target="_blank" rel="noopener">http://metrics.dropwizard.io/4.0.0/getting-started.html)：</a></p><ul><li>COUNTER: 用于累加型的数据，反映的是数据随着时间单调递增的关系，如Tomcat接受到的HTTP请求的总次数</li><li>GAUGE: 用于瞬态数据，表示指标在当前时间点的瞬时情况，反映的是数据随着时间上下波动的关系，如系统的load，JVM的内存使用率</li><li>METER：用于对变化速率型指标进行度量，反映的是数据随时间的增长快慢关系，如某个接口的QPS</li><li>HISTOGRAM：用于对分布型数据进行度量，反映的是数据随时间的统计学分布关系</li></ul><p><strong>Tags 标签存储方案：</strong></p><p>由于生产环境中存储方案当前技术选型为使用Mysql存储Metric数据，Mysql不支持schemaless结构，所以无法做到Tags的key-value的动态扩展，我们使用Mysql的固定列模式，通过提供内置tag来达到相同的目的；Tags中的key为Mysql中的列名称，字段值为tags的value；</p><p>内置的tag字段为：</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>举例</th></tr></thead><tbody><tr><td>tag_host</td><td>主机信息</td><td>127.0.0.1</td></tr><tr><td>tag_device</td><td>设备信息，比如磁盘盘符</td><td>/usr/dev1</td></tr><tr><td>tag_trace</td><td>请求链路标识</td><td>tid</td></tr><tr><td>tag_transaction</td><td>请求事务标识</td><td>createOrder</td></tr></tbody></table><p>Mysql数据模型如下：<br><img src="https://gw.alipayobjects.com/zos/skylark/1936fc76-7df1-4485-aed2-00eda58b2903/2018/png/0a5f4d67-77ca-4030-a095-919918a948c6.png" alt=""></p><h2 id="六、监控数据查询方案"><a href="#六、监控数据查询方案" class="headerlink" title="六、监控数据查询方案"></a>六、监控数据查询方案</h2><h3 id="6-1-数据查询分类："><a href="#6-1-数据查询分类：" class="headerlink" title="6.1 数据查询分类："></a>6.1 数据查询分类：</h3><p>用户对时序数据的查询场景多种多样，总的来说时序数据的查询分为两种：</p><ul><li>原始数据的查询（比如业务监控数据）</li><li>时序数据聚合运算的查询（比如系统监控数据）</li></ul><p><strong>某监控 指标展示计算解析：</strong></p><p>监控中用户日志的计算逻辑是由用户自定义的计算方式（因为是业务监控），主要由求行数、对列值求和、对列值求平均、对列值求最大值、对列值求最小值；其大盘数据展示中并未对数据做再次聚合处理，展示的是采集的原始数据（原始数据分为秒级和分钟级），如果需要做计算，是通过前端的聚合函数进行的业务处理。<br><img src="https://gw.alipayobjects.com/zos/skylark/ed6a20ea-c9d8-4ef7-be45-ab972ac211e2/2018/png/a9b705d7-cc05-43f2-8a3a-dc822ddfd7b2.png" alt=""></p><h3 id="6-2-数据聚合分类："><a href="#6-2-数据聚合分类：" class="headerlink" title="6.2 数据聚合分类："></a>6.2 数据聚合分类：</h3><p>在监控数据使用过程中，我们往往会针对单台机器进行分析或者多台(集群)机器进行分析，每一种分析中又会加入时间的概念，比如是采用原始采集的数据点还是进行多个点的合并形成一个新点。所以我们把数据分析计算分为两个维度，一个是‘机器’维度(空间聚合)，一个时间维度(时间聚合)；在Metric模型中我们通过两个方法分别定义，一个是Aggregator，一个是Down sample。</p><p>Aggregator：用来描述同一个时间点下，数据集合的聚合方式；比如一个集群的CPU使用率，在某一时刻下集群中所有机器的CPU使用率的平均值；需要注意的是，当随着集群规模越来越大的时候，我们也是需要从这个数据集合中进行采样，然后再做聚合计算。</p><p>Down sample：用来描述在多个时间点下，数据聚合的聚合方式；比如一台机器每隔5秒采集一个CPU使用率，最终数据展示时，需要按照1分钟一个点的方式进行展示，那么这个数据集合中在不丢数据的情况下会有12个数据项，我们需要将这12个数据项聚合为一个数据项。</p><h3 id="6-3-数据聚合方式："><a href="#6-3-数据聚合方式：" class="headerlink" title="6.3 数据聚合方式："></a>6.3 数据聚合方式：</h3><p>数据的聚合方式一般可以分为‘预聚合’和‘后聚合’；提前聚合可能引起数据膨胀但可以加速访问请求时的响应速度，访问时聚合虽然降低了一定的存储成本但可能会加慢响应速度。<br><img src="https://gw.alipayobjects.com/zos/skylark/84e8e67c-e0a8-4a9d-a748-0e5383cc08ee/2018/png/4afc4ec7-84d4-42e9-b3b7-d17cdc57eae3.png" alt=""></p><p>大部分监控系统一般都支持预聚合(归档)数据处理（比如zabbix的数据归档表trends）；由于一般原始数据采集周期比较小，比如分钟级，那么展示长时间的数据的视图需要扫描过多数据，展示比较慢，如果将数据归档成按小时，和按天的数据，那么展示时间跨度大的数据的效率大大提高；基于Metric的数据预处理，一般采用流式预聚合引擎，对数据进行降精度处理，比如阿里的DBPass产品，会对指标数据事先降时间精度，分为6个精度：1秒、5秒、15秒、1分钟、5分钟、15分钟。</p><p>基于Metric规范的时序数据库中，OpenTSDB支持预聚合和后聚合，Aliyun的HiTSDB优先采用后聚合，其通过采用倒排索引+前缀索引来加速数据查询。</p><h3 id="6-4-数据计算算法："><a href="#6-4-数据计算算法：" class="headerlink" title="6.4 数据计算算法："></a>6.4 数据计算算法：</h3><p>在客户端数据采集计算的时候，通常也会遇到数据聚合的需求，主要是基于单机维度的数据聚合，比如我们期望采集固定周期周期范围内的数据，假如每个周期范围内存在多个数据点（D1，D2，D3），我们要怎样计算才能得到一个点的数据呢？</p><p>通常会有以下计算方式：</p><ul><li>随机采样；</li><li>滑动窗口；</li><li>滑动时间窗口；</li><li>指数衰减随机采样（EWMA）；</li></ul><p><img src="https://gw.alipayobjects.com/zos/skylark/b070bc51-d1db-46b0-9fb9-19461a360ecc/2018/png/ebfc264d-1e49-4ae2-b771-63e88e39e63d.png" alt=""></p><p><img src="https://gw.alipayobjects.com/zos/skylark/5d1585f9-8351-4eec-afee-d2b74531c268/2018/png/490d585e-700e-44f5-978c-d30a772d9e80.png" alt=""></p><p>EWMA的Java实现方式可以参考：<a href="https://github.com/heartaway/metrics/blob/4.1-development/metrics-core/src/main/java/com/codahale/metrics/EWMA.java" target="_blank" rel="noopener">EWMA.java</a><br>EWMA算法 维护一个固定大小的集合，并认为该集合中的元素的权重不一样，元素的权重随元素距离当前时间的远近而呈现指数型的衰减。主要是解决数据集合中的离散点，让数据曲线跟加平滑。比如Load1、Load5、Load15目前的计算逻辑就采用EWMA算法；</p><h3 id="6-5-数据查询API："><a href="#6-5-数据查询API：" class="headerlink" title="6.5 数据查询API："></a>6.5 数据查询API：</h3><p>待补充</p><h2 id="七、扩展阅读："><a href="#七、扩展阅读：" class="headerlink" title="七、扩展阅读："></a>七、扩展阅读：</h2><p>metric起源：</p><p><a href="https://www.youtube.com/watch?v=czes-oa0yik" target="_blank" rel="noopener">https://www.youtube.com/watch?v=czes-oa0yik</a></p><p>小米 open-falcon：</p><p><a href="http://open-falcon.com/" target="_blank" rel="noopener">http://open-falcon.com/</a></p><p>网易企业级监控：</p><p><a href="http://blog.163yun.com/archives/900" target="_blank" rel="noopener">http://blog.163yun.com/archives/900</a></p><p>salesforce-Argus：<br><a href="https://github.com/salesforce/argus" target="_blank" rel="noopener">https://github.com/salesforce/argus</a></p><p>使用Metrics监控应用程序的性能：</p><p><a href="http://www.cnblogs.com/yangecnu/p/Using-Metrics-to-Profiling-WebService-Performance.html" target="_blank" rel="noopener">http://www.cnblogs.com/yangecnu/p/Using-Metrics-to-Profiling-WebService-Performance.html</a></p><p>深入浅出时序数据库之预处理篇：</p><p><a href="http://www.infoq.com/cn/articles/pretreatment-in-sequential-databases" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/pretreatment-in-sequential-databases</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、监控系统整体概述&quot;&gt;&lt;a href=&quot;#一、监控系统整体概述&quot; class=&quot;headerlink&quot; title=&quot;一、监控系统整体概述&quot;&gt;&lt;/a&gt;一、监控系统整体概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;系统背景：&lt;br&gt;在当前项目中，当我们对特定流程注
      
    
    </summary>
    
      <category term="HighAvailability" scheme="http://heartaway.cn/categories/HighAvailability/"/>
    
    
  </entry>
  
  <entry>
    <title>spring quartz 指定trigger的执行机器</title>
    <link href="http://heartaway.cn/2018/03/06/Java/2018-03-06-spring-quartz-trigger/"/>
    <id>http://heartaway.cn/2018/03/06/Java/2018-03-06-spring-quartz-trigger/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.803Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用spring-quartz的时候，常常会遇到一个场景，那就是任务的调度会随着争取锁的先后顺序而出现不固定机器执行的场景，这在正常业务逻辑中具备了很好的容灾能力，但是在我们排查问题时，却带来了困绕，如果出现问题，我们期望任务调度固定在一台机器上进行执行，方便我们对问题的定位和排查。</p><p>这里就探讨如何扩展spring-quartz来实现任务的固定机器执行。</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>要指定机器运行trigger，那首先我们必须清楚spring-quartz cluster模式下，任务的触发时如何进行分布式执行的。<br>spring-quartz cluster 是借助数据锁来实现并发控制的，需要注意的是分布式环境下需要保证各机器系统时间一致性；</p><p>核心处理线程QuartzSchedulerThread决定了扫描那些JOB，以及触发执行和生命周期的维护。<br>QuartzSchedulerThread中run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在trigger表中扫描指定SCHED_NAME、状态为WAITING，下次触发时间在30秒内的触发器</span></span><br><span class="line">triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                                now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line">....                  </span><br><span class="line"><span class="comment">//触发器执行</span></span><br><span class="line">List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);                                                          </span><br><span class="line">...</span><br><span class="line"><span class="comment">//释放触发器</span></span><br><span class="line">qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//完成触发器</span></span><br><span class="line">qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br></pre></td></tr></table></figure><p>我们就可以在acquireNextTriggers中做扩展，获取全部或者指定了实例ID的trigger。</p><p>延伸思考：acquireNextTriggers获取到trigger列表后，假设机器宕机，这些trigger如何路由到其他机器中正常运行？</p><h3 id="扩展实例ID的生成策略"><a href="#扩展实例ID的生成策略" class="headerlink" title="扩展实例ID的生成策略"></a>扩展实例ID的生成策略</h3><p>spring-quartz一般配置的org.quartz.scheduler.instanceId：AUTO，采用的是SimpleInstanceIdGenerator ID生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleInstanceIdGenerator</span> <span class="keyword">implements</span> <span class="title">InstanceIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateInstanceId</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostName() + System.currentTimeMillis();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't get host name!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleInstanceIdGenerator 采用机器主机名称与当前时间戳作为instanceId,我们期望在开发环境使用hostName，在生产环境(Linux)采用IP作为实例ID。</p><p>实现InstanceIdGenerator接口，实现自己的ID生成策略，QuartzSchedulerInstanceIdGenerator的实现逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzSchedulerInstanceIdGenerator</span> <span class="keyword">implements</span> <span class="title">InstanceIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(QuartzSchedulerInstanceIdGenerator.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OS_NAME = <span class="string">"os.name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WINDOWS = <span class="string">"Windows"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAC = <span class="string">"Mac OS"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateInstanceId</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLocalDev()) &#123;</span><br><span class="line">                id = getHostName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id = IpUtil.getIp();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(id)) &#123;</span><br><span class="line">                id = InetAddress.getLocalHost().getHostName() + System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't generate instance id!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getHostName</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SchedulerException(<span class="string">"Couldn't get host name!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalDev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), WINDOWS) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.indexOfIgnoreCase(System.getProperty(OS_NAME), MAC) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在quartz.properties中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceIdGenerator.class=com.xx.ext.QuartzSchedulerInstanceIdGenerator</span><br></pre></td></tr></table></figure><h3 id="扩展StdJDBCDelegate"><a href="#扩展StdJDBCDelegate" class="headerlink" title="扩展StdJDBCDelegate"></a>扩展StdJDBCDelegate</h3><p>SchedulerFactoryBean 工厂Bean负责加载配置信息，初始化SchedulerFactory和Scheduler实例，jobStore负责job、trigger等的持久化工作，针对不同的数据库类型，可以配置不同的DriverDelegate。Spring中默认使用LocalDataSourceJobStore作为JobStore的处理类。</p><p>SchedulerFactory中initSchedulerFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading Quartz config from ["</span> + <span class="keyword">this</span>.configLocation + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PropertiesLoaderUtils.fillProperties(mergedProps, <span class="keyword">this</span>.configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(<span class="keyword">this</span>.quartzProperties, mergedProps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.put(StdSchedulerFactory.PROP_JOB_STORE_CLASS, LocalDataSourceJobStore.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到SchedulerFactoryBean中设置PROP_JOB_STORE_CLASS属性是在合并用户设置的配置文件之后，也就是PROP_JOB_STORE_CLASS的实现类Spring强制指定为LocalDataSourceJobStore而无法更改，即便是我们在quartz.properties中配置了org.quartz.jobStore.class属性，也会被LocalDataSourceJobStore覆盖掉。</p><p>LocalDataSourceJobStore继承自JobStoreSupport，JobStoreSupport默认配置使用StdJDBCDelegate作为与数据库交互的代理处理类；我们可以通过扩展StdJDBCDelegate类，来实现底层数据库交互的扩展。通过配置org.quartz.jobStore.driverDelegateClass属性，指定driverDelegate为我们扩展后的Delegate。</p><p>在quartz.properties中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.driverDelegateClass=com.xx.ext.StdJDBCDelegateExt</span><br></pre></td></tr></table></figure><p>针对${table_prefix}_quartz_triggers表新增字段INSTANCE_NAME，此字段为InstanceIdGenerator生成的实例ID，此字段会透传到StdJDBCDelegate中的属性instanceId中，因此我们可以扩展StdJDBCDelegate，通过instanceId字段来指定获取的trigger列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StdJDBCDelegateExt</span> <span class="keyword">extends</span> <span class="title">StdJDBCDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String INSTANCE_NAME_VALUE = <span class="string">"&#123;2&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    String SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT = <span class="string">"SELECT "</span></span><br><span class="line">        + COL_TRIGGER_NAME + <span class="string">", "</span> + COL_TRIGGER_GROUP + <span class="string">", "</span></span><br><span class="line">        + COL_NEXT_FIRE_TIME + <span class="string">", "</span> + COL_PRIORITY + <span class="string">" FROM "</span></span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_TRIGGERS + <span class="string">" WHERE "</span></span><br><span class="line">        + COL_SCHEDULER_NAME + <span class="string">" = "</span> + SCHED_NAME_SUBST</span><br><span class="line">        + <span class="string">" AND "</span> + COL_TRIGGER_STATE + <span class="string">" = ? AND "</span> + COL_NEXT_FIRE_TIME + <span class="string">" &lt;= ? "</span></span><br><span class="line">        + <span class="string">" AND ("</span> + COL_INSTANCE_NAME + <span class="string">" IS NULL OR "</span> + COL_INSTANCE_NAME + <span class="string">" = "</span> + INSTANCE_NAME_VALUE + <span class="string">")"</span></span><br><span class="line">        + <span class="string">"AND ("</span> + COL_MISFIRE_INSTRUCTION + <span class="string">" = -1 OR ("</span> + COL_MISFIRE_INSTRUCTION + <span class="string">" != -1 AND "</span></span><br><span class="line">        + COL_NEXT_FIRE_TIME + <span class="string">" &gt;= ?)) "</span></span><br><span class="line">        + <span class="string">"ORDER BY "</span> + COL_NEXT_FIRE_TIME + <span class="string">" ASC, "</span> + COL_PRIORITY + <span class="string">" DESC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许设置trigger 指定一台机器进行任务调度执行；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> noLaterThan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> noEarlierThan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TriggerKey&gt; <span class="title">selectTriggerToAcquire</span><span class="params">(Connection conn, <span class="keyword">long</span> noLaterThan, <span class="keyword">long</span> noEarlierThan, <span class="keyword">int</span> maxCount)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;TriggerKey&gt; nextTriggers = <span class="keyword">new</span> LinkedList&lt;TriggerKey&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(rtp(SELECT_NEXT_TRIGGER_TO_ACQUIRE_EXT, instanceId));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set max rows to retrieve</span></span><br><span class="line">            <span class="keyword">if</span> (maxCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.setMaxRows(maxCount);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to give jdbc driver a hint to hopefully not pull over more than the few rows we actually need.</span></span><br><span class="line">            <span class="comment">// Note: in some jdbc drivers, such as MySQL, you must set maxRows before fetchSize, or you get exception!</span></span><br><span class="line">            ps.setFetchSize(maxCount);</span><br><span class="line"></span><br><span class="line">            ps.setString(<span class="number">1</span>, STATE_WAITING);</span><br><span class="line">            ps.setBigDecimal(<span class="number">2</span>, <span class="keyword">new</span> BigDecimal(String.valueOf(noLaterThan)));</span><br><span class="line">            ps.setBigDecimal(<span class="number">3</span>, <span class="keyword">new</span> BigDecimal(String.valueOf(noEarlierThan)));</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next() &amp;&amp; nextTriggers.size() &lt;= maxCount) &#123;</span><br><span class="line">                nextTriggers.add(triggerKey(</span><br><span class="line">                    rs.getString(COL_TRIGGER_NAME),</span><br><span class="line">                    rs.getString(COL_TRIGGER_GROUP)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> nextTriggers;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResultSet(rs);</span><br><span class="line">            closeStatement(ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">rtp</span><span class="params">(String query, String instanceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MessageFormat.format(query,</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123;tablePrefix, getSchedulerNameLiteral(), <span class="string">"'"</span> + instanceName + <span class="string">"'"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成了指定trigger在特定instanceId上运行，但是有一个问题，假如我们期望trigger可以在多台instanceId上随机执行的话，该如何实现呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用spring-quartz的时候，常常会遇到一个场景，那就是任务的调度会随着争取锁的先后顺序而出现不固定机器执行的场景，这在正常业务逻辑中具备了很好的容灾能力，但是在我们排查问题时，却带来了困绕，如果出现问题，我们期望任务调度固定在一台机器上进行执行，方便我们对问
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring中property-placeholder的使用与解析</title>
    <link href="http://heartaway.cn/2018/01/19/Java/2018-01-19-spring-properties/"/>
    <id>http://heartaway.cn/2018/01/19/Java/2018-01-19-spring-properties/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.803Z</updated>
    
    <content type="html"><![CDATA[<p>在我们程序开发中，进程会需要把一些变量通过property方式进行提取，方便不同环境配置不同的属性，替换变量的方法通常有两种，一种是静态替换，一种是动态替换；所谓静态替换，是在打包编译的时候，把变量替换掉，动态替换，是在程序运行起来时，通过把属性注入到程序的环境变量中，类初始化的时候，再使用环境变量进行替换的一种方法。</p><p>静态替换常用工具：autoconfig<br>动态替换常用工具：spring.property-placeholder</p><h2 id="spring动态替换变量实践"><a href="#spring动态替换变量实践" class="headerlink" title="spring动态替换变量实践"></a>spring动态替换变量实践</h2><p>简洁配置法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:xxx.properties"</span> </span><br><span class="line">ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"location"</span>&gt;</span><br><span class="line">        &lt;value&gt;myConfig.properties&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>完整配置属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder   </span><br><span class="line">        location=<span class="string">""</span>  </span><br><span class="line">        file-encoding=<span class="string">""</span>  </span><br><span class="line">        ignore-resource-not-found=<span class="string">""</span>  </span><br><span class="line">        ignore-unresolvable=<span class="string">""</span>  </span><br><span class="line">        properties-ref=<span class="string">""</span>  </span><br><span class="line">        local-override=<span class="string">""</span>  </span><br><span class="line">        system-properties-mode=<span class="string">""</span>  </span><br><span class="line">        order=<span class="string">""</span>  </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>ignore-resource-not-found：如果属性文件找不到，是否忽略，默认false，即不忽略，找不到将抛出异常 </p><p>ignore-unresolvable：是否忽略解析不到的属性，如果不忽略，找不到将抛出异常 </p><p>order：当配置多个<a href="context:property-placeholder/" target="_blank" rel="noopener">context:property-placeholder/</a>时的查找顺序</p><p>不推荐将ignore-resource-not-found和ignore-unresolvable的值设置为ture，默认为false，可以有效避免程序运行异常</p><h4 id="使用PropertySource注解配置"><a href="#使用PropertySource注解配置" class="headerlink" title="使用PropertySource注解配置"></a>使用PropertySource注解配置</h4><p>Spring3.1添加了@PropertySource注解,方便添加property文件到环境.</p><h4 id="properties的注入与使用"><a href="#properties的注入与使用" class="headerlink" title="properties的注入与使用"></a>properties的注入与使用</h4><ul><li>java中使用@Value注解获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>( <span class="string">"$&#123;jdbc.url&#125;"</span> )</span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure><ul><li>在Spring的xml配置文件中获取</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="配置多个property-placeholder属性"><a href="#配置多个property-placeholder属性" class="headerlink" title="配置多个property-placeholder属性"></a>配置多个property-placeholder属性</h4><p>Spring容器是采用反射扫描的发现机制，通过标签的命名空间实例化实例，当Spring探测到容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderCVonfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描，即只能存在一个实例！</p><p>所以一遍不建议配置多个property-placeholder对象，但是在必须使用多个的场景下，如何配置呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=<span class="string">"xxx.properties"</span> ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:property-placeholder location=<span class="string">"xxx.properties"</span> ignore-unresolvable=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>需要设置ignore-unresolvable=”true”，否则后面的property-placeholder不会被加载；</p><p>ignore-unresolvable单独使用来看是“是否忽视不存在的配置项”，不仅如此，其还有一个隐含意思：是否还要扫描其他配置项：如果为false，则会忽视后续的property-placeholder，如果需要配置多个property-placeholder则应该设置为true；</p><h4 id="context-property-placeholder-工作原理"><a href="#context-property-placeholder-工作原理" class="headerlink" title="context:property-placeholder 工作原理"></a>context:property-placeholder 工作原理</h4><p>在 ContextNamespaceHandler 中对于 context中的property-placeholder 标签，会采用PropertyPlaceholderBeanDefinitionParser解析器进行解析；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyPlaceholderBeanDefinitionParser解析器会将property-placeholder 标签解析为一个PropertySourcesPlaceholderConfigurer的单例 bean 。</p><p>可以看出 PropertySourcesPlaceholderConfigurer 或者 PropertyPlaceholderConfigurer 仅仅是做了一个配置文件的解析工作，真正的注入并不由它们完成，而是托付给了Spring 的Bean初始化流程。<br>之所以这么做可以生效，是因为这两个类实现了 BeanFactoryPostProcessor 接口，这个接口的优先级高于后续的Spring Bean。</p><p>属性元素的注入依赖于 AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues。 通过解析PropertySourcesPlaceholderConfigurer 查询得到元素值。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.findAutowiringMetadata(beanName, bean.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertySourcesPlaceholderConfigurer本质上是一个BeanFactoryPostProcessor。解析XML的流程在BeanFactoryPostProcessor之前， 优先将配置文件的路径以及名字通过Setter传入PropertySourcesPlaceholderConfigurer。</p><p>如上BeanFactoryPostProcessor的优先级又优于其余的Bean。因此可以实现在bean初始化之前的注入。</p><h4 id="Spring-Value注入流程"><a href="#Spring-Value注入流程" class="headerlink" title="Spring @Value注入流程"></a>Spring @Value注入流程</h4><ol><li>Spring Context 的初始化开始</li><li>读取到context:property-placeholder标签或者PropertySourcesPlaceholderConfigurer</li><li>解析并实例化一个PropertySourcesPlaceholderConfigurer。同时向其中注入配置文件路径、名称</li><li>PropertySourcesPlaceholderConfigurer自身生成多个StringValueResolver备用，Bean准备完毕</li><li>Spring在初始化非BeanFactoryPostProcessor的Bean的时候，AutowiredAnnotationBeanPostProcessor 负责找到Bean内有@Value注解的Field或者Method</li><li>通过PropertySourcesPlaceholderConfigurer寻找合适的StringValueResolver并解析得到val值。注入给@Value的Field或Method。(Method优先)2</li><li>Spring的其他流程。</li></ol><p>参考：<br><a href="http://blog.csdn.net/qyp199312/article/details/54313784" target="_blank" rel="noopener">http://blog.csdn.net/qyp199312/article/details/54313784</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们程序开发中，进程会需要把一些变量通过property方式进行提取，方便不同环境配置不同的属性，替换变量的方法通常有两种，一种是静态替换，一种是动态替换；所谓静态替换，是在打包编译的时候，把变量替换掉，动态替换，是在程序运行起来时，通过把属性注入到程序的环境变量中，类初
      
    
    </summary>
    
      <category term="Java" scheme="http://heartaway.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>系统权限控制体系</title>
    <link href="http://heartaway.cn/2018/01/04/Program/2018-01-04-permission-system-degisn/"/>
    <id>http://heartaway.cn/2018/01/04/Program/2018-01-04-permission-system-degisn/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。比如我们开放的功能页面需要登录授权之后才能访问，一些功能需要具备特定权限的人才能操作；再比如我们开放了数据API接口，如果不做访问控制，那么任何人都可以调用，当被不法分子操作时将给我们带来巨大的麻烦。那么在Java 整个体系中访问控制是否有一套理论技术支撑呢，我们是否可以做一个通用性的访问控制系统来完成分布式系统架构下的复杂的权限控制？接下来会一一介绍。</p><h3 id="访问控制的本质："><a href="#访问控制的本质：" class="headerlink" title="访问控制的本质："></a>访问控制的本质：</h3><p>系统权限控制 本质上是访问控制（Access Control），那访问控制的本质又是什么呢？其实就是合法的访问受保护的资源，通俗的解释就是“【谁】是否有可以对某个【资源】进行某种【操作】”；可以看出访问控制的三个基本要素：主体（请求实体）、客体（资源实体）、控制策略（属性集合）；</p><h3 id="访问控制需要完成的两个任务："><a href="#访问控制需要完成的两个任务：" class="headerlink" title="访问控制需要完成的两个任务："></a>访问控制需要完成的两个任务：</h3><p>识别和确认访问系统的用户；<br>决定该用户可以对某一系统资源进行何种类型的访问；</p><h3 id="访问控制理论模型："><a href="#访问控制理论模型：" class="headerlink" title="访问控制理论模型："></a>访问控制理论模型：</h3><ul><li>DAC&amp;MAC模型<ul><li>DAC：自主访问控制；</li><li>MAC：强制访问控制，一般用于多级安全军事系统；</li></ul></li><li>IBAC模型：<ul><li>基于身份的访问控制模型</li><li>举例：登录验证</li><li>比如Java中使用cookie、session存储回话标识；</li></ul></li><li>RBAC模型：<ul><li>基于角色的访问控制（Role-Based Access Control）</li><li>用户、角色、权限</li><li>RBAC是ABAC的一种单属性特例；</li><li>1992年David F.Ferraiolo &amp; D.Richard Kuhn在第十五届国家计算机安全会议上提出；</li><li>论文：<a href="https://csrc.nist.gov/projects/role-based-access-control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/role-based-access-control</a></li><li>举例：丰趣-小二后台的认证授权模型设计；</li><li>Spring Security、Apache Shiro、Ali ACL</li></ul></li><li>ABAC模型：<ul><li>基于属性的访问控制模型 (Attribute Based Access Control)</li><li>举例：阿里云、AWS；</li><li>论文：<ul><li><a href="https://csrc.nist.gov/projects/attribute-based-access-control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/attribute-based-access-control</a></li><li><a href="https://link.springer.com/chapter/10.1007/978-3-319-25645-0_14" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-319-25645-0_14</a></li><li><a href="http://profsandhu.com/dissert/xin_slides.pdf" target="_blank" rel="noopener">http://profsandhu.com/dissert/xin_slides.pdf</a></li></ul></li></ul></li></ul><p>示意图：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/068d3b155b6538ee6f4651d7febe19cd.png" alt=""><br>基于RBAC权限模型的常见数据库模型设计：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/af745d65be9e6922518ff6402e805464.png" alt=""><br>设计的核心主题: 用户、权限、角色、用户角色、角色权限、用户组、用户组角色、操作审计<br>阿里巴巴登录鉴权与审计的三驾马车：BUC、ACL、OpLog；</p><h3 id="Java常用访问控制框架："><a href="#Java常用访问控制框架：" class="headerlink" title="Java常用访问控制框架："></a>Java常用访问控制框架：</h3><ul><li>JAAS框架：<ul><li>Authentication（鉴别），    Authorization（授权），Accounting（计费）；</li><li>Java认证和授权服务（Java Authentication and Authorization Service，简称JAAS）</li><li>支持的框架：LDAP</li><li>特点：面世时间早，使用受限，不建议使用；</li></ul></li><li>Spring Security框架</li><li>Apache Shiro框架</li></ul><h3 id="权限系统的演变历史："><a href="#权限系统的演变历史：" class="headerlink" title="权限系统的演变历史："></a>权限系统的演变历史：</h3><h4 id="1：-标准的JAAS-时代；"><a href="#1：-标准的JAAS-时代；" class="headerlink" title="1： 标准的JAAS 时代；"></a>1： 标准的JAAS 时代；</h4><p>J2ee时代，Java提出了标准的鉴权服务，即jaas；通过简单的容器配置和文件配置，通过一个LDAP（可以用数据库，只是效率不高），就可以提供一个极为高效便捷的权限管控服务。这个模式不仅支持页面管控，还支持ejb服务接口管控。其鉴权因为ldap的数倍于数据库的查询效率而无需任何缓存，速度很快。但是伴随着分布式服务化进程，应用的数量无限度增长，这种散落在各个容器的配置给容灾和修改，都带来了极大的挑战，ldap的可读化差，修改和编辑极为不便，当需求一旦个性化超过了树能够表达的模型便很难在适应。并且当ldap的数据爆炸式增长，且呈现28规律时（数据冷热不均），或者如果需要频繁的写ldap，查询效率会陡然下降。虽然这种方式目前并不流行的，但是由于历史原因，还存留着使用这种方式的管控方式，所以我们在Spring Security或者阿里的ACL中都还能看到对JAAS的支持。</p><h4 id="2：-单点登录-SSO-接口鉴权时代；"><a href="#2：-单点登录-SSO-接口鉴权时代；" class="headerlink" title="2： 单点登录(SSO)+接口鉴权时代；"></a>2： 单点登录(SSO)+接口鉴权时代；</h4><p>把分散在各个系统的登录认证服务统一到一个系统中来，统一管控登录授权业务，用户只要在一个系统中登录了，在其它系统中就没必要再次登录了，这就是SSO。简单的实现是登录授权系统部署在一台机器上，不涉登录系统的多机部署，此架构具有单点风险；任何具备高可用思维的架构师都不会允许此风险存在，原因有二：1. 统一登录中心后，SSO成为极为核心的应用，如果SSO系统挂了，那么需要登录的任何服务器都无法正常提供服务；2. 单台机器不具备抵抗登录风暴的能力； 所以SSO系统必须成为集群部署模式。其次，在访问控制模型上，也必须放弃JAAS方式，转而使用RBAC模型；</p><h4 id="3：-统一登录（分布式Session）-接口鉴权时代；"><a href="#3：-统一登录（分布式Session）-接口鉴权时代；" class="headerlink" title="3： 统一登录（分布式Session） + 接口鉴权时代；"></a>3： 统一登录（分布式Session） + 接口鉴权时代；</h4><p>SSO系统集群部署后，面临的首要问题就是Session的共享问题，比如用户在sso-1 机器上登录了，下次访问sso-2机器时，也必须是登录态的。分布式Session使用较多的方案为：Session集中管理；比如阿里巴巴基于Tair 缓存体系的共享session体系tbsession。如果采用了session + cookie的方案，并且服务端集群是多域名共享登录的话，那么还需要提供cookie跨域同步的能力（解决cookie不能跨域的问题）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。比如我们开放的功能页面需要登录授权之后才能访问，一些功能需要具备特定权限的人才能操作；再比如我们开放了数据API接口，如果不做访问控制，那么任何人都可以
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>Taobao SSO 跨域登录过程解析</title>
    <link href="http://heartaway.cn/2018/01/04/Program/2018-01-04-taobao-sso/"/>
    <id>http://heartaway.cn/2018/01/04/Program/2018-01-04-taobao-sso/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<p>今年的双十一和双十二已经告一段落，你是否买到了你想要的宝贝呢？我们知道双十一是天猫的主场，双十二是淘宝的主场，你有没有注意到你在登录了淘宝后，访问天猫或者飞猪，你还是处于登录态的，但是我们知道cookie是不能跨域的，那么阿里是如何做到了多域名下的登录态同步呢？接下来我们通过抓包进行请求解析来了解这个过程。</p><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><ol><li>如果忘了Cookie和Session的区别，那么建议你先回顾一下，可以参考：<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md</a></li><li>如果不知道为什么需要鉴权，为什么需要SSO，为什么需要跨域登录，建议你先阅读上一篇文章“系统权限控制”。</li></ol><h2 id="测试过程："><a href="#测试过程：" class="headerlink" title="测试过程："></a>测试过程：</h2><ol><li>访问<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 请求登录，跳转到 login.taobao.com<ul><li>输入用户名和密码后，登录成功，302 回调到<a href="http://www.taobao.com页面" target="_blank" rel="noopener">www.taobao.com页面</a></li><li>Post 表单到 login.taobao.com , response 为 set-cookie，并通过redirectURL 跳会<a href="http://www.taobao.com首页；" target="_blank" rel="noopener">www.taobao.com首页；</a></li></ul></li><li>访问 <a href="http://www.tmall.com" target="_blank" rel="noopener">www.tmall.com</a><ul><li><a href="http://www.tmall.com页面响应中发起新的请求" target="_blank" rel="noopener">www.tmall.com页面响应中发起新的请求</a> tmcc.tmall.com/pass.com</li></ul></li><li>请求页面 <a href="https://tmcc.tmall.com/pass.htm" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm</a><ul><li>响应为 302 跳转到： <a href="https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1</a></li><li>tbpm=1表示：进行tbsession的跨域同步；</li></ul></li><li>请求页面 <a href="https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https://tmcc.tmall.com/pass.htm?tbpm=1</a><ul><li>在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息</li><li>响应为302跳转到：<a href="https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1" target="_blank" rel="noopener">https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1</a></li><li>服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。</li></ul></li><li>请求页面 <a href="https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1" target="_blank" rel="noopener">https://pass.tmall.com/add?_tb_token_=eef03e35fbe&amp;u......&amp;target=https%3A%2F%2Ftmcc.tmall.com%2Fpass.htm%3Ftbpm%3D1</a><ul><li>携带cookie 信息的query string 参数请求 tmall.com域名下的信息，请求添加cookie。</li><li>响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步；</li><li>响应状态未302 重定向到 <a href="https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm?tbpm=1</a></li></ul></li><li>请求页面<a href="https://tmcc.tmall.com/pass.htm?tbpm=1" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm?tbpm=1</a> 302 跳转到 <a href="https://tmcc.tmall.com/pass.htm" target="_blank" rel="noopener">https://tmcc.tmall.com/pass.htm</a></li></ol><p>抓包信息：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/87d35687c06bdf7d01ea78c3aa1f8c7f.png" alt=""><br>图中隐藏了非关键请求，比如页面的静态资源等；</p><p>同样：</p><ol><li>访问 <a href="http://www.alitrip.com，会同步请求https://ffa.alitrip.com/userInfo.htm的请求" target="_blank" rel="noopener">www.alitrip.com，会同步请求https://ffa.alitrip.com/userInfo.htm的请求</a></li><li>请求页面<a href="https://ffa.alitrip.com/userInfo.htm" target="_blank" rel="noopener">https://ffa.alitrip.com/userInfo.htm</a><ul><li>响应为 302 跳转到：<a href="https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserInfo.htm" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserInfo.htm</a></li></ul></li><li>请求页面<a href="https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserIn" target="_blank" rel="noopener">https://login.taobao.com/jump?target=https%3A%2F%2Fffa.alitrip.com%2FuserIn</a><ul><li>在请求login.taobao.com/jump时，会携带上taobao.com域下的cookie信息</li><li>响应为302跳转到：<a href="https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4…" target="_blank" rel="noopener">https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4…</a></li><li>服务器端把taobao域下的cookie信息拼接到了302跳转的url 的 query string上。</li></ul></li><li>请求页面<a href="https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4" target="_blank" rel="noopener">https://pass.alitrip.com/add?_tb_token_=eef03e35fbe&amp;uss=UtBTusG4</a><ul><li>携带cookie 信息的query string 参数请求 alitrip.com 域名下的信息，请求添加cookie</li><li>响应中把请求中的cookie信息set 到 浏览器cookie中，以此完成tmall.com域名下的cookie同步;</li></ul></li></ol><p>示意图：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ad93fbcaff26e6b4bc3ca3af620468e9.png" alt=""></p><ol><li>访问原始url： tmcc.tmall.com</li><li>重定向，访问login.taobao.com/jump</li><li>重定向，访问pass.tmall.com</li><li>重定向，访问原始url（带有同步标识tbpm）</li><li>重定向，访问原始url（去掉同步标识tbpm）</li></ol><p>如果我们taobao.com域下没有登录cookie，通过在login.tmall.com页面进行登录，那么cookie的传递是怎么样的呢？<br>通过测试，发现在请求login.tmall.com的时候会同步请求login.taobao.com然后cookie依然是通过taobao域同步到tmall域名，也就是cookie的同步是单向；</p><p>当然，这个过程是正向流程，那退出登录的逆向流程是怎么样的呢？会同步请求login.taobao.com/clear, 通过set-cookie 清楚session cookie（会话cookie），然后进行 302 跳转到 <a href="https://pass.tmall.com/clear" target="_blank" rel="noopener">https://pass.tmall.com/clear</a> 进行cookie清理，然后 302 跳转到 <a href="https://pass.etao.com/clear" target="_blank" rel="noopener">https://pass.etao.com/clear</a> 进行cookie清理，然后 302 跳转到<a href="https://pass.etao.com/clear" target="_blank" rel="noopener">https://pass.etao.com/clear</a> 进行 cookie清理，如此重复知道所有域名cookie进行清理完毕。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/eafb7fc66c6139c50a6a8bbb5bd89e58.png" alt=""><br>通过测试发现淘系的系统所有的退出登录都是走login.taobao.com/member/logout.jhtml , 然后通过一些列302 跳转pass系统进行登录态的清理。 登录态在到阿里云、支付宝是不通的,因为阿里云和支付宝的账号体系不一样。</p><h2 id="禁用Cookie："><a href="#禁用Cookie：" class="headerlink" title="禁用Cookie："></a>禁用Cookie：</h2><p>可以看出整个跨域登录依赖的是cookie信息的传递与跨域设置，如果出于安全考虑，我们禁用了cookie，是否还能正常工作呢？经过测试，发现禁用cookie后，跨域自动登录不能正常执行了，跨域请求后对于受限的访问请求还是会自动跳登录。由于设计上没有考虑cookie禁用的情况，淘宝的登录页面竟然无法进入，一直循环跳转登录页面。</p><h2 id="分布式Session-的常见解决方案："><a href="#分布式Session-的常见解决方案：" class="headerlink" title="分布式Session 的常见解决方案："></a>分布式Session 的常见解决方案：</h2><ol><li>通过cookie进行共享；</li><li>借助第三方进行存储，比如缓存；</li><li>不容服务器之间进行session同步；</li></ol><p>这里面涉及到阿里两个重要级产品：tbsession、passcookie。</p><ol><li>tbsession：用来解决多应用间session共享存储与同步问题；tbsession采用的是 方法1 + 方法2的结合；</li><li>passcookie：用来解决不同域名之间cookie同步的问题，以及决定同步那些cookie；</li></ol><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>问：为什么有了cookie 还需要 session？</p><p>答：cookie存储本身具备一些优势，比如信息存储在客户端，分散了资源消耗，cookie可以在客户端进行持久化存储（cookie在客户端分为：Permanent Cookies，Session Cookie）。    主要是只使用cookie作为资源访问的鉴权记录具备不安全性，容易引起CSRF（跨站请求伪造），比如攻击者劫持登录后的cookie信息进行页面操作，此时服务器以为还是用户自身在登录态下的本人操作。当然，只是简单的使用session也并不能彻底解决CSRF，使用session只是把用户的登录态信息保存在服务器端，客户端cookie往往会记录一个JSessionId 用来标识当前会话ID，jsessionid在网络中传输还是存在被劫持的可能性（参考下面的session劫持），所以需要配合响应的解决手段防止CSRF的发生。其次，cookie的使用在大小和条数上限制，大于需要存储大量用户态信息的场景下已经不够用了，此时需要借助session在服务端的存储设备来实现。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/877347f9c7fc1318a494640818519c2a.png" alt=""></p><p>问：登录后会会话中的每一次访问受限资源都需要访问验证？</p><p>答：是的，因为每一次请求都无法确认你的身份，所以为了降低复杂认证授权的过程，通过sessionId 来标识某一会话；如果我们的Cookie信息泄露，那么不法分子就可以使用我们包含登录态的Cookie进行访问我们的受限资源（比如拷贝登录后的cookie信息通过postman请求需要登录后才能查看的信息），即便是我们丢增删改的请求采用了crsf_token ,不法分子还是可以看到我们的信息，信息已经造成了泄露。所以对于持久化Cookie，尽量设置为httpOnly，不允许通过JS脚本读取Cookie信息。还有就是使用https协议代替http协议（从tcp到ssl），这样不法分子劫持了请求信息，也无法破解请求信息的内容。</p><p>问：是否采用了https就不需要防范CSRF了？</p><p>答：不是的，我们采用https，是在数据传输层对请求进行进行加密后发送，但是如果CSRF是在浏览器的本地读取我们的Cookie信息（存储在我们浏览器中本地的Cookie信息确实明文的），还是可以读取到我们明文的Cookie信息。采用https只是防止了请求在传输中拦截后窃取我们的Cookie进行攻击而已。</p><h2 id="Session-劫持与防范："><a href="#Session-劫持与防范：" class="headerlink" title="Session 劫持与防范："></a>Session 劫持与防范：</h2><p>这篇文章详细阐述了服务器端不做任何处理下的sessionId劫持的案例。<br><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md</a></p><p>session 劫持的防范措施：</p><ol><li>使用POST 请求 + Referer验证；<ul><li>此方式简单容易实现；</li><li>弊端：1.所有请求都是用POST方式不符合规范，比如RestFul。2.很多场景下请求是无法携带referer的；</li></ul></li><li>使用csrf_token：在涉及增删改的请求中，带上一个和服务器端同步的随机数(token)，然后在服务器端做校验。由于这个token是变化的，同时具有私密性，只会内嵌到当前用户的页面中，因此可以起到防止CSRF的作用，比如淘宝域下cookie中的_tb_token_参数。</li></ol><p>csrftoken的整个生命周期一般是这样的：</p><ul><li>后端针对每一个用户生成唯一的csrftoken后    </li><li>将csrftoken存储在服务器端，且和当前用户一一绑定</li><li>当用户访问页面时，将csrftoken埋入前端页面</li><li>用户提交请求时，需要在请求中附带上csrftoken</li><li>后端对接收到的csrftoken进行校验，判断请求是否合法</li><li>根据请求，后端判断是非需要更新csrftoken</li></ul><p>使用csrf_token 方案目前来说是最有效的安全措施，但是方案实施起来也相对复杂很多，需要考虑csrf_token的存储、更新、埋点以及校验等逻辑。</p><h2 id="本质思考："><a href="#本质思考：" class="headerlink" title="本质思考："></a>本质思考：</h2><p>SSO 跨域统一登录的本质就是【登录态信息的跨域共享，为了实现共享采用了复制的方式】，这跟我们现实世界中为了达到知识共享，需要把知识转化为书籍，然后通过书籍印刷进行分发。</p><h2 id="抓包工具介绍："><a href="#抓包工具介绍：" class="headerlink" title="抓包工具介绍："></a>抓包工具介绍：</h2><ol><li>工具采用 mac 下的 Charles；</li><li>https由于安全限制无法抓取到具体的内容，所以需要通过一些列的设置才能抓到请求数据；</li><li>Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</li><li>Proxy -&gt; SSL Proxying Setting -&gt; SSL Proxying 添加正则域名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年的双十一和双十二已经告一段落，你是否买到了你想要的宝贝呢？我们知道双十一是天猫的主场，双十二是淘宝的主场，你有没有注意到你在登录了淘宝后，访问天猫或者飞猪，你还是处于登录态的，但是我们知道cookie是不能跨域的，那么阿里是如何做到了多域名下的登录态同步呢？接下来我们通
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>二零一七，我的失败与伟大</title>
    <link href="http://heartaway.cn/2017/12/29/Think/2017-12-29-2017-my-success-and-fail/"/>
    <id>http://heartaway.cn/2017/12/29/Think/2017-12-29-2017-my-success-and-fail/</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.811Z</updated>
    
    <content type="html"><![CDATA[<p>2017年飘然离去，留下的唯有回忆。这一年总有一些刻骨铭心，总有一些难以忘怀，依依不舍。或遗落在某一渡口，或消失在某段站台，或模糊在某页书籍。岁月洗礼而后，一一封存，装帧成册，遗忘的森林，层出不穷的景致，黯淡了记忆的门窗。当又一次轻扣，忽而想起那年夏天的故事，亦或冬天里的恋歌，轻捻时光，掀开了往事，撑开了回忆的帆。这一年有过痛苦、焦虑、烦躁，也有过欢乐，自信和拼搏。</p><p>如果说让我用一句话总结一下2017年，我想这句话会比较合适：</p><blockquote><p>认知上升了一个台阶，但仍未能克服行为上的懒惰；工作生活，持续反思与学习，但仍沉溺于专业深度的自卑之中。</p></blockquote><p>如果非要让我从过去一年中对自己的失败和伟大之处做一些“套路”上的总结的话，以下这几天应该被展现出来，愿它们像伴随我成长之路上的路灯，时时照亮我前行的路。</p><h2 id="1-认知升级，追本溯源"><a href="#1-认知升级，追本溯源" class="headerlink" title="1. 认知升级，追本溯源"></a>1. 认知升级，追本溯源</h2><p>这一年自己思想的改变应该算是最大的收获了。以前对待事情总是浮在表面，现在会主动去思考事情背后的关系与本质，到底是什么导致了当前的状态，每个人说的话其背后的逻辑是什么；比如当开会、讨论、看演讲时，都会跳出当前讨论的事情，去想他们为什么会这么说，理论基础是什么，期望达到一个什么目标。</p><p>近期通过研究高效学习的理论知识，逐步掌握学习知识的方法套路。学习的理论自己在高中和大学阶段坚持的不错，但是工作以来，坚持的并不算好，很多时候，一天过去了，回顾时，是浑浑噩噩的，对自己的人生似乎帮助并不大，感慨自己的浪费生命。记得之前看到过一句话，我们现在做的觉得有挑战的事情，之前已经有很多人应该都做过了，我们只需要看看他们踩过的吭和趟出的路就好的。这点无论是放在编程还是人生上来说，都适用。很多时候，我们不需要重复造轮子，有轮子直接购买使用就好，为自己的工作生活快速提效，这是一个一切为“<strong>效率</strong>”为核心的时代。</p><p>什么是认知升级，就是看到了之前自己看不到的地方，看问题的角度比之前上升了一个角度。如果把认知划分为本能层、情绪层、立场层、利益层、社会心理层、系统认知层和智慧认知层的话，我目前只能算是从本能层走到了情绪层，未来的路还有很多要走。</p><p><img src="/images/posts/20171229/2017-12-12-renzhi-lay.jpeg" alt=""><br>​                            （图片来自“雾满拦江”）</p><p>什么是认知，什么是格局，我觉得有一个例子很不错，值得自己记在心里：</p><p>《吕氏套秋》里记载着一则楚王失弓的故事，讲的是楚王去云梦泽打猎，不小心把自己心爱的弓丢了，侍从们要循原路寻找，楚王说，算了吧，不必去找了，楚人失之，楚人得之，到不了别处的。侍从们都很佩服楚王的豁达与胸怀。孔子听闻此事后说，这句话如果去掉“楚”字就好了，不妨说“人失之，人得之。”老子听说了孔子的评论后，也发表了自己的看法。他说再去掉“人”字会更好。那样就是“失之，得之”，这样才符合天道。</p><h2 id="2-把握自己的命运，不要把自己的未来寄托在别人手上"><a href="#2-把握自己的命运，不要把自己的未来寄托在别人手上" class="headerlink" title="2. 把握自己的命运，不要把自己的未来寄托在别人手上"></a>2. 把握自己的命运，不要把自己的未来寄托在别人手上</h2><p><img src="/images/posts/20171229/2017-12-12-stock.jpeg" alt=""></p><p>相信炒股的朋友都收到过推销内幕股的电话或者微信，他们通过前一天收盘后的预期与第二天开盘后的涨幅逐步获取你的信任，之后采用盈利分成或者入会费的方式，跟你合作，告诉你什么时间点买哪只股票，什么价位卖出。开始的时候，我确实在短时间内赚了好几千快，感觉他们太牛了，感觉这种赚钱方式比工作快多了，无法克制住自己的<strong>贪婪</strong>，投入大量的资金进去，此时一次正常的下跌也让我们损失惨重，炒作垃圾股，根本就没有持仓的信心。跳出来好好想一想，如果钱真的这么好赚，他们为什么还要花这么大的心思跟你分成呢？他们过分强调了平分你的收益而把风险完全抛给了你。其次，走位一个多年的老股票，完全听信一个不知专业深浅的人指导，这跟板上鱼肉有何区别呢？即使是赚了钱，你也获取不到技能的提升，对于你后续的投资思路不会有半毛钱帮助，有的只有那点钱了。</p><p>正确的投资股市方式是建立其自己投资模式，比如改“投机”为“投资”，注重收益与风险的管理，做优质企业的中长线价值投资等。</p><p>其次，这点在个人职业生涯中同样适用，我们伴随着团队成长的同时，也要明确知道自己在职业这个坐标体系中自己的位置，明确自己的目标坐标，通过资源争取或者个人努力，逐渐向目标靠拢，而不是等待着老板或者同事赶着你走。如果事事都是你的老板说了算，你自己没有主见的话，这跟被牵着鼻子走的牛没什么两样，在团队中，你也只能成为“老黄牛”了，当你老了，结果会是“卸磨杀驴”（2017年华为清退老员工事件）。反观自己，以前很少与老板探讨自己想要什么，不要做什么，现在有一定的自信说出自己的诉求，然后主动把握机会磨练自己的独特优势，这一点是一个进步。</p><h2 id="3-矫正心理饥饿的金钱观"><a href="#3-矫正心理饥饿的金钱观" class="headerlink" title="3. 矫正心理饥饿的金钱观"></a>3. 矫正心理饥饿的金钱观</h2><p><img src="/images/posts/20171229/2017-12-12-yunnan-lgh.jpeg" alt=""></p><p>由于自己出生在一个比较贫困的家庭，自幼对金钱就分外珍惜，什么钱都不舍得花，甚至认为除了基本保证生活的开支外，一切的花销都是多余的。很多人看到这点肯定会评价说是“抠门”，我们不能拿着自己优越的生活去评论不曾经历的贫穷生活，因为你想象不到，贫穷深入骨髓后是一种什么状态。每当在相亲节目中看到那些抠门的男方的时候，我都很难能理解，然而面对确实大家一边倒式的批判。改革开放40年来，人们的生活质量有了非常的提升，但是很多的养成的节省系统并不是说改掉就能改掉的，就像我父母，他们年幼时经历了大饥荒，知道现在全家年收入超过已经达到小康水平，但还每日担忧未来可能没有饭吃，非要在自家的储藏室中储藏上几袋大米，心理才有安全感，其实这个陈为“心理饥饿”。由于害怕失去钱，害怕自己变得一无所有，所以自己万事都尽量已保守节省的方式在生活，殊不知，在现代经济中，反而认为最安全的方式往往却是最危险的方式，比如父母为了少还一些利息，买房时尽量不让贷款，几乎全款买房，殊不知，合理负债才是家庭财务经营的正确指导。</p><p>这个世界正在以超乎我们想象的速度变化，如果我们还保守着过去看似正确的理念生活，那么我们会与优质生活质量相差越来越远。钱是用来花的，不是用来存储的，学会花钱也是一门艺术。合理的消费，不仅有助于提高自身生活质量，还能提高国家的经济效应。现在的我不在为一周多买一次水果而大呼小叫，不再为每餐两人三菜而觉得浪费，为了让自己生活有点品质，还是不是给家里买一些鲜花来装饰装饰，美好的生活反过来会对我们的工作行程正反馈，心情好了，工作效率也会高不少。</p><p>自从买了车之后，生活确实变得不一样了，说走就走的旅行变得不再那么困难，自驾游去千岛湖，飞行去昆明、丽江、大理和香格里拉，感受祖国的大美河山和不同的乡土文化，读千卷书，行万里路。世界这么大大，我们应该时长走出去看看，走出工作家庭两点一线之间的线性单调区间。</p><h2 id="4-为专业付费，免费的往往是最贵的"><a href="#4-为专业付费，免费的往往是最贵的" class="headerlink" title="4. 为专业付费，免费的往往是最贵的"></a>4. 为专业付费，免费的往往是最贵的</h2><p>互联网在过去5年，倡导的一直是“免费”的文化，让产品免费，让更多用户受益。我们在使用各种软件或者观看各种收费视频的时候，首先先到的是找一找有没有破解版或者不需要收费的服务，为了获得免费的东西，有时候我们花费了大量的时间和精力，事后想一想，如果把时间换算成钱的话，我们是亏了的。往往<strong>看似免费的东西是最贵的</strong>，这个世界上没有免费的午餐，<strong>一切事情都是有成本的</strong>，只是有些事情的成本是隐形的，不容易被我们察觉罢了。免费的东西，人人都能力，其质量就很差，我们长期阅读低质的信息，会阻碍我们思维升级。反而那些付费的内容，正因为我们的付费，才促就了内容生产者以更加严谨的态度来对待产品，这是一个良性循环。我们值得为优质内容付费，科学高效的方法论告诉我们，跟随业界一流的牛人学习，才是高效的学习策略之一。</p><h2 id="5-你的圈子决定了你的价值"><a href="#5-你的圈子决定了你的价值" class="headerlink" title="5. 你的圈子决定了你的价值"></a>5. 你的圈子决定了你的价值</h2><p>查尔斯琼斯说：通过一个人的朋友圈和他看的书就可以看到5年以后的他，也就是说呢，一个人是他周围5个人的综合体。从而形成了“五次元密友理论”。环境的力量，我们不得不信服。古代有孟母三迁，现代人为了一套学区房挤破脑袋。跟优秀的人在一起，我们会被优秀的气场所影响，观念、行为也逐步会发生改变。</p><p>所以很多成功学或者心灵鸡汤类的文章常常建议我们每年主动与比我们自身段位高的人的人交往与交流，虽然在我们与他们交往中会有一定的不适感，但我们需要认识到这是正常的生理反应，是突破舒适区的副作用，我们终究会逐渐习惯，这种不适感会随着我们段位的提升而逐渐消失。</p><p>反观身边那些职场中晋升非常快的人，在他们成长的路上，几乎都有一个伙伴，和他们一起成长，帮助他们坚持正确的决定，从而避开错误。一个好的有责任心的伙伴是这样的，无条件的爱你，他本身就渴望成功，成熟，会征求你的建议，在你需要帮助的时候能帮助你，能够陪伴鼓励你！你是不能一个人在成长的道路上走下去的，除非你不想达到顶峰。在看看自己当前身处的环境，是否有这样一个伙伴一同成长，如果没有，我们改如何破局？</p><h2 id="6-感悟人性"><a href="#6-感悟人性" class="headerlink" title="6. 感悟人性"></a>6. 感悟人性</h2><p>狗为什么会对陌生人狂吠，人为什么会对伤害自身利益的言论会极力反驳进而情绪失控？面对巨大利益的时候，我们为什么会贪婪？这些都跟本性有关，了解人性，对我们日常生活非常有帮助，无论是我们做投资还是与人相处。就好像，以前老婆跟我抱怨工作上的不顺利，每次在她还没有说完前，我就不耐烦的打断，一口要求都是你自己的错误，在无法改变别人的前提下，你为什么不改变自己呢，然后噼里啪啦的堆砌出一大推自认为很有哲理性的说教语句，换来的结果总是无话可说。当我知晓了这背后的人性需求后，从说教着改为倾听者、陪伴者，效果一下子就不一样了。人性，是需要持续学习和感悟的东西，未来我会花时间系统性的去了解人性的心理学体系。</p><h2 id="7-成为一名佛系青年"><a href="#7-成为一名佛系青年" class="headerlink" title="7. 成为一名佛系青年"></a>7. 成为一名佛系青年</h2><p><img src="/images/posts/20171229/2017-12-12-yunnan-party.jpeg" alt=""></p><p>去了一趟香格里拉，接触藏民后，彻底改变了我对藏民和佛教的看法。认知中，藏M是野蛮和暴利的代名词，佛教是无知的人期望佛教来改变自身命运，现在看来，原来自己如井底之蛙般视野短浅，认知还停留在本能层。在一名叫做“幸福哥”的藏M导游解说藏传佛教的信仰之时，自己不知不觉中流下了真诚而感动的泪水。回来的途中，阅读了鬼脚七的《人生所有经过的路，都是必经之路》，感受他在出嫁求佛路中的点滴感悟，领悟颇多，自此下定决心，没事就开始背诵和抄写心经。佛教教会我们如何看待自己和这个世界，这个视角是脱离自我的视角，是以更高层的认识来看到实物的视角；比如“画外看画”，脱离自我，站在旁观者角度审视自己的举止言行，我们会有不一样的思考。</p><p>在工作生活中，我也不断践行佛教的自我审视的方法，遇到不开心的或者困惑的事情，也尝试着使用佛教中思想来指导言行，虽然有些时候还是不能控制住自己的身为人的本性，但是我相信，通过不断的练习，终究会抵达彼岸，菩提萨婆诃。</p><h2 id="8-让自己成为有一技之长的专业人才"><a href="#8-让自己成为有一技之长的专业人才" class="headerlink" title="8. 让自己成为有一技之长的专业人才"></a>8. 让自己成为有一技之长的专业人才</h2><p><img src="/images/posts/20171229/2017-12-12-aliyun-profile-money.png" alt=""></p><p>身为一名软件工程师，但是迟迟没有专业自信，究其原因，是因为自己在专业性上的精力投入远远不够，由于积累的太薄，很多技术都不说不清其核心思想，当面对未知的问题时，顿时会觉得恐慌和无助，更不要谈自信了。如何成为专业的人才，方法和策略其实自己都已知晓，但是迟迟未能行动，即便是行动起来了，也是三天打鱼两天晒网。这是一个道理过剩，行动力匮乏的年代，我们不会因为知道了变得不一样，而会因我们做了什么而不一样。以此祭奠我过去5年的专业自卑感，计划用一到两年时间来培养自己的专业自信。</p><h2 id="9-认清自己的核心优势，差异化竞争"><a href="#9-认清自己的核心优势，差异化竞争" class="headerlink" title="9. 认清自己的核心优势，差异化竞争"></a>9. 认清自己的核心优势，差异化竞争</h2><p>总觉得自己啥都能干，但是啥都不专业。在面对当前追求效率的社会大浪潮中，分工越来越细化，我们必须清楚的自己在社会大分工中位置，知道自己相比于其他人有哪些优势，短板在哪里，如何发挥个人的差异化竞争。最近在招聘中，对于那些什么都能干，然后什么研究的都不深入，有没有任何亮点的同学，我们基本都会直接Pass掉。我们常常笑道：如果按照现在的标准，我们也许都面不过当前的岗位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年飘然离去，留下的唯有回忆。这一年总有一些刻骨铭心，总有一些难以忘怀，依依不舍。或遗落在某一渡口，或消失在某段站台，或模糊在某页书籍。岁月洗礼而后，一一封存，装帧成册，遗忘的森林，层出不穷的景致，黯淡了记忆的门窗。当又一次轻扣，忽而想起那年夏天的故事，亦或冬天里的恋
      
    
    </summary>
    
      <category term="Think" scheme="http://heartaway.cn/categories/Think/"/>
    
    
  </entry>
  
  <entry>
    <title>The Twelve-Factor App</title>
    <link href="http://heartaway.cn/2017/12/27/Program/2017-12-27-the-twelve-factor-app/"/>
    <id>http://heartaway.cn/2017/12/27/Program/2017-12-27-the-twelve-factor-app/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：</p><ul><li>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</li><li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。</li><li>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。</li><li>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。</li><li>可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。</li><li>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文的贡献者者参与过数以百计的应用程序的开发和部署，并通过 Heroku 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p><p>本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。</p><p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： Patterns of Enterprise Application Architecture ， Refactoring 。</p><h2 id="读者应该是哪些人？"><a href="#读者应该是哪些人？" class="headerlink" title="读者应该是哪些人？"></a>读者应该是哪些人？</h2><p>任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。</p><hr><h1 id="12-factors"><a href="#12-factors" class="headerlink" title="12-factors"></a>12-factors</h1><h2 id="I-基准代码"><a href="#I-基准代码" class="headerlink" title="I. 基准代码"></a>I. 基准代码</h2><p>一份基准代码（Codebase），多份部署（deploy）<br>12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。</p><p>在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。</p><p><img src="https://12factor.net/images/codebase-deploys.png" alt=""></p><p>基准代码和应用之间总是保持一一对应的关系：</p><ul><li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。</li><li>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。</li></ul><p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h2 id="II-依赖"><a href="#II-依赖" class="headerlink" title="II. 依赖"></a>II. 依赖</h2><p>显式声明依赖关系（ dependency ）<br>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p>12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， Ruby 的 <a href="https://bundler.io/" target="_blank" rel="noopener">Bundler</a> 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – <a href="http://www.pip-installer.org/en/latest/" target="_blank" rel="noopener">Pip</a> 用作依赖声明， <a href="http://www.virtualenv.org/en/latest/" target="_blank" rel="noopener">Virtualenv</a> 用作依赖隔离。甚至 C 语言也有类似工具， <a href="http://www.gnu.org/s/autoconf/" target="_blank" rel="noopener">Autoconf</a> 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。</p><p>12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h2 id="III-配置"><a href="#III-配置" class="headerlink" title="III. 配置"></a>III. 配置</h2><p>在环境中存储配置<br>通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，Memcached，以及其他 后端服务 的配置</li><li>第三方服务的证书，如 Amazon S3、Twitter 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 <a href="http://spring.io/" target="_blank" rel="noopener">Spring</a> 时 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html" target="_blank" rel="noopener">代码模块间的依赖注入关系</a> 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p><strong>12-Factor推荐将应用的配置存储于</strong> 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h2 id="IV-后端服务"><a href="#IV-后端服务" class="headerlink" title="IV. 后端服务"></a>IV. 后端服务</h2><p>把后端服务(backing services)当作附加资源<br>后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（<a href="http://dev.mysql.com/" target="_blank" rel="noopener">MySQL</a>，<a href="http://couchdb.apache.org/" target="_blank" rel="noopener">CouchDB</a>），消息/队列系统（<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>，<a href="http://kr.github.com/beanstalkd/" target="_blank" rel="noopener">Beanstalkd</a>），SMTP 邮件发送服务（<a href="http://www.postfix.org/" target="_blank" rel="noopener">Postfix</a>），以及缓存系统（<a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a>）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 <a href="http://postmarkapp.com/" target="_blank" rel="noopener">Postmark</a>），数据收集服务（例如 <a href="http://newrelic.com/" target="_blank" rel="noopener">New Relic</a> 或 <a href="http://www.loggly.com/" target="_blank" rel="noopener">Loggly</a>），数据存储服务（如 <a href="http://http//aws.amazon.com/s3/" target="_blank" rel="noopener">Amazon S3</a>），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。</p><p><strong>12-Factor 应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。</p><p><img src="https://12factor.net/images/attached-resources.png" alt=""></p><p>部署可以按需加载或卸载资源## 部署可以按需加载或卸载资源部署可以按需加载或卸载资源部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h2 id="V-构建，发布，运行"><a href="#V-构建，发布，运行" class="headerlink" title="V. 构建，发布，运行"></a>V. 构建，发布，运行</h2><p> 严格分离构建和运行</p><p><a href="https://12factor.net/zh_cn/codebase" target="_blank" rel="noopener">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li>构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。</li><li>发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。</li><li>运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。</li></ul><p><img src="https://12factor.net/images/release.png" alt=""></p><p><strong>12-factor 应用严格区分构建，发布，运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， <a href="">Capistrano</a> 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。</p><p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h2 id="VI-进程"><a href="#VI-进程" class="headerlink" title="VI. 进程"></a>VI. 进程</h2><p>以一个或多个无状态进程运行应用<br>运行环境中，应用程序通常是以一个和多个 进程 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。</p><p>12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤做此动作——正如 Rails资源管道 ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</p><h2 id="VII-端口绑定"><a href="#VII-端口绑定" class="headerlink" title="VII. 端口绑定"></a>VII. 端口绑定</h2><p>通过端口绑定(Port binding)来提供服务<br>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。</p><p>12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似<a href="http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。" target="_blank" rel="noopener">http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</a></p><p>通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。</p><h2 id="VIII-并发"><a href="#VIII-并发" class="headerlink" title="VIII. 并发"></a>VIII. 并发</h2><p>通过进程模型进行扩展<br>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。<br><img src="https://12factor.net/images/process-types.png" alt=""><br>扩展表现为运行中的进程，工作多样性表现为进程类型。</p><p>在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。</p><p>12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h2 id="IX-易处理"><a href="#IX-易处理" class="headerlink" title="IX. 易处理"></a>IX. 易处理</h2><p>快速启动和优雅终止可最大化健壮性<br>12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。</p><p>进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。</p><p>进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。</p><h2 id="X-开发环境与线上环境等价"><a href="#X-开发环境与线上环境等价" class="headerlink" title="X. 开发环境与线上环境等价"></a>X. 开发环境与线上环境等价</h2><p>尽可能的保持开发，预发布，线上环境相同<br>从以往经验来看，开发环境（* 从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li>时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li>人员差异： 开发人员编写代码，运维人员部署代码。</li><li>工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。</li></ul><p>想要做到 持续部署 就必须* 想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:</p><ul><li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li></ul><p>将上述总结变为一个表格如下：</p><p>传统应用    12-FACTOR 应用<br>每次部署间隔    数周    几小时<br>开发人员 VS 运维人员    不同的人    相同的人<br>开发环境 VS 线上环境    不同    尽量接近<br>后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。</p><p>类型    语言    类库    适配器<br>数据库    Ruby/Rails    ActiveRecord    MySQL, PostgreSQL, SQLite<br>队列    Python/Django    Celery    RabbitMQ, Beanstalkd, Redis<br>缓存    Ruby/Rails    ActiveSupport::Cache    Memory, filesystem, Memcached<br>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。</p><p>12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是## 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h2 id="XI-日志"><a href="#XI-日志" class="headerlink" title="XI. 日志"></a>XI. 日志</h2><p>把日志当做事件流<br>日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p>12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><p>找出过去一段时间特殊的事件。<br>图形化一个大规模的趋势，比如每分钟的请求量。<br>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</p><h2 id="XII-管理进程"><a href="#XII-管理进程" class="headerlink" title="XII. 管理进程"></a>XII. 管理进程</h2><p>后台管理任务当作一次性进程运行<br>进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><p>运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。<br>运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。<br>运行一些提交到代码仓库的一次性脚本。<br>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。</p><p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p><p>转发自：<a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">https://12factor.net/zh_cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
  <entry>
    <title>DevOps的三种方式</title>
    <link href="http://heartaway.cn/2017/12/24/Program/2017-12-24-devops-three-method/"/>
    <id>http://heartaway.cn/2017/12/24/Program/2017-12-24-devops-three-method/</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2018-11-10T08:59:09.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客中提到的“三种方式“源自 <a href="http://www.itrevolution.com/book/the-devops-handbook/" target="_blank" rel="noopener">《DevOps Handbook》</a> 及<a href="https://itrevolution.com/books/novel/" target="_blank" rel="noopener">《凤凰项目》</a>（The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win.），这三种方式描述了构成 DevOps 的理论框架、流程、实践及价值观和哲学。</p><p>感谢《Lean IT》的作者 Mike Orzen 为此文提供宝贵建议。</p><h2 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h2><p>下文将介绍三种模式及在该种模式指导下的 DevOps 实践。</p><h3 id="第一种方式：-系统思考"><a href="#第一种方式：-系统思考" class="headerlink" title="第一种方式： 系统思考"></a>第一种方式： 系统思考</h3><p><img src="https://gw.alipayobjects.com/zos/skylark/90fda8c1-ed1d-414d-bf7a-379e3fc7bd54/2018/png/46243fa7-bffa-4015-acd8-2597e974feee.png" alt=""></p><p>第一种方式强调全局优化，而非局部改进。— 大到部门职能划分（例如研发部和运维部门），小到个人（开发和系统工程师）。</p><p>这种方式将关注点放在整个业务价值流上。换句话说，整个团队应该关注在从需求被定义到开发，再到运维这个过程，直到价值被以服务的形式交付给最终用户。</p><p>将这种方式带到实践中的产出便是永远不要将已知的缺陷传递到下游工作，永远不要为了局部优化影响了整体价值流交付，总是为了增加价值流动努力，永远追求对架构的深刻理解。</p><p>涉及到这种方式的实践有：</p><ul><li>所有环境和代码使用同一个仓库，将软件包纳入版本管理</li><li>团队共同决定发布流程</li><li>保持 DEV、TEST、PRODUCTION 环境的一致性</li><li>自动化回归测试</li><li>小步提交，每日部署；而不是一次部署大量变更</li><li>更快、更频繁发布</li></ul><h3 id="第二种方式：经过放大的反馈回路"><a href="#第二种方式：经过放大的反馈回路" class="headerlink" title="第二种方式：经过放大的反馈回路"></a>第二种方式：经过放大的反馈回路</h3><p><img src="https://gw.alipayobjects.com/zos/skylark/f6cc08b5-b7e5-4162-92a3-0d0df213d902/2018/png/c8e97809-c293-4170-a84c-143789ea7faf.png" alt=""></p><p>第二种方式是创建从开发过程下游至上游的反馈环。几乎所有的流程改进都是为了从时间上缩短和从覆盖面上放大反馈循环，从而可以不断地进行必要的改正。</p><p>第二种方式的产出是关注到价值流中所有涉及到的用户，包括价值流内部和外部的，缩短和放大反馈回路，并且可以随时定位到需要改进的地方。</p><p>涉及到这种方式的实践有：</p><ul><li>代码审查及配置变更检查</li><li>有纪律的自动化测试，使许多同时的小型敏捷团队能够有效地工作</li><li>尽早设置监控预警</li><li>修复 bug 为团队最高优先级</li><li>团队成员之间高度互相信任</li><li>团队之间保持沟通和良好合作<h3 id="第三种方式：持续做试验和学习的文化"><a href="#第三种方式：持续做试验和学习的文化" class="headerlink" title="第三种方式：持续做试验和学习的文化"></a>第三种方式：持续做试验和学习的文化</h3><img src="https://gw.alipayobjects.com/zos/skylark/dfea288e-e3e5-4f41-b1c0-998f7def0202/2018/png/096c5099-06da-403c-8329-3c88f8851fd9.png" alt=""></li></ul><p>第三种方式提倡持续做试验，承担风险、从失败中学习；通过反复实践来达到精通。</p><p>我们需要实验和冒着失败的风险，及时不断地尝试将我们置于一个危险的境地，我们要通过反复试错来掌握使我们远离危险的技能。</p><p>第三种方式的输出为为改善日常工作分配时间、奖励团队冒险精神，将错误人工引入系统以提高系统健壮性。</p><p>最具有代表性的就是 Netfilx 的 Chaos monkey ，Netflix 在他们的生产环境搭建一个服务用于定时随机关闭服务器，用以模拟服务器正常损坏或服务异常，他们的系统长期在这种环境下运行，“服务器故障”成为系统每日都要面临的问题，因此当服务器真的以外故障时不会对系统整体造成任何的影响。</p><h2 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h2><p>全局优化、快速反馈、鼓励失败。我们发现其实敏捷、精益、持续交付、DevOps中间有很多相似的东西。</p><blockquote><p>参考资料: <a href="https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec" target="_blank" rel="noopener">https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec</a></p></blockquote><blockquote><p><a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">http://itrevolution.com/the-three-ways-principles-underpinning-devops/</a></p></blockquote><p>转发自：@duyidong</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇博客中提到的“三种方式“源自 &lt;a href=&quot;http://www.itrevolution.com/book/the-devops-
      
    
    </summary>
    
      <category term="Program" scheme="http://heartaway.cn/categories/Program/"/>
    
    
  </entry>
  
</feed>
